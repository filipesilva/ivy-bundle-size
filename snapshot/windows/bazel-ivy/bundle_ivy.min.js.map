{"version":3,"sources":["../../../../../../../external/angular/packages/core/src/util/property.ts","../../../../../../external/npm/node_modules/tslib/tslib.es6.js","../../../../../../../external/angular/packages/core/src/render3/fields.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/injector.ts","../../../../../../../external/angular/packages/core/src/util.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/container.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/context.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/view.ts","../../../../../../../external/angular/packages/core/src/render3/util.ts","../../../../../../../external/angular/packages/core/src/di/injector_compatibility.ts","../../../../../../../external/angular/packages/core/src/render3/state.ts","../../../../../../../external/angular/packages/core/src/render3/hooks.ts","../../../../../../../external/angular/packages/core/src/render3/di.ts","../../../../../../../external/angular/packages/core/src/render3/context_discovery.ts","../../../../../../../external/angular/packages/core/src/render3/tokens.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/projection.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/renderer.ts","../../../../../../../external/angular/packages/core/src/render3/styling/util.ts","../../../../../../../external/angular/packages/core/src/render3/instructions.ts","../../../../../../../external/angular/packages/core/src/render3/node_manipulation.ts","../../../../../../../external/angular/packages/core/src/render3/component.ts","../../../../../../../external/angular/packages/core/src/di/injector.ts","../../../../../external/rxjs/internal/util/isArray.ts","../../../../../external/rxjs/internal/util/UnsubscriptionError.ts","../../../../../external/rxjs/internal/symbol/observable.ts","../../../../../external/rxjs/internal/util/ObjectUnsubscribedError.ts","../../../../../external/rxjs/internal/util/EmptyError.ts","../../../../../../../external/angular/packages/core/src/type.ts","../../../../../../../external/angular/packages/core/src/di/util.ts","../../../../../../../external/angular/packages/core/src/render3/jit/injectable.ts","../../../../../../../external/angular/packages/core/src/render3/definition.ts","../../../../src/main.ngtsc.ts"],"names":["getClosureSafeProperty","objWithPropertyToExtract","key","Error","Object","setPrototypeOf","Array","NodeInjectorFactory","NG_COMPONENT_DEF","ngComponentDef","NG_ELEMENT_ID","__NG_ELEMENT_ID__","__window","window","__self","self","WorkerGlobalScope","_global","global","ACTIVE_INDEX","VIEWS","MONKEY_PATCH_KEY_NAME","PARENT_INJECTOR","INJECTOR_BLOOM_PARENT_SIZE","NO_PARENT_INJECTOR","FactoryPrototype","factory","isViewProvider","injectImplementation","this","resolving","canSeeViewProviders","injectImpl","prototype","TVIEW","FLAGS","PARENT","NEXT","HOST","HOST_NODE","BINDING_INDEX","CONTEXT","INJECTOR","RENDERER_FACTORY","RENDERER","SANITIZER","CONTAINER_INDEX","DECLARATION_VIEW","HEADER_OFFSET","readElementValue","value","isArray","readPatchedLView","target","readPatchedData","lView","_injectImplementation","previousOrParentTNode","isParent","defaultScheduler","requestAnimationFrame","setTimeout","bind","setInjectImplementation","impl","previous","executeHooks","currentView","allHooks","checkHooks","checkNoChangesMode","hooksToCall","callHooks","arr","i","length","call","getPreviousOrParentTNode","setPreviousOrParentTNode","tNode","setTNodeAndViewData","view","getIsParent","setIsParent","isCreationMode","getCheckNoChangesMode","enterView","newView","hostTNode","oldView","leaveView","tView","viewHooks","viewCheckHooks","bindingStartIndex","includeViewProviders","setIncludeViewProviders","v","oldValue","BLOOM_MASK","BLOOM_SIZE","nextNgElementId","insertBloom","footer","push","attachPatchData","data","NO_CHANGE","NG_PROJECT_AS_ATTR_NAME","isProceduralRenderer","renderer","domRendererFactory3","createRenderer","hostElement","rendererType","document","ANIMATION_PROP_PREFIX","refreshDescendantViews","firstTemplatePass","executeInitHooks","initHooks","refreshDynamicEmbeddedViews","current","getLViewChild","childIndex","container_1","dynamicViewData","renderEmbeddedTemplate","refreshContentQueries","contentQueries","directiveDefIdx","contentQueriesRefresh","contentHooks","contentCheckHooks","setHostBindings","viewData","expandoInstructions","bindingRootIndex","expandoStartIndex","currentDirectiveIndex","currentElementIndex","instruction","providerCount","refreshChildComponents","components","viewAttached","hostView","getComponentViewByIndex","nodeIndex","slotValue","getLView","syncViewWithBlueprint","componentView","componentTView","blueprint","checkView","component","hostTView","templateFn","template","viewQuery","createViewQuery","getRenderFlags","updateViewQuery","createLView","parentLView","context","flags","rendererFactory","sanitizer","injector","slice","viewToRender","_isParent","_previousOrParentTNode","tickRootContext","rootContext","rootComponent","renderComponentOrTemplate","getRootContext","viewOrComponent","getRootView","normalExecutionPath","begin","end","createTView","viewIndex","consts","vars","directives","pipes","initialViewLength","createViewBlueprint","fill","id","node","destroyHooks","pipeDestroyHooks","cleanup","directiveRegistry","pipeRegistry","firstChild","CLEAN_PROMISE","Promise","resolve","createRootComponentView","rNode","def","rootView","resetComponentState","getOrCreateTView","ngPrivateData","directiveDefs","pipeDefs","onPush","createNodeAtIndex","index","type","native","name","attrs","adjustedIndex","createTNode","tagName","tViews","parent","tParent","injectorIndex","directiveStart","directiveEnd","providerIndexes","localNames","initialInputs","undefined","inputs","outputs","next","child","detached","stylingTemplate","projection","diPublicInInjector","token","bloomAdd","charCodeAt","bloomBit","mask","b6","b5","tData","getOrCreateNodeInjectorForNode","existingInjectorIndex","getInjectorIndex","parentLoc","getParentInjectorLocation","viewOffset","parentIndex","getParentInjectorIndex","parentLocation","getParentInjectorView","location","startView","getParentInjectorViewOffset","parentView","hasParentInjector","parentData","initNodeFlags","numberOfDirectives","queueComponentIndexForCheck","String","Symbol","Function","renderComponent","componentType","opts","componentDef","getComponentDef","hostRNode","locateHostElement","elementOrSelector","defaultRenderer","selectRootElement","querySelector","host","selectors","rootFlags","createRootContext","scheduler","playerHandler","clean","createRootComponent","hostFeatures","instantiateRootComponent","rootTNode","providersResolver","generateExpandoInstructionBlock","directiveCount","elementIndex","baseResolveDirective","directiveFactory","nodeInjectorFactory","isComponentDef","directive","getNodeInjectable","lData","isFactory","obj","getPrototypeOf","stringify","previousIncludeViewProviders","previousInjectImplementation","savePreviousOrParentTNode","saveLView","postProcessBaseDirective","getNativeByTNode","attributes","setUpAttributes","isProc","attrName","namespaceURI","attrName_1","attrVal","setAttribute","setAttributeNS","setProperty","forEach","feature","hostBindings","HelloWorld"],"mappings":"yBAQA,SAAAA,EAA0CC,GACxC,IAAK,IAAIC,KAAOD,EACd,GAAIA,EAAyBC,KAASF,EACpC,OAAOE,EAGX,MAAMC,MAAM,qDCEMC,OAAOC,gBACOC,MASZF,OChBf,ICuHPG,EDvHaC,EAAmBR,GAAwBS,eAAgBT,IAa3DU,EAAgBV,GAAwBW,kBAAmBX,IETlEY,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAyB,oBAATC,MAAqD,oBAAtBC,mBACjDD,gBAAgBC,mBAAqBD,KAKnCE,EAJ6B,oBAAXC,QAA0BA,QAICN,GAAYE,ECFlDK,EAAe,EACfC,EAAQ,ECLRC,EAAwB,gBHAxBC,EAAkB,EAClBC,EAA6B,EAgB7BC,GAAgD,EAkNvDC,GAjHNlB,EAmFE,SAAAA,EAIWmB,EAmBPC,EACAC,GApBOC,KAAAH,QAAAA,EA7EXG,KAAAC,WAAY,EAkGVD,KAAKE,oBAAsBJ,EAC3BE,KAAKG,WAAaJ,IAIuBK,UIxNhCC,EAAQ,EACRC,EAAQ,EACRC,EAAS,EACTC,EAAO,EAEPC,EAAO,EACPC,EAAY,EACZC,EAAgB,EAEhBC,EAAU,EACVC,EAAW,GACXC,EAAmB,GACnBC,EAAW,GACXC,EAAY,GAEZC,EAAkB,GAElBC,EAAmB,GAEnBC,EAAgB,GCqC7B,SAAAC,EAAiCC,GAC/B,KAAO5C,MAAM6C,QAAQD,IACnBA,EAAQA,EAAMZ,GAEhB,OAAOY,EA+ET,SAAAE,EAAiCC,GAC/B,IAAMH,EANR,SAAAI,EAAgCD,GAE9B,OAAOA,EAAOhC,GAIAiC,CAAgBD,GAC9B,OAAIH,EACK5C,MAAM6C,QAAQD,GAASA,EAASA,EAAmBK,MAErD,KA0EF,ICpLHC,ECsEAC,EAqBAC,EA4CAH,EF6CSI,GACyB,oBAA1BC,uBAAyCA,uBAChDC,YACEC,KAAK5C,GCjLZ,SAAA6C,EACIC,GAEF,IAAMC,EAAWT,EAEjB,OADAA,EAAwBQ,EACjBC,EEiCT,SAAAC,EACIC,EAAoBC,EAA2BC,EAC/CC,GACF,IAAIA,EAAJ,CAEA,IAAMC,EAAgC,EAAlBJ,EAAYhC,GAAqCiC,EAAWC,EAC5EE,GAYN,SAAAC,EAA0BL,EAAoBM,GAC5C,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAIE,OAAQD,GAAK,EAClCD,EAAIC,EAAI,GAAiBE,KAAKT,EAAYM,EAAIC,KAb/CF,CAAUL,EAAaI,iBDEzB,OAAOhB,EAmBT,SAAAsB,IAEE,OAAOpB,EAGT,SAAAqB,EAAyCC,GACvCtB,EAAwBsB,EAG1B,SAAAC,EAAoCD,EAAcE,GAChDxB,EAAwBsB,EACxBxB,EAAQ0B,EAUV,SAAAC,IAEE,OAAOxB,EAGT,SAAAyB,EAA4BjC,GAC1BQ,EAAWR,EA0Bb,SAAAkC,EAA+BH,GAC7B,YAD6B,IAAAA,IAAAA,EAAA1B,GACV,IAAA,EAAX0B,EAAK9C,IAiBf,IAYImC,GAAqB,EAEzB,SAAAe,IAEE,OAAOf,EA8CT,SAAAgB,EAA0BC,EAAgBC,GACxC,IAAMC,EAAUlC,EAWhB,OAJAE,EAAwB+B,EACxB9B,GAAW,EAEXH,EAAuBgC,EAChBE,EAmCT,SAAAC,EAA0BH,GACxB,IAAMI,EAAQpC,EAAMrB,GAChBkD,EAAe7B,GACjBA,EAAMpB,KAAU,GAEhB+B,EAAaX,EAAOoC,EAAMC,UAAWD,EAAME,eAAgBvB,GAE3Df,EAAMpB,KAAU,GAChBoB,EAAMpB,IAAM,GACZoB,EAAMf,GAAiBmD,EAAMG,mBAE/BR,EAAUC,EAAS,MEzQrB,IAAIQ,GAAuB,EAE3B,SAAAC,EAAiCC,GAC/B,IAAMC,EAAWH,EAEjB,OADAA,EAAuBE,EAChBC,EAQT,IACMC,EAAaC,IAGfC,EAAkB,EA8FtB,SAAAC,EAAqB7B,EAAY8B,GAC/B9B,EAAI+B,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAGD,GCDnC,SAAAE,GAAgCpD,EAAaqD,GAC3CrD,EAAOhC,GAAyBqF,EChK3B,IAAMC,MCqDAC,GAA0B,cCtBvC,SAAAC,GAAqCC,GAEnC,QAAWA,EAAuB,OAkD7B,IAAMC,IACXC,eAAgB,SAACC,EAA8BC,GACZ,OAAOC,WC7EtCC,GAAwB,ICyC9B,SAAAC,GAAuC9D,GACrC,IAAMoC,EAAQpC,EAAMrB,GAOpB,GALAyD,EAAM2B,mBAAoB,GAKrBlC,EAAe7B,GAAQ,CAC1B,IAAMe,EAAqBe,KPuB/B,SAAAkC,EACIpD,EAAoBwB,EAAcrB,IAC/BA,GAAwC,GAAlBH,EAAYhC,KACrC+B,EAAaC,EAAawB,EAAM6B,UAAW7B,EAAMtB,WAAYC,GAC7DH,EAAYhC,KAAU,IOzBtBoF,CAAiBhE,EAAOoC,EAAOrB,GA24DnC,SAAAmD,EAAqClE,GACnC,IAAK,IAAImE,EC9kDX,SAAAC,EAA8BpE,GAC5B,IAAMqE,EAAarE,EAAMrB,GAAO0F,WAChC,OAAuB,IAAhBA,EAAoB,KAAOrE,EAAMqE,GD4kDrBD,CAAcpE,GAAoB,OAAZmE,EAAkBA,EAAUA,EAAQrF,GAI3E,GAAIqF,EAAQ/C,OAAS3B,IAA4C,IAA3B0E,EAAQvG,GAE5C,IADA,IAAM0G,EAAYH,EACThD,EAAI,EAAGA,EAAImD,EAAUzG,GAAOuD,OAAQD,IAAK,CAChD,IAAMoD,EAAkBD,EAAUzG,GAAOsD,GAGzCqD,GAAuBD,EAAiBA,EAAgB5F,GAAQ4F,EAAgBrF,KAp5DpFgF,CAA4BlE,GAuDhC,SAAAyE,EAA+BrC,GAC7B,GAA4B,MAAxBA,EAAMsC,eACR,IAAK,IAAIvD,EAAI,EAAGA,EAAIiB,EAAMsC,eAAetD,OAAQD,GAAK,EAAG,CACvD,IAAMwD,EAAkBvC,EAAMsC,eAAevD,GACxBiB,EAAMe,KAAKwB,GAEnBC,sBACTD,EAAkBlF,EAAe2C,EAAMsC,eAAevD,EAAI,KA3DhEsD,CAAsBrC,GAEtBzB,EAAaX,EAAOoC,EAAMyC,aAAczC,EAAM0C,kBAAmB/D,GAUrE,SAAAgE,EAAgC3C,EAAc4C,GAC5C,GAAI5C,EAAM6C,oBAKR,IAJA,IAAIC,EAAmBF,EAAS/F,GAAiBmD,EAAM+C,kBAEnDC,GAAyB,EACzBC,GAAuB,EAClBlE,EAAI,EAAGA,EAAIiB,EAAM6C,oBAAoB7D,OAAQD,IAAK,CACzD,IAAMmE,EAAclD,EAAM6C,oBAAoB9D,GAC9C,GAA2B,iBAAhBmE,EACT,GAAIA,GAAe,EAAG,CAGpBD,GAAuBC,EAEvB,IAAMC,EAAiBnD,EAAM6C,sBAAsB9D,GAGnDiE,EAFAF,GAAoBlH,EAA6BuH,OAOjDL,GAAoBI,OAKF,OAAhBA,IACFN,EAAS/F,GAAiBiG,EAC1BI,EAAW,EACa5F,EAAiBsF,EAASI,IAC9CC,IAEND,KAzCJL,CAAgB3C,EAAOpC,IA6D3B,SAAAwF,EAAgCC,GAC9B,GAAkB,MAAdA,EACF,IAAK,IAAItE,EAAI,EAAGA,EAAIsE,EAAWrE,OAAQD,KAmgE3C,SAAAuE,EAA6BhE,GAC3B,OAAmB,KAAA,GAAXA,EAAK9C,KAzCT8G,CAJEC,EV9/DR,SAAAC,EAAwCC,EAAmBF,GAEzD,IAAMG,EAAYH,EAASE,GAC3B,OAAOC,EAAU1E,QAAU3B,EAAgBqG,EAAYA,EAAU/G,GU2/DhD6G,CAt9DIH,EAAWtE,GAo9DlB4E,OAM+B,GAAfJ,EAAS/G,KAgCzC,SAAAoH,EAA+BC,GAE7B,IADA,IAAMC,EAAiBD,EAActH,GAC5BwC,EAAI8E,EAAc7E,OAAQD,EAAI+E,EAAeC,UAAU/E,OAAQD,IACtE8E,EAAc9E,GAAK+E,EAAeC,UAAUhF,GAlC5C6E,CAAsBL,GAwW1B,SAAAS,EAA6BT,EAAiBU,GAC5C,IAAMC,EAAYX,EAAShH,GACrBuD,EAAUH,EAAU4D,EAAUA,EAAS3G,IACvCuH,EAAaD,EAAUE,SACvBC,EAAYH,EAAUG,UAE5B,KAWF,SAAAC,EAA4BD,EAAqC/E,EAAa2E,GACxEI,GAAa5E,EAAeH,IAC9B+E,EAAS,EAAqBJ,IAX9BK,CAAgBD,EAAWd,EAAUU,GACrCE,EAAWI,GAAehB,GAAWU,GACrCvC,GAAuB6B,GAa3B,SAAAiB,EAA4BH,EAAqC/E,EAAa2E,GACxEI,IAAc5E,EAAeH,IAC/B+E,EAAS,EAAqBJ,GAd9BO,CAAgBH,EAAWd,EAAUU,WAErClE,EAAUD,IApXVkE,CAAUT,EAAUA,EAASzG,KATjC,IAGQyG,EAnhENH,CAAuBpD,EAAMqD,YAkE/B,SAAAoB,GACIC,EAA2B1E,EAAc2E,EAAmBC,EAC5DC,EAA2C1D,EAC3C2D,EAA8BC,GAChC,IAAMnH,EAAQoC,EAAM+D,UAAUiB,QAW9B,OAVApH,EAAMpB,GAAc,GAALoI,EAEfhH,EAAMnB,GAAUmB,EAAMR,GAAoBsH,EAC1C9G,EAAMd,GAAW6H,EACjB/G,EAAMZ,GAAqB6H,GAAmBH,GAAeA,EAAY1H,GAEzEY,EAAMX,GAAakE,GAAYuD,GAAeA,EAAYzH,GAE1DW,EAAMV,GAAa4H,GAAaJ,GAAeA,EAAYxH,IAAc,KACzEU,EAAMb,GAAmBgI,GAAYL,GAAeA,EAAY3H,IAAa,KACtEa,EAkLT,SAAAwE,GAA0C6C,EAAqBjF,EAAc2E,GAC3E,IAII7E,EAJEoF,EAAY3F,IACZ4F,EAAyBjG,IAI/B,GAHAM,GAAY,GACZL,EAAyB,MAEF,IAAnB8F,EAAazI,IAqiEnB,SAAA4I,EAAyBC,GACvB,IAAK,IAAItG,EAAI,EAAGA,EAAIsG,EAAYhC,WAAWrE,OAAQD,IAAK,CACtD,IAAMuG,EAAgBD,EAAYhC,WAAWtE,GAC7CwG,GAA0B9H,EAAiB6H,GAAkBA,IAtiE7DF,CV5MJ,SAAAI,EAA+BC,GAI7B,OAbF,SAAAC,EAA4BhI,GAG1B,IADA,IAAIE,EAAQjD,MAAM6C,QAAQE,GAAWA,EAAmBD,EAAiBC,GAClEE,KAAuB,IAAZA,EAAMpB,KACtBoB,EAAQA,EAAMnB,GAEhB,OAAOmB,EAIU8H,CAAYD,GAGb3I,GUwME0I,CAAeP,SAE/B,IACEzF,GAAY,GACZL,EAAyB,MAEzBW,EAAUH,EAAUsF,EAAcA,EAAarI,IAE/CoD,EAAMoE,SAAWG,GAAeU,GAAeN,GAK/CM,EAAa1I,GAAOoF,mBAAoB,EAGxCD,GAAuBuD,WAEvBlF,EAAUD,GACVN,EAAY0F,GACZ/F,EAAyBgG,IAmB/B,SAAAI,GACIhC,EAAiBoB,EAAYR,GAC/B,IAAMU,EAAkBtB,EAASvG,GAC3B8C,EAAUH,EAAU4D,EAAUA,EAAS3G,IACvC+I,GAAuBjG,IAC7B,IACMiG,GAAuBd,EAAgBe,OACzCf,EAAgBe,QAGdnG,EAAe8D,KAEbY,GAEFA,EAAU,EAAqBQ,GAGjCjD,GAAuB6B,GACvBA,EAAS/G,KAAU,GAIrB2H,GAAcA,EAAU,EAAqBQ,GAC7CjD,GAAuB6B,WAEnBoC,GAAuBd,EAAgBgB,KACzChB,EAAgBgB,MAElB9F,EAAUD,IASd,SAAAyE,GAAwBjF,GACtB,OAAOG,EAAeH,GAAK,EAAA,EA2Q7B,SAAAwG,GACIC,EAAmB5B,EAA0C6B,EAAgBC,EAC7EC,EAA8CC,EAC9C9B,GAEF,IAAMlE,EAAoB9C,EAAgB2I,EAIpCI,EAAoBjG,EAAoB8F,EACxClC,EA8BR,SAAAsC,EAA6BlG,EAA2BiG,GACtD,IAAMrC,EAAY,IAAIpJ,MAAMyL,GACLE,KAAK,KAAM,EAAGnG,GACdmG,KAAKtF,GAAWb,GAGvC,OAFA4D,EAAU5G,IAAoB,EAC9B4G,EAAUlH,GAAiBsD,EACpB4D,EApCWsC,CAAoBlG,EAAmBiG,GACzD,OAAOrC,EAAUxH,IACfgK,GAAIR,EACJhC,UAAWA,EACXK,SAAUD,EACVE,UAAWA,EACXmC,KAAM,KACNzF,KAAMgD,EAAUiB,QAChB/C,YAAa,EACb9B,kBAAmBA,EACnB4C,kBAAmBqD,EACnBvD,oBAAqB,KACrBlB,mBAAmB,EACnBE,UAAW,KACXnD,WAAY,KACZ+D,aAAc,KACdC,kBAAmB,KACnBzC,UAAW,KACXC,eAAgB,KAChBuG,aAAc,KACdC,iBAAkB,KAClBC,QAAS,KACTrE,eAAgB,KAChBe,WAAY,KACZuD,kBAAyC,mBAAfV,EAA4BA,IAAeA,EACrEW,aAA+B,mBAAVV,EAAuBA,IAAUA,EACtDW,WAAY,MA0kET,IAAMC,GArvFUC,QAAQC,QAAQ,ME2GvC,SAAAC,GACIC,EAAwBC,EAAwBC,EAChDxC,EAAmC1D,EAAqB2D,IVgJ5D,SAAAwC,IACEvJ,GAAW,EACXD,EAAwB,KUjJxBwJ,GACA,IAAMtH,EAAQqH,EAAS9K,GACjBsH,EAAgBY,GAClB4C,EF6fN,SAAAE,EACIpD,EAAoC6B,EAAgBC,EACpDC,EAA8CC,EAC9C9B,GAQF,OAAOF,EAAWqD,gBACbrD,EAAWqD,cACP1B,IAAa,EAAG3B,EAAY6B,EAAQC,EAAMC,EAAYC,EAAO9B,IEzgBlEkD,CACIH,EAAIhD,SAAUgD,EAAIpB,OAAQoB,EAAInB,KAAMmB,EAAIK,cAAeL,EAAIM,SAAUN,EAAI/C,WAC7E,KAAM+C,EAAIO,OAAM,EAAA,EAA8C9C,EAAiB1D,EAC/E2D,GACE1F,EF2BR,SAAAwI,EACIC,EAAeC,EAAiBC,EAA4CC,EAC5EC,GAEF,IAAMrK,EAAQ+F,IACR3D,EAAQpC,EAAMrB,GACd2L,EAAgBL,EAAQxK,EAG9BO,EAAMsK,GAAiBH,EAEvB,IAAI3I,EAAQY,EAAMe,KAAKmH,GACV,MAAT9I,IAEFA,EAAQY,EAAMe,KAAKmH,GA81BvB,SAAAC,EACIvK,EAAckK,EAAiBI,EAAuBE,EACtDH,EAA2BI,GAC7B,IAAMvK,EAAwBoB,IAExBoJ,EACF/I,IAAgBzB,EAAwBA,GAAyBA,EAAsBwK,OAKrFC,EADmBD,GAAU1K,GAAS0K,IAAW1K,EAAMhB,GAC1B0L,EAA0C,KAE7E,OACER,KAAMA,EACND,MAAOK,EACPM,cAAeD,EAAUA,EAAQC,eAAiB,EAClDC,gBAAiB,EACjBC,cAAe,EACf9D,MAAO,EACP+D,gBAAiB,EACjBP,QAASA,EACTH,MAAOA,EACPW,WAAY,KACZC,mBAAeC,EACfC,YAAQD,EACRE,aAASF,EACTT,OAAQA,EACRY,KAAM,KACNC,MAAO,KACPZ,OAAQC,EACRY,SAAU,KACVC,gBAAiB,KACjBC,WAAY,MA/3BwBlB,CAAYvK,EAAOkK,EAAMI,EAAeF,EAAMC,EAAO,OAM3F,IAAMnK,EAAwBoB,IACxBnB,EAAWwB,IAiBjB,OAhBIzB,KACEC,GAA2C,MAA/BD,EAAsBoL,OAChB,OAAjB9J,EAAMkJ,QAA6C,IAA1BxK,EAAsBgK,KAGxC/J,IACVD,EAAsBmL,KAAO7J,GAF7BtB,EAAsBoL,MAAQ9J,GAMV,MAApBY,EAAM8G,aACR9G,EAAM8G,WAAa1H,GAGrBD,EAAyBC,GACzBI,GAAY,GACLJ,EEjEOwI,CAAkB,EAAC,EAAqBT,EAAO,KAAM,MAYnE,OAVInH,EAAM2B,oBRwDZ,SAAA2H,EACId,EAAuBlJ,EAAaiK,IA1IxC,SAAAC,EACIhB,EAAuBxI,EAAc8H,GAEvC,IAAIvB,EACgB,iBAATuB,EAAqBA,EAAa/M,GAAiB+M,EAAK2B,WAAW,IAAM,EAI1E,MAANlD,IACFA,EAAMuB,EAAa/M,GAAiB2F,KAKtC,IAAMgJ,EAAWnD,EAAK/F,EAKhBmJ,EAAO,GAAKD,EAKZE,EAAgB,GAAXF,EACLG,EAAgB,GAAXH,EACLI,EAAQ9J,EAAMe,KAHE,IAAX2I,EAMTE,EAAMC,EAAMC,EAAMtB,EAAgB,IAAMmB,EAASG,EAAMtB,EAAgB,IAAMmB,EACvEE,EAAMC,EAAMtB,EAAgB,IAAMmB,EAASG,EAAMtB,EAAgB,IAAMmB,EAE7EC,EAAMC,EAAMC,EAAMtB,EAAgB,IAAMmB,EAASG,EAAMtB,EAAgB,IAAMmB,EACvEE,EAAMC,EAAMtB,EAAgB,IAAMmB,EAASG,EAAMtB,IAAkBmB,EA0G3EH,CAAShB,EAAelJ,EAAK/C,GAAQgN,GQzDnCD,CRtCJ,SAAAS,EACI3K,EAA8DmE,GAChE,IAAMyG,EA2CR,SAAAC,EAAiC7K,EAAcmE,GAC7C,OAA6B,IAAzBnE,EAAMoJ,eAGLpJ,EAAMkJ,QAAUlJ,EAAMkJ,OAAOE,gBAAkBpJ,EAAMoJ,eAGH,MAAnDjF,EAASnE,EAAMoJ,cAAgB7M,IACzB,EAEDyD,EAAMoJ,cArDeyB,CAAiB7K,EAAOmE,GACtD,IAA+B,IAA3ByG,EACF,OAAOA,EAGT,IAAMhK,EAAQuD,EAAShH,GACnByD,EAAM2B,oBACRvC,EAAMoJ,cAAgBjF,EAASvE,OAC/B2B,EAAYX,EAAMe,KAAM3B,GACxBuB,EAAY4C,EAAU,MACtB5C,EAAYX,EAAM+D,UAAW,OAO/B,IAAMmG,EA8CR,SAAAC,EAA0C/K,EAAcE,GACtD,GAAIF,EAAMkJ,SAA0C,IAAhClJ,EAAMkJ,OAAOE,cAC/B,OAAOpJ,EAAMkJ,OAAOE,cAQtB,IAFA,IAAI3I,EAAYP,EAAK1C,GACjBwN,EAAa,EACVvK,IAA0C,IAA7BA,EAAU2I,eAE5B3I,GADAP,EAAOA,EAAKlC,IACOkC,EAAK1C,GAAa,KACrCwN,IAGF,OAAOvK,EACHA,EAAU2I,cAAiB4B,GAAU,IACpC,EAhEaD,CAA0B/K,EAAOmE,GAC7C8G,EJwBR,SAAAC,EAAuCC,GACrC,OAAwC,MAAhCA,EIzBYD,CAAuBJ,GACrCxF,EJwCR,SAAA8F,EAAsCC,EAAoCC,GAOxE,IANA,IAAIN,EAdN,SAAAO,EAA4CJ,GAC1C,OAAQA,GAAgC,GAavBI,CAA4BF,GACzCG,EAAaF,EAKVN,EAAa,GAClBQ,EAAaA,EAAWxN,GACxBgN,IAEF,OAAOQ,EInDaJ,CAAsBN,EAAW3G,GAE/CiF,EAAgBpJ,EAAMoJ,cAI5B,GJaF,SAAAqC,EAAkCN,GAChC,OAAOA,IAAmB1O,EIdtBgP,CAAkBX,GAIpB,IAHA,IAAMY,EAAapG,EAAYnI,GAAOwE,KAG7BhC,EAAI,EAAGA,EAAI,EAAGA,IACrBwE,EAASiF,EAAgBzJ,GAAK2F,EAAY2F,EAActL,GAAK+L,EAAWT,EAActL,GAK1F,OADAwE,EAASiF,EAAgB7M,GAAmBuO,EACrC1B,EQCcuB,CAA+B3K,EAAOiI,GAAWA,EAAUD,EAAIU,MAClF1I,EAAMwF,MAAK,EFsgDf,SAAAmG,EAA8B3L,EAAcyI,EAAemD,GAWzD5L,EAAMwF,MAAa,EATLxF,EAAMwF,MAUpBxF,EAAMqJ,eAAiBZ,EACvBzI,EAAMsJ,aAAeb,EAAQmD,EAC7B5L,EAAMuJ,gBAAkBd,EEnhDtBkD,CAAc3L,EAAOiI,EAASrI,OAAQ,GFq8C1C,SAAAiM,EAA4CnN,GAG1C,IAAMkC,EAAQ2D,IAAWpH,IACxByD,EAAMqD,aAAerD,EAAMqD,gBAAkBxC,KAAK/C,EAAsB+J,OEx8CvEoD,CAA4B7L,IAI9ByE,EAAclH,GAAQ0K,EAAShK,GAC/BwG,EAAcjH,GAAawC,EACpBiI,EAAShK,GAAiBwG,ECjDiBqH,OCnI7BvQ,MCkB2BH,MCNN,mBAAX2Q,QAAyBA,OCEJ3Q,MCAbA,MCIrB4Q,SCFgCF,OCmEAA,OTmBpD,SAAAG,GACIC,EAGAC,QAAA,IAAAA,IAAAA,MAGF,IAAM1G,EAAkB0G,EAAK1G,iBAAmBzD,GAC1C0D,EAAYyG,EAAKzG,WAAa,KAC9B0G,EUohBR,SAAAC,EAAmC3D,GACjC,OAAQA,EAAajN,IAAqB,KVrhBrB4Q,CAAmBH,GACpCE,EAAa1D,MAAQwD,IAAeE,EAAa1D,KAAOwD,GAG5D,IACMI,EF2qBR,SAAAC,EACI5P,EAA2B6P,GAC7B,IAAMC,EAAkB9P,EAAQsF,eAAe,KAAM,MAarD,MAZ2C,iBAAtBuK,EAChB1K,GAAqB2K,GACjBA,EAAgBC,kBAAkBF,GAClCC,EAAgBE,cAAcH,GACnCA,EElrBcD,CAAkB9G,EAAiB0G,EAAKS,MADrCR,EAAaS,UAAY,GAAK,IAE7CC,EAAYV,EAAa7D,OAAS,IACA,IAClCtC,EA2FR,SAAA8G,EACIC,EAA0CC,GAC5C,OACEhJ,cACA+I,UAAWA,GAAapO,EACxBsO,MAAOvF,GACPsF,cAAeA,GAAiB,KAChCzH,MAAK,GAlGauH,CAAkBZ,EAAKa,UAAWb,EAAKc,eAErDlL,EAAW0D,EAAgBxD,eAAeqK,EAAWF,GACrDnE,EAAkB5C,GACpB,KAAMqB,IAAa,EAAG,KAAM,EAAG,EAAG,KAAM,KAAM,MAAOT,EAAa6G,EAAWrH,EAC7E1D,OAAU2H,EAAWyC,EAAKxG,UAAY,MAEpCjF,EAAUH,EAAU0H,EAAU,MAEpC,IACMxC,EAAgBe,OAAOf,EAAgBe,QA0D/C,SAAA2G,EACI1I,EAAsB2H,EAA+BnE,EAAiBhC,EACtEmH,GACF,IAAMxM,EAAQqH,EAAS9K,GAEjB0H,EF2tCR,SAAAwI,EACIzM,EAAc4C,EAAiBwE,GACjC,IAAMsF,EAAYxN,IACdc,EAAM2B,oBACJyF,EAAIuF,mBAAmBvF,EAAIuF,kBAAkBvF,GAoGrD,SAAAwF,EACI5M,EAAcZ,EAAcyN,GAK9B,IAAMC,IAAiB1N,EAAMyI,MAAQxK,GAE/B8F,EAAgBnD,EAAMe,KAAK/B,QADe,MAArBI,EAAMuJ,kBAEhC3I,EAAM6C,sBAAwB7C,EAAM6C,yBAChChC,KAAKiM,EAAc3J,EAAe0J,GA7GrCD,CAAgC5M,EAAO0M,EAAW,GAmStD,SAAAK,EACI/M,EAAc4C,EAAiBwE,EAC/B4F,GACFhN,EAAMe,KAAKF,KAAKuG,GAChB,IAAM6F,EAAsB,IAAIrS,EAAoBoS,EV9kDtD,SAAAE,EAAkC9F,GAChC,OAA6C,OAArCA,EAAwBhD,SU6kDsC8I,CAAe9F,GAAM,MAC3FpH,EAAM+D,UAAUlD,KAAKoM,GACrBrK,EAAS/B,KAAKoM,GAxSZF,CAAqB/M,EAAO4C,EAAUwE,EAAKA,EAAIrL,UAEjD,IAAMoR,EN77BR,SAAAC,EACItD,EAAcuD,EAAcxF,EAAezI,GAC7C,IAAI7B,EAAQ8P,EAAMxF,GAClB,GTtPF,SAAAyF,EAA0BC,GAExB,OAAc,MAAPA,GAA6B,iBAAPA,GAAmB9S,OAAO+S,eAAeD,IAAQzR,ESoP1EwR,CAAU/P,GAAQ,CACpB,IAAMxB,EAA+BwB,EACrC,GAAIxB,EAAQI,UACV,MAAM,IAAI3B,MAAM,+BJ7cI+C,GACxB,MAAoB,mBAATA,EAA4BA,EAAMyK,MAAQzK,EACjC,iBAATA,EAA0BA,EACxB,MAATA,EAAsB,GACN,iBAATA,GAA0C,mBAAdA,EAAMuK,KACpCvK,EAAMuK,KAAKE,MAAQzK,EAAMuK,KAC3B,GAAKvK,EIuc4BkQ,CAAU3D,EAAMjC,KAEtD,IAAM6F,EAA+BrN,EAAwBtE,EAAQK,qBACrEL,EAAQI,WAAY,EACpB,IAAIwR,OAA4B,EAC5B5R,EAAQM,aACVsR,EAA+BvP,EAAwBrC,EAAQM,aAEjE,IAAMuR,EAA4B1O,IAC5B2O,EAAYlK,IAClBtE,EAAoBD,EAAOiO,GAC3B,IACE9P,EAAQ8P,EAAMxF,GAAS9L,EAAQA,QAAQ,KAAM+N,EAAOuD,EAAOjO,WAEvDrD,EAAQM,YAAY+B,EAAwBuP,GAChDtN,EAAwBqN,GACxB3R,EAAQI,WAAY,EACpBkD,EAAoBuO,EAA2BC,IAGnD,OAAOtQ,EMo6BH6P,CAAkBpN,EAAMe,KAAM6B,EAAUA,EAAS5D,OAAS,EAAG0N,GAEjE,OAkJF,SAAAoB,EACIlQ,EAAcE,EAA8BqP,EAAc/F,GAC5D,IAAMW,EVj+CR,SAAAgG,EAQiC3O,EAAcmE,GAC7C,OAAOjG,EAAiBiG,EAASnE,EAAMyI,QUw9CxBkG,CAAiBjQ,EAAuBF,GAOvDkD,GAAgBqM,EAAWvP,GACvBmK,GACFjH,GAAgBiH,EAAQnK,GAIJ,MAAlBwJ,EAAI4G,YAAgD,GAA1BlQ,EAAsBgK,MA71BtD,SAAAmG,EAAyBlG,EAAkBE,GAKzC,IAJA,IAAM9G,EAAWwC,IAAW1G,GACtBiR,EAAShN,GAAqBC,GAChCpC,EAAI,EAEDA,EAAIkJ,EAAMjJ,QAAQ,CACvB,IAAMmP,EAAWlG,EAAMlJ,KACvB,GAAuB,iBAAZoP,EAAsB,CAC/B,GAAY,IAARA,EAYF,MAVA,IAAMC,EAAenG,EAAMlJ,KACrBsP,EAAWpG,EAAMlJ,KACjBuP,EAAUrG,EAAMlJ,KAEtBmP,EACK/M,EACIoN,aAAaxG,EAAQsG,EAAUC,EAASF,GAC7CrG,EAAOyG,eAAeJ,EAAcC,EAAUC,QAO9CA,EAAUrG,EAAMlJ,KAClBoP,IAAalN,KAGKkN,EDhqBd,KAAO1M,GCiqBPyM,GACD/M,EAAiCsN,YAAY1G,EAAQoG,EAAUG,GAGlEJ,EACK/M,EACIoN,aAAaxG,EAAQoG,EAAoBG,GAC9CvG,EAAOwG,aAAaJ,EAAoBG,KA0zBlDL,CAAgBlG,EAAoBX,EAAI4G,YAnK1CF,CAAyBlL,EAAU8J,EAAWS,EAAW/F,GAClD+F,EEtuCWV,CAAyBzM,EAAOqH,EAAUmE,GAO5D,GALAnG,EAAYhC,WAAWxC,KAAKoD,GAC5BJ,EAAc/G,GAAWmH,EAEzBuI,GAAgBA,EAAakC,QAAQ,SAACC,GAAY,OAAAA,EAAQ1K,EAAWuH,KAEjExL,EAAM2B,mBAAqB6J,EAAaoD,aAAc,CACxD,IAAMlC,EAAYxN,IAElBsM,EAAaoD,aAAY,EAAqB3K,EAAWyI,EAAU7E,MAAQxK,GAI7E,OAAO4G,EA1EOsI,CAFUrF,GAClBwE,EAAWF,EAAcnE,EAAUxC,EAAiB1D,EAAU2D,GAE/C0G,EAAcnE,EAAUhC,EAAakG,EAAKiB,cAAgB,MAE7E9K,GAAuB2F,GACvBA,EAAS7K,KAAU,EACnBkF,GAAuB2F,WAEvBtH,EAAUD,GACN+E,EAAgBgB,KAAKhB,EAAgBgB,OWvI7CwF,CAFA,SAAAwD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty as any) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport function fillProperties(target: {[key: string]: string}, source: {[key: string]: string}) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMPONENT_DEF = getClosureSafeProperty({ngComponentDef: getClosureSafeProperty});\nexport const NG_DIRECTIVE_DEF = getClosureSafeProperty({ngDirectiveDef: getClosureSafeProperty});\nexport const NG_INJECTABLE_DEF = getClosureSafeProperty({ngInjectableDef: getClosureSafeProperty});\nexport const NG_INJECTOR_DEF = getClosureSafeProperty({ngInjectorDef: getClosureSafeProperty});\nexport const NG_PIPE_DEF = getClosureSafeProperty({ngPipeDef: getClosureSafeProperty});\nexport const NG_MODULE_DEF = getClosureSafeProperty({ngModuleDef: getClosureSafeProperty});\nexport const NG_BASE_DEF = getClosureSafeProperty({ngBaseDef: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nexport const NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {InjectFlags} from '../../di/injector_compatibility';\nimport {Type} from '../../type';\nimport {TElementNode} from './node';\nimport {LView, TData} from './view';\n\nexport const TNODE = 8;\nexport const PARENT_INJECTOR = 8;\nexport const INJECTOR_BLOOM_PARENT_SIZE = 9;\n\n/**\n * Represents a relative location of parent injector.\n *\n * The interfaces encodes number of parents `LView`s to traverse and index in the `LView`\n * pointing to the parent injector.\n */\nexport interface RelativeInjectorLocation { __brand__: 'RelativeInjectorLocationFlags'; }\n\nexport const enum RelativeInjectorLocationFlags {\n  InjectorIndexMask = 0b111111111111111,\n  ViewOffsetShift = 16,\n  NO_PARENT = -1,\n}\n\nexport const NO_PARENT_INJECTOR: RelativeInjectorLocation = -1 as any;\n\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n\n/**\n* Factory for creating instances of injectors in the NodeInjector.\n*\n* This factory is complicated by the fact that it can resolve `multi` factories as well.\n*\n* NOTE: Some of the fields are optional which means that this class has two hidden classes.\n* - One without `multi` support (most common)\n* - One with `multi` values, (rare).\n*\n* Since VMs can cache up to 4 inline hidden classes this is OK.\n*\n* - Single factory: Only `resolving` and `factory` is defined.\n* - `providers` factory: `componentProviders` is a number and `index = -1`.\n* - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n*/\nexport class NodeInjectorFactory {\n  /**\n   * The inject implementation to be activated when using the factory.\n   */\n  injectImpl: null|(<T>(token: Type<T>|InjectionToken<T>, flags: InjectFlags) => T);\n\n  /**\n   * Marker set to true during factory invocation to see if we get into recursive loop.\n   * Recursive loop causes an error to be displayed.\n   */\n  resolving = false;\n\n  /**\n   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n   */\n  canSeeViewProviders: boolean;\n\n  /**\n   * An array of factories to use in case of `multi` provider.\n   */\n  multi?: Array<() => any>;\n\n  /**\n   * Number of `multi`-providers which belong to the component.\n   *\n   * This is needed because when multiple components and directives declare the `multi` provider\n   * they have to be concatenated in the correct order.\n   *\n   * Example:\n   *\n   * If we have a component and directive active an a single element as declared here\n   * ```\n   * component:\n   *   provides: [ {provide: String, useValue: 'component', multi: true} ],\n   *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],\n   *\n   * directive:\n   *   provides: [ {provide: String, useValue: 'directive', multi: true} ],\n   * ```\n   *\n   * Then the expected results are:\n   *\n   * ```\n   * providers: ['component', 'directive']\n   * viewProviders: ['component', 'componentView', 'directive']\n   * ```\n   *\n   * The way to think about it is that the `viewProviders` have been inserted after the component\n   * but before the directives, which is why we need to know how many `multi`s have been declared by\n   * the component.\n   */\n  componentProviders?: number;\n\n  /**\n   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n   * See `providerFactory`.\n   */\n  index?: number;\n\n  /**\n   * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is\n   * possible for `viewProvides` to shadow the `provides`. For this reason we store the\n   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n   *\n   * Example:\n   *\n   * Given:\n   * ```\n   * provides: [ {provide: String, useValue: 'all', multi: true} ],\n   * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n   * ```\n   *\n   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n   * of view injection. We further have to make sure that the shared instances (in our case\n   * `all`) are the exact same instance in both the content as well as the view injection. (We\n   * have to make sure that we don't double instantiate.) For this reason the `viewProvides`\n   * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the\n   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n   * ['all', 'viewOnly']`).\n   */\n  providerFactory?: NodeInjectorFactory|null;\n\n\n  constructor(\n      /**\n       * Factory to invoke in order to create a new instance.\n       */\n      public factory:\n          (this: NodeInjectorFactory, _: null,\n           /**\n            * array where injectables tokens are stored. This is used in\n            * case of an error reporting to produce friendlier errors.\n            */\n           tData: TData,\n           /**\n            * array where existing instances of injectables are stored. This is used in case\n            * of multi shadow is needed. See `multi` field documentation.\n            */\n           lView: LView,\n           /**\n            * The TNode of the same element injector.\n            */\n           tNode: TElementNode) => any,\n      /**\n       * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n       */\n      isViewProvider: boolean,\n      injectImplementation: null|(<T>(token: Type<T>|InjectionToken<T>, flags: InjectFlags) => T)) {\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\n\nconst FactoryPrototype = NodeInjectorFactory.prototype;\nexport function isFactory(obj: any): obj is NodeInjectorFactory {\n  // See: https://jsperf.com/instanceof-vs-getprototypeof\n  return obj != null && typeof obj == 'object' && Object.getPrototypeOf(obj) == FactoryPrototype;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any /** TODO #9100 */;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any /** TODO #9100 */;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nconst _global: {[name: string]: any} = __global || __window || __self;\n\nconst promise: Promise<any> = Promise.resolve(0);\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n\n// When Symbol.iterator doesn't exist, retrieves the key used in es6-shim\ndeclare const Symbol: any;\nlet _symbolIterator: any = null;\nexport function getSymbolIterator(): string|symbol {\n  if (!_symbolIterator) {\n    const Symbol = _global['Symbol'];\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' &&\n            (Map as any).prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n  return _symbolIterator;\n}\n\nexport function scheduleMicroTask(fn: Function) {\n  if (typeof Zone === 'undefined') {\n    // use promise to schedule microTask instead of use Zone\n    promise.then(() => { fn && fn.apply(null, null); });\n  } else {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n  }\n}\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n  return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token instanceof Array) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport function noSideEffects(fn: () => void): string {\n  return '' + {toString: fn};\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LQueries} from './query';\nimport {RComment, RElement} from './renderer';\nimport {StylingContext} from './styling';\nimport {HOST, LView, NEXT, PARENT, QUERIES} from './view';\n\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport const ACTIVE_INDEX = 0;\nexport const VIEWS = 1;\n// PARENT, NEXT, QUERIES, and HOST are indices 2, 3, 4, and 5.\n// As we already have these constants in LView, we don't need to re-create them.\nexport const NATIVE = 6;\nexport const RENDER_PARENT = 7;\n// Because interfaces in TS/JS cannot be instanceof-checked this means that we\n// need to rely on predictable characteristics of data-structures to check if they\n// are what we expect for them to be. The `LContainer` interface code below has a\n// fixed length and the constant value below references that. Using the length value\n// below we can predictably gaurantee that we are dealing with an `LContainer` array.\n// This value MUST be kept up to date with the length of the `LContainer` array\n// interface below so that runtime type checking can work.\nexport const LCONTAINER_LENGTH = 8;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The next active index in the views array to read or write to. This helps us\n   * keep track of where we are in the views array.\n   * In the case the LContainer is created for a ViewContainerRef,\n   * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\n   * i.e. provided directly by the user of the ViewContainerRef API.\n   */\n  [ACTIVE_INDEX]: number;\n\n  /**\n   * A list of the container's currently active child views. Views will be inserted\n   * here as they are added and spliced from here when they are removed. We need\n   * to keep a record of current views so we know which views are already in the DOM\n   * (and don't need to be re-added) and so we can remove views from the DOM when they\n   * are no longer required.\n   */\n  [VIEWS]: LView[];\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView|null;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * Queries active for this container - all the views inserted to / removed from\n   * this container are reported to queries referenced here.\n   */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   *\n   * It could also be a styling context if this is a node with a style/class\n   * binding.\n   */\n  [HOST]: RElement|RComment|StylingContext|LView;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  [NATIVE]: RComment;\n\n  /**\n   * Parent Element which will contain the location where all of the views will be\n   * inserted into to.\n   *\n   * If `renderParent` is `null` it is headless. This means that it is contained\n   * in another view which in turn is contained in another container and\n   * therefore it does not yet have its own parent.\n   *\n   * If `renderParent` is not `null` then it may be:\n   * - same as `tContainerNode.parent` in which case it is just a normal container.\n   * - different from `tContainerNode.parent` in which case it has been re-projected.\n   *   In other words `tContainerNode.parent` is logical parent where as\n   *   `tContainerNode.projectedParent` is render parent.\n   *\n   * When views are inserted into `LContainer` then `renderParent` is:\n   * - `null`, we are in a view, keep going up a hierarchy until actual\n   *   `renderParent` is found.\n   * - not `null`, then use the `projectedParent.native` as the `RElement` to insert\n   * views into.\n   */\n  [RENDER_PARENT]: RElement|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {RElement} from './renderer';\nimport {LView} from './view';\n\n/**\n * This property will be monkey-patched on elements, components and directives\n */\nexport const MONKEY_PATCH_KEY_NAME = '__ngContext__';\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nexport interface LContext {\n  /**\n   * The component's parent view data.\n   */\n  lView: LView;\n\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex: number;\n\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native: RElement;\n\n  /**\n   * The instance of the Component node.\n   */\n  component: {}|null|undefined;\n\n  /**\n   * The list of active directives that exist on this element.\n   */\n  directives: any[]|null|undefined;\n\n  /**\n   * The map of local references (local reference name => element or directive instance) that exist\n   * on this element.\n   */\n  localRefs: {[key: string]: any}|null|undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {Injector} from '../../di/injector';\nimport {QueryList} from '../../linker';\nimport {Sanitizer} from '../../sanitization/security';\nimport {Type} from '../../type';\nimport {LContainer} from './container';\nimport {ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList} from './definition';\nimport {I18nUpdateOpCodes, TI18n} from './i18n';\nimport {TElementNode, TNode, TViewNode} from './node';\nimport {PlayerHandler} from './player';\nimport {LQueries} from './query';\nimport {RElement, Renderer3, RendererFactory3} from './renderer';\nimport {StylingContext} from './styling';\n\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const TVIEW = 0;\nexport const FLAGS = 1;\nexport const PARENT = 2;\nexport const NEXT = 3;\nexport const QUERIES = 4;\nexport const HOST = 5;\nexport const HOST_NODE = 6;  // Rename to `T_HOST`?\nexport const BINDING_INDEX = 7;\nexport const CLEANUP = 8;\nexport const CONTEXT = 9;\nexport const INJECTOR = 10;\nexport const RENDERER_FACTORY = 11;\nexport const RENDERER = 12;\nexport const SANITIZER = 13;\nexport const TAIL = 14;\nexport const CONTAINER_INDEX = 15;\nexport const CONTENT_QUERIES = 16;\nexport const DECLARATION_VIEW = 17;\n/** Size of LView's header. Necessary to adjust for it when setting slots.  */\nexport const HEADER_OFFSET = 18;\n\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView extends Array<any> {\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly[TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * The parent view is needed when we exit the view and must restore the previous\n   * `LView`. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * This is the \"insertion\" view for embedded views. This allows us to properly\n   * destroy embedded views.\n   */\n  [PARENT]: LView|null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * The host node for this LView instance, if this is a component view.\n   *\n   * If this is an embedded view, HOST will be null.\n   */\n  [HOST]: RElement|StylingContext|null;\n\n  /**\n   * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.\n   *\n   * If `TViewNode`, this is an embedded view of a container. We need this to be able to\n   * efficiently find the `LViewNode` when inserting the view into an anchor.\n   *\n   * If `TElementNode`, this is the LView of a component.\n   *\n   * If null, this is the root view of an application (root component is in this view).\n   */\n  [HOST_NODE]: TViewNode|TElementNode|null;\n\n  /**\n   * The binding index we should access next.\n   *\n   * This is stored so that bindings can continue where they left off\n   * if a view is left midway through processing bindings (e.g. if there is\n   * a setter that creates an embedded view, like in ngIf).\n   */\n  [BINDING_INDEX]: number;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   */\n  // TODO: flatten into LView[]\n  [CLEANUP]: any[]|null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component the context contains change detection data.\n   * - For non-root components, the context is the component instance,\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: {}|RootContext|null;\n\n  /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly[INJECTOR]: Injector|null;\n\n  /** Renderer to be used for this view. */\n  [RENDERER_FACTORY]: RendererFactory3;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer3;\n\n  /** An optional custom sanitizer. */\n  [SANITIZER]: Sanitizer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [TAIL]: LView|LContainer|null;\n\n  /**\n   * The index of the parent container's host node. Applicable only to embedded views that\n   * have been inserted dynamically. Will be -1 for component views and inline views.\n   *\n   * This is necessary to jump from dynamically created embedded views to their parent\n   * containers because their parent cannot be stored on the TViewNode (views may be inserted\n   * in multiple containers, so the parent cannot be shared between view instances).\n   */\n  [CONTAINER_INDEX]: number;\n\n  /**\n   * Stores QueryLists associated with content queries of a directive. This data structure is\n   * filled-in as part of a directive creation process and is later used to retrieve a QueryList to\n   * be refreshed.\n   */\n  [CONTENT_QUERIES]: QueryList<any>[]|null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * Only applicable for dynamically created views. Will be null for inline/component views.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView|null;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b000000001,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 0b000000010,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b000000100,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b000001000,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b000010000,\n\n  /**\n   *  Whether or not the init hooks have run.\n   *\n   * If on, the init hooks haven't yet been run and should be executed by the first component that\n   * runs OR the first cR() instruction that runs (so inits are run for the top level view before\n   * any embedded views).\n   */\n  RunInit = 0b000100000,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 0b001000000,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 0b010000000,\n}\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the template function as ngPrivateData.\n */\nexport interface TView {\n  /**\n   * ID for inline views to determine whether a view is the same as the previous view\n   * in a certain position. If it's not, we know the new view needs to be inserted\n   * and the one that exists needs to be removed (e.g. if/else statements)\n   *\n   * If this is -1, then this is a component view or a dynamically created view.\n   */\n  readonly id: number;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ComponentQuery<{}>|null;\n\n  /**\n   * Pointer to the `TNode` that represents the root of the view.\n   *\n   * If this is a `TViewNode` for an `LViewNode`, this is an embedded view of a container.\n   * We need this pointer to be able to efficiently find this node when inserting the view\n   * into an anchor.\n   *\n   * If this is a `TElementNode`, this is the view of a root component. It has exactly one\n   * root TNode.\n   *\n   * If this is null, this is the view of a component that is not at root. We do not store\n   * the host TNodes for child component views because they can potentially have several\n   * different host TNodes, depending on where the component is being used. These host\n   * TNodes cannot be shared (due to different indices, etc).\n   */\n  node: TViewNode|TElementNode|null;\n\n  /** Whether or not this template has been processed. */\n  firstTemplatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"consts\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Index of the host node of the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   *\n   * For embedded views, we store the index of an LContainer's host rather than the first\n   * LView to avoid managing splicing when views are added/removed.\n   */\n  childIndex: number;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode|null;\n\n  /**\n   * Set of instructions used to process host bindings efficiently.\n   *\n   * See VIEW_DATA.md for more information.\n   */\n  expandoInstructions: (number|HostBindingsFunction<any>|null)[]|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  initHooks: HookData|null;\n\n  /**\n   * Array of ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  checkHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: HookData|null;\n\n  /**\n   * Array of pipe ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Index of pipe in data\n   * Odd indices: Hook function\n   *\n   * These must be stored separately from directive destroy hooks because their contexts\n   * are stored in data.\n   */\n  pipeDestroyHooks: HookData|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element `element = lView[tView.cleanup[i+1]]`\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's a renderer2 style listener or ViewRef destroy hook being stored:\n   * 1st index is: index of the cleanup function in LView.cleanupInstances[]\n   * 2nd index is: `null`\n   *               `lView[CLEANUP][tView.cleanup[i+0]]()`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A list of indices for child directives that have content queries.\n   *\n   * Even indices: Directive indices\n   * Odd indices: Starting index of content queries (stored in CONTENT_QUERIES) for this directive\n   */\n  contentQueries: number[]|null;\n}\n\nexport const enum RootContextFlags {Empty = 0b00, DetectChanges = 0b01, FlushPlayers = 0b10}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: {}[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * Even indices: Directive index\n * Odd indices: Hook function\n */\nexport type HookData = (number | (() => void))[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData =\n    (TNode | PipeDef<any>| DirectiveDef<any>| ComponentDef<any>| number | Type<any>|\n     InjectionToken<any>| TI18n | I18nUpdateOpCodes | null)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../util';\n\nimport {assertDataInRange, assertDefined, assertGreaterThan, assertLessThan} from './assert';\nimport {ACTIVE_INDEX, LCONTAINER_LENGTH, LContainer} from './interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags} from './interfaces/injector';\nimport {TContainerNode, TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {RComment, RElement, RText} from './interfaces/renderer';\nimport {StylingContext} from './interfaces/styling';\nimport {CONTEXT, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, LView, LViewFlags, PARENT, RootContext, TData, TVIEW, TView} from './interfaces/view';\n\n/**\n * Returns whether the values are different from a change detection stand point.\n *\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\n */\nexport function isDifferent(a: any, b: any): boolean {\n  // NaN is the only value that is not equal to itself so the first\n  // test checks if both a and b are not NaN\n  return !(a !== a && b !== b) && a !== b;\n}\n\nexport function stringify(value: any): string {\n  if (typeof value == 'function') return value.name || value;\n  if (typeof value == 'string') return value;\n  if (value == null) return '';\n  if (typeof value == 'object' && typeof value.type == 'function')\n    return value.type.name || value.type;\n  return '' + value;\n}\n\n/**\n * Flattens an array in non-recursive way. Input arrays are not modified.\n */\nexport function flatten(list: any[]): any[] {\n  const result: any[] = [];\n  let i = 0;\n\n  while (i < list.length) {\n    const item = list[i];\n    if (Array.isArray(item)) {\n      if (item.length > 0) {\n        list = item.concat(list.slice(i + 1));\n        i = 0;\n      } else {\n        i++;\n      }\n    } else {\n      result.push(item);\n      i++;\n    }\n  }\n\n  return result;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function loadInternal<T>(view: LView | TData, index: number): T {\n  ngDevMode && assertDataInRange(view, index + HEADER_OFFSET);\n  return view[index + HEADER_OFFSET];\n}\n\n/**\n * Takes the value of a slot in `LView` and returns the element node.\n *\n * Normally, element nodes are stored flat, but if the node has styles/classes on it,\n * it might be wrapped in a styling context. Or if that node has a directive that injects\n * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,\n * it will be wrapped in LView. It could even have all three, so we keep looping\n * until we find something that isn't an array.\n *\n * @param value The initial value in `LView`\n */\nexport function readElementValue(value: RElement | StylingContext | LContainer | LView): RElement {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RElement {\n  return readElementValue(lView[index + HEADER_OFFSET]);\n}\n\nexport function getNativeByTNode(tNode: TNode, hostView: LView): RElement|RText|RComment {\n  return readElementValue(hostView[tNode.index]);\n}\n\nexport function getTNode(index: number, view: LView): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, view[TVIEW].data.length, 'wrong index for TNode');\n  return view[TVIEW].data[index + HEADER_OFFSET] as TNode;\n}\n\nexport function getComponentViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  const slotValue = hostView[nodeIndex];\n  return slotValue.length >= HEADER_OFFSET ? slotValue : slotValue[HOST];\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isLContainer(value: RElement | RComment | LContainer | StylingContext): boolean {\n  // Styling contexts are also arrays, but their first index contains an element node\n  return Array.isArray(value) && value.length === LCONTAINER_LENGTH;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param component any component\n */\nexport function getRootView(target: LView | {}): LView {\n  ngDevMode && assertDefined(target, 'component');\n  let lView = Array.isArray(target) ? (target as LView) : readPatchedLView(target) !;\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView = lView[PARENT] !;\n  }\n  return lView;\n}\n\nexport function getRootContext(viewOrComponent: LView | {}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LView|LContext|null {\n  ngDevMode && assertDefined(target, 'Target expected');\n  return target[MONKEY_PATCH_KEY_NAME];\n}\n\nexport function readPatchedLView(target: any): LView|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lView;\n  }\n  return null;\n}\n\nexport function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nexport function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n}\n\nexport function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) >> RelativeInjectorLocationFlags.ViewOffsetShift;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nexport function getParentInjectorView(location: RelativeInjectorLocation, startView: LView): LView {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    viewOffset--;\n  }\n  return parentView;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the TNode of the parent injector is found.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @param startTNode The TNode instance of the starting element\n * @returns The TNode of the parent injector\n */\nexport function getParentInjectorTNode(\n    location: RelativeInjectorLocation, startView: LView, startTNode: TNode): TElementNode|\n    TContainerNode|null {\n  if (startTNode.parent && startTNode.parent.injectorIndex !== -1) {\n    // view offset is 0\n    const injectorIndex = startTNode.parent.injectorIndex;\n    let parentTNode = startTNode.parent;\n    while (parentTNode.parent != null && injectorIndex == parentTNode.injectorIndex) {\n      parentTNode = parentTNode.parent;\n    }\n    return parentTNode;\n  }\n\n  let viewOffset = getParentInjectorViewOffset(location);\n  // view offset is 1\n  let parentView = startView;\n  let parentTNode = startView[HOST_NODE] as TElementNode;\n\n  // view offset is superior to 1\n  while (viewOffset > 1) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    parentTNode = parentView[HOST_NODE] as TElementNode;\n    viewOffset--;\n  }\n  return parentTNode;\n}\n\nexport const defaultScheduler =\n    (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame ||  // browser only\n     setTimeout                                                                // everything else\n     ).bind(global);\n\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\nexport function addAllToArray(items: any[], arr: any[]) {\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n}\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lView LView for which we want a host element node\n * @returns The host node\n */\nexport function findComponentView(lView: LView): LView {\n  let rootTNode = lView[HOST_NODE];\n\n  while (rootTNode && rootTNode.type === TNodeType.View) {\n    ngDevMode && assertDefined(lView[DECLARATION_VIEW], 'lView[DECLARATION_VIEW]');\n    lView = lView[DECLARATION_VIEW] !;\n    rootTNode = lView[HOST_NODE];\n  }\n\n  return lView;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, getInjectableDef} from './defs';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n\n\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation: (<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags) => T | null)|\n    undefined;\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined):\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>): T;\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|\n    null;\nexport function injectInjectorOnly<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @publicApi\n */\nexport function inject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  return (_injectImplementation || injectInjectorOnly)(token, flags);\n}\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport function injectRootLimpMode<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T|null {\n  const injectableDef: InjectableDef<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, flags));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {executeHooks} from './hooks';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {TElementNode, TNode, TNodeFlags, TViewNode} from './interfaces/node';\nimport {LQueries} from './interfaces/query';\nimport {BINDING_INDEX, CONTEXT, DECLARATION_VIEW, FLAGS, HOST_NODE, LView, LViewFlags, OpaqueViewState, QUERIES, TVIEW} from './interfaces/view';\nimport {isContentQueryHost} from './util';\n\n\n\n/**\n * Store the element depth count. This is used to identify the root elements of the template\n * so that we can than attach `LView` to only those elements.\n */\nlet elementDepthCount !: number;\n\nexport function getElementDepthCount() {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  elementDepthCount--;\n}\n\nlet currentDirectiveDef: DirectiveDef<any>|ComponentDef<any>|null = null;\n\nexport function getCurrentDirectiveDef(): DirectiveDef<any>|ComponentDef<any>|null {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return currentDirectiveDef;\n}\n\nexport function setCurrentDirectiveDef(def: DirectiveDef<any>| ComponentDef<any>| null): void {\n  currentDirectiveDef = def;\n}\n\n/**\n * Stores whether directives should be matched to elements.\n *\n * When template contains `ngNonBindable` than we need to prevent the runtime form matching\n * directives on children of that element.\n *\n * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n * </div>\n * ```\n */\nlet bindingsEnabled !: boolean;\n\nexport function getBindingsEnabled(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return bindingsEnabled;\n}\n\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function enableBindings(): void {\n  bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function disableBindings(): void {\n  bindingsEnabled = false;\n}\n\nexport function getLView(): LView {\n  return lView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n */\nexport function restoreView(viewToRestore: OpaqueViewState) {\n  contextLView = viewToRestore as any as LView;\n}\n\n/** Used to set the parent property when nodes are created and track query results. */\nlet previousOrParentTNode: TNode;\n\nexport function getPreviousOrParentTNode(): TNode {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return previousOrParentTNode;\n}\n\nexport function setPreviousOrParentTNode(tNode: TNode) {\n  previousOrParentTNode = tNode;\n}\n\nexport function setTNodeAndViewData(tNode: TNode, view: LView) {\n  previousOrParentTNode = tNode;\n  lView = view;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentTNode` points to a parent node.\n *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\nexport function getIsParent(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return isParent;\n}\n\nexport function setIsParent(value: boolean): void {\n  isParent = value;\n}\n\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\n * create content queries).\n */\nexport function getOrCreateCurrentQueries(\n    QueryType: {new (parent: null, shallow: null, deep: null): LQueries}): LQueries {\n  const lView = getLView();\n  let currentQueries = lView[QUERIES];\n  // if this is the first content query on a node, any existing LQueries needs to be cloned\n  // in subsequent template passes, the cloning occurs before directive instantiation.\n  if (previousOrParentTNode && previousOrParentTNode !== lView[HOST_NODE] &&\n      !isContentQueryHost(previousOrParentTNode)) {\n    currentQueries && (currentQueries = lView[QUERIES] = currentQueries.clone());\n    previousOrParentTNode.flags |= TNodeFlags.hasContentQuery;\n  }\n\n  return currentQueries || (lView[QUERIES] = new QueryType(null, null, null));\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView = lView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * State of the current view being processed.\n *\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet lView: LView;\n\n/**\n * The last viewData retrieved by nextContext().\n * Allows building nextContext() and reference() calls.\n *\n * e.g. const inner = x().$implicit; const outer = x().$implicit;\n */\nlet contextLView: LView = null !;\n\nexport function getContextLView(): LView {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return contextLView;\n}\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\nexport function getCheckNoChangesMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return checkNoChangesMode;\n}\n\nexport function setCheckNoChangesMode(mode: boolean): void {\n  checkNoChangesMode = mode;\n}\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\nexport function getFirstTemplatePass(): boolean {\n  return firstTemplatePass;\n}\n\nexport function setFirstTemplatePass(value: boolean): void {\n  firstTemplatePass = value;\n}\n\n/**\n * The root index from which pure function instructions should calculate their binding\n * indices. In component views, this is TView.bindingStartIndex. In a host binding\n * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n */\nlet bindingRootIndex: number = -1;\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  return bindingRootIndex;\n}\n\nexport function setBindingRoot(value: number) {\n  bindingRootIndex = value;\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LView, hostTNode: TElementNode | TViewNode | null): LView {\n  const oldView = lView;\n  if (newView) {\n    const tView = newView[TVIEW];\n    firstTemplatePass = tView.firstTemplatePass;\n    bindingRootIndex = tView.bindingStartIndex;\n  }\n\n  previousOrParentTNode = hostTNode !;\n  isParent = true;\n\n  lView = contextLView = newView;\n  return oldView;\n}\n\nexport function nextContextImpl<T = any>(level: number = 1): T {\n  contextLView = walkUpViews(level, contextLView !);\n  return contextLView[CONTEXT] as T;\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/**\n * Resets the application state.\n */\nexport function resetComponentState() {\n  isParent = false;\n  previousOrParentTNode = null !;\n  elementDepthCount = 0;\n  bindingsEnabled = true;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n */\nexport function leaveView(newView: LView): void {\n  const tView = lView[TVIEW];\n  if (isCreationMode(lView)) {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n  } else {\n    executeHooks(lView, tView.viewHooks, tView.viewCheckHooks, checkNoChangesMode);\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    lView[FLAGS] |= LViewFlags.RunInit;\n    lView[BINDING_INDEX] = tView.bindingStartIndex;\n  }\n  enterView(newView, null);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode} from './interfaces/node';\nimport {FLAGS, HookData, LView, LViewFlags, TView} from './interfaces/view';\n\n\n\n/**\n * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into\n * TView.initHooks during directiveCreate.\n *\n * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:\n * directive index), then saved in the even indices of the initHooks array. The odd indices\n * hold the hook functions themselves.\n *\n * @param index The index of the directive in LView\n * @param hooks The static hooks map on the directive def\n * @param tView The current TView\n */\nexport function queueInitHooks(\n    index: number, onInit: (() => void) | null, doCheck: (() => void) | null, tView: TView): void {\n  ngDevMode &&\n      assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');\n  if (onInit) {\n    (tView.initHooks || (tView.initHooks = [])).push(index, onInit);\n  }\n\n  if (doCheck) {\n    (tView.initHooks || (tView.initHooks = [])).push(index, doCheck);\n    (tView.checkHooks || (tView.checkHooks = [])).push(index, doCheck);\n  }\n}\n\n/**\n * Loops through the directives on a node and queues all their hooks except ngOnInit\n * and ngDoCheck, which are queued separately in directiveCreate.\n */\nexport function queueLifecycleHooks(tView: TView, tNode: TNode): void {\n  if (tView.firstTemplatePass) {\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n      const def = tView.data[i] as DirectiveDef<any>;\n      queueContentHooks(def, tView, i);\n      queueViewHooks(def, tView, i);\n      queueDestroyHooks(def, tView, i);\n    }\n  }\n}\n\n/** Queues afterContentInit and afterContentChecked hooks on TView */\nfunction queueContentHooks(def: DirectiveDef<any>, tView: TView, i: number): void {\n  if (def.afterContentInit) {\n    (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentInit);\n  }\n\n  if (def.afterContentChecked) {\n    (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentChecked);\n    (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, def.afterContentChecked);\n  }\n}\n\n/** Queues afterViewInit and afterViewChecked hooks on TView */\nfunction queueViewHooks(def: DirectiveDef<any>, tView: TView, i: number): void {\n  if (def.afterViewInit) {\n    (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewInit);\n  }\n\n  if (def.afterViewChecked) {\n    (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewChecked);\n    (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, def.afterViewChecked);\n  }\n}\n\n/** Queues onDestroy hooks on TView */\nfunction queueDestroyHooks(def: DirectiveDef<any>, tView: TView, i: number): void {\n  if (def.onDestroy != null) {\n    (tView.destroyHooks || (tView.destroyHooks = [])).push(i, def.onDestroy);\n  }\n}\n\n/**\n * Calls onInit and doCheck calls if they haven't already been called.\n *\n * @param currentView The current view\n */\nexport function executeInitHooks(\n    currentView: LView, tView: TView, checkNoChangesMode: boolean): void {\n  if (!checkNoChangesMode && currentView[FLAGS] & LViewFlags.RunInit) {\n    executeHooks(currentView, tView.initHooks, tView.checkHooks, checkNoChangesMode);\n    currentView[FLAGS] &= ~LViewFlags.RunInit;\n  }\n}\n\n/**\n * Iterates over afterViewInit and afterViewChecked functions and calls them.\n *\n * @param currentView The current view\n */\nexport function executeHooks(\n    currentView: LView, allHooks: HookData | null, checkHooks: HookData | null,\n    checkNoChangesMode: boolean): void {\n  if (checkNoChangesMode) return;\n\n  const hooksToCall = currentView[FLAGS] & LViewFlags.FirstLViewPass ? allHooks : checkHooks;\n  if (hooksToCall) {\n    callHooks(currentView, hooksToCall);\n  }\n}\n\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass.\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n */\nexport function callHooks(currentView: any[], arr: HookData): void {\n  for (let i = 0; i < arr.length; i += 2) {\n    (arr[i + 1] as() => void).call(currentView[arr[i] as number]);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getInjectableDef, getInjectorDef} from '../di/defs';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectFlags, injectRootLimpMode, setInjectImplementation} from '../di/injector_compatibility';\nimport {Type} from '../type';\n\nimport {assertDefined, assertEqual} from './assert';\nimport {getComponentDef, getDirectiveDef, getPipeDef} from './definition';\nimport {NG_ELEMENT_ID} from './fields';\nimport {DirectiveDef} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, NodeInjectorFactory, PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags, TNODE, isFactory} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType} from './interfaces/node';\nimport {DECLARATION_VIEW, HOST_NODE, INJECTOR, LView, TData, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {getLView, getPreviousOrParentTNode, setTNodeAndViewData} from './state';\nimport {findComponentView, getParentInjectorIndex, getParentInjectorView, hasParentInjector, isComponent, isComponentDef, stringify} from './util';\n\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\n\nfunction setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n    injectorIndex: number, tView: TView, type: Type<any>| InjectionToken<any>| string): void {\n  ngDevMode && assertEqual(tView.firstTemplatePass, true, 'expected firstTemplatePass to be true');\n  let id: number|undefined =\n      typeof type !== 'string' ? (type as any)[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n  const tData = tView.data as number[];\n\n  if (b7) {\n    b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n         (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n  } else {\n    b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n         (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n  }\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LView): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, hostView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = hostView[TVIEW];\n  if (tView.firstTemplatePass) {\n    tNode.injectorIndex = hostView.length;\n    insertBloom(tView.data, tNode);  // foundation for node bloom\n    insertBloom(hostView, null);     // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n\n    ngDevMode && assertEqual(\n                     tNode.flags === 0 || tNode.flags === TNodeFlags.isComponent, true,\n                     'expected tNode.flags to not be initialized');\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, hostView);\n  const parentIndex = getParentInjectorIndex(parentLoc);\n  const parentLView = getParentInjectorView(parentLoc, hostView);\n\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8; i++) {\n      hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode | null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\n\nexport function getInjectorIndex(tNode: TNode, hostView: LView): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\n    return -1;\n  } else {\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\n */\nexport function getParentInjectorLocation(tNode: TNode, view: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex as any;  // ViewOffset is 0\n  }\n\n  // For most cases, the parent injector index can be found on the host node (e.g. for component\n  // or container), so this loop will be skipped, but we must keep the loop here to support\n  // the rarer case of deeply nested <ng-template> tags or inline views.\n  let hostTNode = view[HOST_NODE];\n  let viewOffset = 1;\n  while (hostTNode && hostTNode.injectorIndex === -1) {\n    view = view[DECLARATION_VIEW] !;\n    hostTNode = view ? view[HOST_NODE] : null;\n    viewOffset++;\n  }\n\n  return hostTNode ?\n      hostTNode.injectorIndex | (viewOffset << RelativeInjectorLocationFlags.ViewOffsetShift) :\n      -1 as any;\n}\n\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, view: LView, token: InjectionToken<any>| Type<any>): void {\n  bloomAdd(injectorIndex, view[TVIEW], token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string|null {\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  const attrs = tNode.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      const attrName = attrs[i];\n      if (attrName === AttributeMarker.SelectOnly) break;\n      if (attrName == attrNameToInject) {\n        return attrs[i + 1] as string;\n      }\n    }\n  }\n  return null;\n}\n\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nexport function getOrCreateInjectable<T>(\n    tNode: TElementNode | TContainerNode | TElementContainerNode | null, lView: LView,\n    token: Type<T>| InjectionToken<T>, flags: InjectFlags = InjectFlags.Default,\n    notFoundValue?: any): T|null {\n  if (tNode) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n      const savePreviousOrParentTNode = getPreviousOrParentTNode();\n      const saveLView = getLView();\n      setTNodeAndViewData(tNode, lView);\n      try {\n        const value = bloomHash();\n        if (value == null && !(flags & InjectFlags.Optional)) {\n          throw new Error(`No provider for ${stringify(token)}!`);\n        } else {\n          return value;\n        }\n      } finally {\n        setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\n      }\n    } else if (typeof bloomHash == 'number') {\n      // If the token has a bloom hash, then it is a token which could be in NodeInjector.\n\n      // A reference to the previous injector TView that was found while climbing the element\n      // injector tree. This is used to know if viewProviders can be accessed on the current\n      // injector.\n      let previousTView: TView|null = null;\n      let injectorIndex = getInjectorIndex(tNode, lView);\n      let parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;\n      let hostTElementNode: TNode|null =\n          flags & InjectFlags.Host ? findComponentView(lView)[HOST_NODE] : null;\n\n      // If we should skip this injector, or if there is no injector on this node, start by\n      // searching\n      // the parent injector.\n      if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n        parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                                                lView[injectorIndex + PARENT_INJECTOR];\n\n        if (!shouldSearchParent(flags, false)) {\n          injectorIndex = -1;\n        } else {\n          previousTView = lView[TVIEW];\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        }\n      }\n\n      // Traverse up the injector tree until we find a potential match or until we know there\n      // *isn't* a match.\n      while (injectorIndex !== -1) {\n        parentLocation = lView[injectorIndex + PARENT_INJECTOR];\n\n        // Check the current injector. If it matches, see if it contains token.\n        const tView = lView[TVIEW];\n        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n          // At this point, we have an injector which *may* contain the token, so we step through\n          // the providers and directives associated with the injector's corresponding node to get\n          // the instance.\n          const instance: T|null = searchTokensOnInjector<T>(\n              injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n          if (instance !== NOT_FOUND) {\n            return instance;\n          }\n        }\n        if (shouldSearchParent(\n                flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) &&\n            bloomHasToken(bloomHash, injectorIndex, lView)) {\n          // The def wasn't found anywhere on this node, so it was a false positive.\n          // Traverse up the tree and continue searching.\n          previousTView = tView;\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        } else {\n          // If we should not search parent OR If the ancestor bloom filter value does not have the\n          // bit corresponding to the directive we can give up on traversing up to find the specific\n          // injector.\n          injectorIndex = -1;\n        }\n      }\n    }\n  }\n\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    if (moduleInjector) {\n      return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n    } else {\n      return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n    }\n  }\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throw new Error(`NodeInjector: NOT_FOUND [${stringify(token)}]`);\n  }\n}\n\nconst NOT_FOUND = {};\n\nfunction searchTokensOnInjector<T>(\n    injectorIndex: number, lView: LView, token: Type<T>| InjectionToken<T>,\n    previousTView: TView | null, flags: InjectFlags, hostTElementNode: TNode | null) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + TNODE] as TNode;\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibities\n  const canAccessViewProviders = previousTView == null ?\n      // 1) This is the first invocation `previousTView == null` which means that we are at the\n      // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n      // to look into the ViewProviders is if:\n      // - we are on a component\n      // - AND the injector set `includeViewProviders` to true (implying that the token can see\n      // ViewProviders because it is the Component or a Service which itself was declared in\n      // ViewProviders)\n      (isComponent(tNode) && includeViewProviders) :\n      // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n      // In such a case we are only allowed to look into the ViewProviders if:\n      // - We just crossed from child View to Parent View `previousTView != currentTView`\n      // - AND the parent TNode is an Element.\n      // This means that we just came from the Component's View and therefore are allowed to see\n      // into the ViewProviders.\n      (previousTView != currentTView && (tNode.type === TNodeType.Element));\n\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n\n  const injectableIdx =\n      locateDirectiveOrProvider(tNode, lView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(currentTView.data, lView, injectableIdx, tNode as TElementNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param lView The view we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n    tNode: TNode, lView: LView, token: Type<T>| InjectionToken<T>, canAccessViewProviders: boolean,\n    isHostSpecialCase: boolean | number): number|null {\n  const tView = lView[TVIEW];\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const injectablesStart = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount =\n      nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex =\n      canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i] as InjectionToken<any>| Type<any>| DirectiveDef<any>;\n    if (i < directivesStart && token === providerTokenOrDef ||\n        i >= directivesStart && (providerTokenOrDef as DirectiveDef<any>).type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart] as DirectiveDef<any>;\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n\n/**\n* Retrieve or instantiate the injectable from the `lData` at particular `index`.\n*\n* This function checks to see if the value has already been instantiated and if so returns the\n* cached `injectable`. Otherwise if it detects that the value is still a factory it\n* instantiates the `injectable` and caches the value.\n*/\nexport function getNodeInjectable(\n    tData: TData, lData: LView, index: number, tNode: TElementNode): any {\n  let value = lData[index];\n  if (isFactory(value)) {\n    const factory: NodeInjectorFactory = value;\n    if (factory.resolving) {\n      throw new Error(`Circular dep for ${stringify(tData[index])}`);\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let previousInjectImplementation;\n    if (factory.injectImpl) {\n      previousInjectImplementation = setInjectImplementation(factory.injectImpl);\n    }\n    const savePreviousOrParentTNode = getPreviousOrParentTNode();\n    const saveLView = getLView();\n    setTNodeAndViewData(tNode, lData);\n    try {\n      value = lData[index] = factory.factory(null, tData, lData, tNode);\n    } finally {\n      if (factory.injectImpl) setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n */\nexport function bloomHashBitOrFactory(token: Type<any>| InjectionToken<any>| string): number|\n    Function|undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n  return typeof tokenId === 'number' ? tokenId & BLOOM_MASK : tokenId;\n}\n\nexport function bloomHasToken(\n    bloomHash: number, injectorIndex: number, injectorView: LView | TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags: InjectFlags, isFirstHostTNode: boolean): boolean|number {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\n\nexport function injectInjector() {\n  const tNode = getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode;\n  return new NodeInjector(tNode, getLView());\n}\n\nexport class NodeInjector implements Injector {\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode|null,\n      private _lView: LView) {}\n\n  get(token: any, notFoundValue?: any): any {\n    return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\n  }\n}\n\nexport function getFactoryOf<T>(type: Type<any>): ((type: Type<T>| null) => T)|null {\n  const typeAny = type as any;\n  const def = getComponentDef<T>(typeAny) || getDirectiveDef<T>(typeAny) ||\n      getPipeDef<T>(typeAny) || getInjectableDef<T>(typeAny) || getInjectorDef<T>(typeAny);\n  if (!def || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n\nexport function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = getFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\nimport {assertDomNode} from './assert';\nimport {EMPTY_ARRAY} from './empty';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, HOST, LView, TVIEW} from './interfaces/view';\nimport {getComponentViewByIndex, getNativeByTNode, readElementValue, readPatchedData} from './util';\n\n\n\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport function getLContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lView: LView = mpValue !;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = readElementValue(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lView, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomNode(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lView: LView|null;\n        if (Array.isArray(parentContext)) {\n          lView = parentContext as LView;\n        } else {\n          lView = parentContext.lView;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = readElementValue(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView: LView, nodeIndex: number, native: RElement): LContext {\n  return {\n    lView,\n    nodeIndex,\n    native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LView {\n  let lView = readPatchedData(componentInstance);\n  let view: LView;\n\n  if (Array.isArray(lView)) {\n    const nodeIndex = findViaComponent(lView, componentInstance);\n    view = getComponentViewByIndex(nodeIndex, lView);\n    const context = createLContext(lView, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lView as any as LContext;\n    view = getComponentViewByIndex(context.nodeIndex, context.lView);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LView | LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngComponentDef;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngDirectiveDef;\n}\n\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView: LView, target: RElement): number {\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const native = getNativeByTNode(tNode, lView) !;\n    if (native === target) {\n      return tNode.index;\n    }\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView: LView, componentInstance: {}): number {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView: LView, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function getDirectivesAtNodeIndex(\n    nodeIndex: number, lView: LView, includeComponents: boolean): any[]|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = tNode.directiveEnd;\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponent) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nexport function getComponentAtNodeIndex(nodeIndex: number, lView: LView): {}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  return tNode.flags & TNodeFlags.isComponent ? lView[directiveStartIndex] : null;\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lView: LView, nodeIndex: number): {[key: string]: any}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      const localRefName = tNode.localNames[i];\n      const directiveIndex = tNode.localNames[i + 1] as number;\n      result[localRefName] =\n          directiveIndex === -1 ? getNativeByTNode(tNode, lView) ! : lView[directiveIndex];\n    }\n    return result;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\nexport type CssSelector = (string | SelectorFlags)[];\n\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport type CssSelectorList = CssSelector[];\n\n/** Flags used to build up CssSelectors */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\nexport const NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and than\n * use that time for rendering.\n *\n * At runtime we can than use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n\nimport {RendererStyleFlags2, RendererType2} from '../../render/api';\n\n\n// TODO: cleanup once the code is merged in angular/angular\nexport enum RendererStyleFlags3 {\n  Important = 1 << 0,\n  DashCase = 1 << 1\n}\n\nexport type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;\n\n/**\n * Object Oriented style of API needed to create elements and text nodes.\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade\n * (reducing payload size).\n * */\nexport interface ObjectOrientedRenderer3 {\n  createComment(data: string): RComment;\n  createElement(tagName: string): RElement;\n  createElementNS(namespace: string, tagName: string): RElement;\n  createTextNode(data: string): RText;\n\n  querySelector(selectors: string): RElement|null;\n}\n\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nexport function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3):\n    renderer is ProceduralRenderer3 {\n  return !!((renderer as any).listen);\n}\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. This also facilitates backwards compatibility\n * with Renderer2.\n */\nexport interface ProceduralRenderer3 {\n  destroy(): void;\n  createComment(value: string): RComment;\n  createElement(name: string, namespace?: string|null): RElement;\n  createText(value: string): RText;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode?: ((node: RNode) => void)|null;\n  appendChild(parent: RElement, newChild: RNode): void;\n  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null): void;\n  removeChild(parent: RElement, oldChild: RNode): void;\n  selectRootElement(selectorOrNode: string|any): RElement;\n\n  parentNode(node: RNode): RElement|null;\n  nextSibling(node: RNode): RNode|null;\n\n  setAttribute(el: RElement, name: string, value: string, namespace?: string|null): void;\n  removeAttribute(el: RElement, name: string, namespace?: string|null): void;\n  addClass(el: RElement, name: string): void;\n  removeClass(el: RElement, name: string): void;\n  setStyle(\n      el: RElement, style: string, value: any,\n      flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  setProperty(el: RElement, name: string, value: any): void;\n  setValue(node: RText|RComment, value: string): void;\n\n  // TODO(misko): Deprecate in favor of addEventListener/removeEventListener\n  listen(target: RNode, eventName: string, callback: (event: any) => boolean | void): () => void;\n}\n\nexport interface RendererFactory3 {\n  createRenderer(hostElement: RElement|null, rendererType: RendererType2|null): Renderer3;\n  begin?(): void;\n  end?(): void;\n}\n\nexport const domRendererFactory3: RendererFactory3 = {\n  createRenderer: (hostElement: RElement | null, rendererType: RendererType2 | null):\n                      Renderer3 => { return document;}\n};\n\n/** Subset of API needed for appending elements and text nodes. */\nexport interface RNode {\n  parentNode: RNode|null;\n\n  nextSibling: RNode|null;\n\n  removeChild(oldChild: RNode): void;\n\n  /**\n   * Insert a child node.\n   *\n   * Used exclusively for adding View root nodes into ViewAnchor location.\n   */\n  insertBefore(newChild: RNode, refChild: RNode|null, isViewRoot: boolean): void;\n\n  /**\n   * Append a child node.\n   *\n   * Used exclusively for building up DOM which are static (ie not View roots)\n   */\n  appendChild(newChild: RNode): RNode;\n}\n\n/**\n * Subset of API needed for writing attributes, properties, and setting up\n * listeners on Element.\n */\nexport interface RElement extends RNode {\n  style: RCssStyleDeclaration;\n  classList: RDomTokenList;\n  className: string;\n  setAttribute(name: string, value: string): void;\n  removeAttribute(name: string): void;\n  setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\n  addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\n  removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\n\n  setProperty?(name: string, value: any): void;\n}\n\nexport interface RCssStyleDeclaration {\n  removeProperty(propertyName: string): string;\n  setProperty(propertyName: string, value: string|null, priority?: string): void;\n}\n\nexport interface RDomTokenList {\n  add(token: string): void;\n  remove(token: string): void;\n}\n\nexport interface RText extends RNode { textContent: string|null; }\n\nexport interface RComment extends RNode { textContent: string|null; }\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../ng_dev_mode';\n\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {getLContext} from '../context_discovery';\nimport {LContainer} from '../interfaces/container';\nimport {LContext} from '../interfaces/context';\nimport {AttributeMarker, TAttributes, TNode, TNodeFlags} from '../interfaces/node';\nimport {PlayState, Player, PlayerContext, PlayerIndex} from '../interfaces/player';\nimport {RElement} from '../interfaces/renderer';\nimport {InitialStylingValues, StylingContext, StylingFlags, StylingIndex} from '../interfaces/styling';\nimport {HEADER_OFFSET, HOST, LView, RootContext} from '../interfaces/view';\nimport {getTNode} from '../util';\n\nimport {CorePlayerHandler} from './core_player_handler';\n\nconst ANIMATION_PROP_PREFIX = '@';\n\nexport function createEmptyStylingContext(\n    element?: RElement | null, sanitizer?: StyleSanitizeFn | null,\n    initialStyles?: InitialStylingValues | null,\n    initialClasses?: InitialStylingValues | null): StylingContext {\n  return [\n    0,                                     // MasterFlags\n    [null, -1, false, sanitizer || null],  // DirectiveRefs\n    initialStyles || [null],               // InitialStyles\n    initialClasses || [null],              // InitialClasses\n    [0, 0],                                // SinglePropOffsets\n    element || null,                       // Element\n    null,                                  // PreviousMultiClassValue\n    null,                                  // PreviousMultiStyleValue\n    null,                                  // PlayerContext\n  ];\n}\n\n/**\n * Used clone a copy of a pre-computed template of a styling context.\n *\n * A pre-computed template is designed to be computed once for a given element\n * (instructions.ts has logic for caching this).\n */\nexport function allocStylingContext(\n    element: RElement | null, templateStyleContext: StylingContext): StylingContext {\n  // each instance gets a copy\n  const context = templateStyleContext.slice() as any as StylingContext;\n  context[StylingIndex.ElementPosition] = element;\n\n  // this will prevent any other directives from extending the context\n  context[StylingIndex.MasterFlagPosition] |= StylingFlags.BindingAllocationLocked;\n  return context;\n}\n\n/**\n * Retrieve the `StylingContext` at a given index.\n *\n * This method lazily creates the `StylingContext`. This is because in most cases\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\n * every style declaration such as `<div style=\"color: red\">` would result `StyleContext`\n * which would create unnecessary memory pressure.\n *\n * @param index Index of the style allocation. See: `elementStyling`.\n * @param viewData The view to search for the styling context\n */\nexport function getStylingContext(index: number, viewData: LView): StylingContext {\n  let storageIndex = index;\n  let slotValue: LContainer|LView|StylingContext|RElement = viewData[storageIndex];\n  let wrapper: LContainer|LView|StylingContext = viewData;\n\n  while (Array.isArray(slotValue)) {\n    wrapper = slotValue;\n    slotValue = slotValue[HOST] as LView | StylingContext | RElement;\n  }\n\n  if (isStylingContext(wrapper)) {\n    return wrapper as StylingContext;\n  } else {\n    // This is an LView or an LContainer\n    const stylingTemplate = getTNode(index - HEADER_OFFSET, viewData).stylingTemplate;\n\n    if (wrapper !== viewData) {\n      storageIndex = HOST;\n    }\n\n    return wrapper[storageIndex] = stylingTemplate ?\n        allocStylingContext(slotValue, stylingTemplate) :\n        createEmptyStylingContext(slotValue);\n  }\n}\n\nexport function isStylingContext(value: any): value is StylingContext {\n  // Not an LView or an LContainer\n  return Array.isArray(value) && typeof value[StylingIndex.MasterFlagPosition] === 'number' &&\n      Array.isArray(value[StylingIndex.InitialStyleValuesPosition]);\n}\n\nexport function isAnimationProp(name: string): boolean {\n  return name[0] === ANIMATION_PROP_PREFIX;\n}\n\nexport function addPlayerInternal(\n    playerContext: PlayerContext, rootContext: RootContext, element: HTMLElement,\n    player: Player | null, playerContextIndex: number, ref?: any): boolean {\n  ref = ref || element;\n  if (playerContextIndex) {\n    playerContext[playerContextIndex] = player;\n  } else {\n    playerContext.push(player);\n  }\n\n  if (player) {\n    player.addEventListener(PlayState.Destroyed, () => {\n      const index = playerContext.indexOf(player);\n      const nonFactoryPlayerIndex = playerContext[PlayerIndex.NonBuilderPlayersStart];\n\n      // if the player is being removed from the factory side of the context\n      // (which is where the [style] and [class] bindings do their thing) then\n      // that side of the array cannot be resized since the respective bindings\n      // have pointer index values that point to the associated factory instance\n      if (index) {\n        if (index < nonFactoryPlayerIndex) {\n          playerContext[index] = null;\n        } else {\n          playerContext.splice(index, 1);\n        }\n      }\n      player.destroy();\n    });\n\n    const playerHandler =\n        rootContext.playerHandler || (rootContext.playerHandler = new CorePlayerHandler());\n    playerHandler.queuePlayer(player, ref);\n    return true;\n  }\n\n  return false;\n}\n\nexport function getPlayersInternal(playerContext: PlayerContext): Player[] {\n  const players: Player[] = [];\n  const nonFactoryPlayersStart = playerContext[PlayerIndex.NonBuilderPlayersStart];\n\n  // add all factory-based players (which are apart of [style] and [class] bindings)\n  for (let i = PlayerIndex.PlayerBuildersStartPosition + PlayerIndex.PlayerOffsetPosition;\n       i < nonFactoryPlayersStart; i += PlayerIndex.PlayerAndPlayerBuildersTupleSize) {\n    const player = playerContext[i] as Player | null;\n    if (player) {\n      players.push(player);\n    }\n  }\n\n  // add all custom players (not apart of [style] and [class] bindings)\n  for (let i = nonFactoryPlayersStart; i < playerContext.length; i++) {\n    players.push(playerContext[i] as Player);\n  }\n\n  return players;\n}\n\n\nexport function getOrCreatePlayerContext(target: {}, context?: LContext | null): PlayerContext|\n    null {\n  context = context || getLContext(target) !;\n  if (!context) {\n    ngDevMode && throwInvalidRefError();\n    return null;\n  }\n\n  const {lView, nodeIndex} = context;\n  const stylingContext = getStylingContext(nodeIndex, lView);\n  return getPlayerContext(stylingContext) || allocPlayerContext(stylingContext);\n}\n\nexport function getPlayerContext(stylingContext: StylingContext): PlayerContext|null {\n  return stylingContext[StylingIndex.PlayerContext];\n}\n\nexport function allocPlayerContext(data: StylingContext): PlayerContext {\n  return data[StylingIndex.PlayerContext] =\n             [PlayerIndex.SinglePlayerBuildersStartPosition, null, null, null, null];\n}\n\nexport function throwInvalidRefError() {\n  throw new Error('Only elements that exist in an Angular application can be used for animations');\n}\n\nexport function hasStyling(attrs: TAttributes): boolean {\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    if (attr == AttributeMarker.Classes || attr == AttributeMarker.Styles) return true;\n  }\n  return false;\n}\n\nexport function hasClassInput(tNode: TNode) {\n  return tNode.flags & TNodeFlags.hasClassInput ? true : false;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {resolveForwardRef} from '../di/forward_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectFlags} from '../di/injector_compatibility';\nimport {QueryList} from '../linker';\nimport {Sanitizer} from '../sanitization/security';\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {Type} from '../type';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../util/ng_reflect';\n\nimport {assertDataInRange, assertDefined, assertEqual, assertHasParent, assertLessThan, assertNotEqual, assertPreviousIsParent} from './assert';\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4} from './bindings';\nimport {attachPatchData, getComponentViewByInstance} from './context_discovery';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateInjectable, getOrCreateNodeInjectorForNode, injectAttributeImpl} from './di';\nimport {throwMultipleComponentError} from './errors';\nimport {executeHooks, executeInitHooks, queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {ACTIVE_INDEX, LContainer, VIEWS} from './interfaces/container';\nimport {ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {INJECTOR_BLOOM_PARENT_SIZE, NodeInjectorFactory} from './interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode, TViewNode} from './interfaces/node';\nimport {PlayerFactory} from './interfaces/player';\nimport {CssSelectorList, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {ProceduralRenderer3, RComment, RElement, RText, Renderer3, RendererFactory3, isProceduralRenderer} from './interfaces/renderer';\nimport {SanitizerFn} from './interfaces/sanitization';\nimport {BINDING_INDEX, CLEANUP, CONTAINER_INDEX, CONTENT_QUERIES, CONTEXT, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, INJECTOR, LView, LViewFlags, NEXT, OpaqueViewState, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, TAIL, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {appendChild, appendProjectedNode, createTextNode, getLViewChild, getRenderParent, insertView, removeView} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {decreaseElementDepthCount, enterView, getBindingsEnabled, getCheckNoChangesMode, getContextLView, getCurrentDirectiveDef, getElementDepthCount, getFirstTemplatePass, getIsParent, getLView, getPreviousOrParentTNode, increaseElementDepthCount, isCreationMode, leaveView, nextContextImpl, resetComponentState, setBindingRoot, setCheckNoChangesMode, setCurrentDirectiveDef, setFirstTemplatePass, setIsParent, setPreviousOrParentTNode} from './state';\nimport {getInitialClassNameValue, initializeStaticContext as initializeStaticStylingContext, patchContextWithStaticAttrs, renderInitialStylesAndClasses, renderStyling, updateClassProp as updateElementClassProp, updateContextWithBindings, updateStyleProp as updateElementStyleProp, updateStylingMap} from './styling/class_and_style_bindings';\nimport {BoundPlayerFactory} from './styling/player_factory';\nimport {createEmptyStylingContext, getStylingContext, hasClassInput, hasStyling, isAnimationProp} from './styling/util';\nimport {NO_CHANGE} from './tokens';\nimport {findComponentView, getComponentViewByIndex, getNativeByIndex, getNativeByTNode, getRootContext, getRootView, getTNode, isComponent, isComponentDef, loadInternal, readElementValue, readPatchedLView, stringify} from './util';\n\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings, refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nexport function refreshDescendantViews(lView: LView) {\n  const tView = lView[TVIEW];\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = false;\n  setFirstTemplatePass(false);\n\n  // If this is a creation pass, we should not call lifecycle hooks or evaluate bindings.\n  // This will be done in the update pass.\n  if (!isCreationMode(lView)) {\n    const checkNoChangesMode = getCheckNoChangesMode();\n\n    executeInitHooks(lView, tView, checkNoChangesMode);\n\n    refreshDynamicEmbeddedViews(lView);\n\n    // Content query results must be refreshed before content hooks are called.\n    refreshContentQueries(tView);\n\n    executeHooks(lView, tView.contentHooks, tView.contentCheckHooks, checkNoChangesMode);\n\n    setHostBindings(tView, lView);\n  }\n\n  refreshChildComponents(tView.components);\n}\n\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(tView: TView, viewData: LView): void {\n  if (tView.expandoInstructions) {\n    let bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;\n    setBindingRoot(bindingRootIndex);\n    let currentDirectiveIndex = -1;\n    let currentElementIndex = -1;\n    for (let i = 0; i < tView.expandoInstructions.length; i++) {\n      const instruction = tView.expandoInstructions[i];\n      if (typeof instruction === 'number') {\n        if (instruction <= 0) {\n          // Negative numbers mean that we are starting new EXPANDO block and need to update\n          // the current element and directive index.\n          currentElementIndex = -instruction;\n          // Injector block and providers are taken into account.\n          const providerCount = (tView.expandoInstructions[++i] as number);\n          bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;\n\n          currentDirectiveIndex = bindingRootIndex;\n        } else {\n          // This is either the injector size (so the binding root can skip over directives\n          // and get to the first set of host bindings on this node) or the host var count\n          // (to get to the next set of host bindings on this node).\n          bindingRootIndex += instruction;\n        }\n        setBindingRoot(bindingRootIndex);\n      } else {\n        // If it's not a number, it's a host binding function that needs to be executed.\n        if (instruction !== null) {\n          viewData[BINDING_INDEX] = bindingRootIndex;\n          instruction(\n              RenderFlags.Update, readElementValue(viewData[currentDirectiveIndex]),\n              currentElementIndex);\n        }\n        currentDirectiveIndex++;\n      }\n    }\n  }\n}\n\n/** Refreshes content queries for all directives in the given view. */\nfunction refreshContentQueries(tView: TView): void {\n  if (tView.contentQueries != null) {\n    for (let i = 0; i < tView.contentQueries.length; i += 2) {\n      const directiveDefIdx = tView.contentQueries[i];\n      const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n\n      directiveDef.contentQueriesRefresh !(\n          directiveDefIdx - HEADER_OFFSET, tView.contentQueries[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(components: number[] | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i++) {\n      componentRefresh(components[i]);\n    }\n  }\n}\n\nexport function createLView<T>(\n    parentLView: LView | null, tView: TView, context: T | null, flags: LViewFlags,\n    rendererFactory?: RendererFactory3 | null, renderer?: Renderer3 | null,\n    sanitizer?: Sanitizer | null, injector?: Injector | null): LView {\n  const lView = tView.blueprint.slice() as LView;\n  lView[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.RunInit |\n      LViewFlags.FirstLViewPass;\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]) !;\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]) !;\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null !;\n  lView[INJECTOR as any] = injector || parentLView && parentLView[INJECTOR] || null;\n  return lView;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null,\n    attrs: TAttributes | null): TElementNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Container, native: RComment, name: string | null,\n    attrs: TAttributes | null): TContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Projection, native: null, name: null,\n    attrs: TAttributes | null): TProjectionNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.ElementContainer, native: RComment, name: string | null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.IcuContainer, native: RComment, name: null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType, native: RText | RElement | RComment | null, name: string | null,\n    attrs: TAttributes | null): TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&\n    TIcuContainerNode {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode &&\n      assertLessThan(adjustedIndex, lView.length, `Slot should have been initialized with null`);\n  lView[adjustedIndex] = native;\n\n  let tNode = tView.data[adjustedIndex] as TNode;\n  if (tNode == null) {\n    // TODO(misko): Refactor createTNode so that it does not depend on LView.\n    tNode = tView.data[adjustedIndex] = createTNode(lView, type, adjustedIndex, name, attrs, null);\n  }\n\n  // Now link ourselves into the tree.\n  // We need this even if tNode exists, otherwise we might end up pointing to unexisting tNodes when\n  // we use i18n (especially with ICU expressions that update the DOM during the update phase).\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  const isParent = getIsParent();\n  if (previousOrParentTNode) {\n    if (isParent && previousOrParentTNode.child == null &&\n        (tNode.parent !== null || previousOrParentTNode.type === TNodeType.View)) {\n      // We are in the same view, which means we are adding content node to the parent view.\n      previousOrParentTNode.child = tNode;\n    } else if (!isParent) {\n      previousOrParentTNode.next = tNode;\n    }\n  }\n\n  if (tView.firstChild == null) {\n    tView.firstChild = tNode;\n  }\n\n  setPreviousOrParentTNode(tNode);\n  setIsParent(true);\n  return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n      TProjectionNode & TIcuContainerNode;\n}\n\nexport function createViewNode(index: number, view: LView) {\n  // View nodes are not stored in data because they can be added / removed at runtime (which\n  // would cause indices to change). Their TNodes are instead stored in tView.node.\n  if (view[TVIEW].node == null) {\n    view[TVIEW].node = createTNode(view, TNodeType.View, index, null, null, null) as TViewNode;\n  }\n\n  return view[HOST_NODE] = view[TVIEW].node as TViewNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n */\nexport function allocExpando(view: LView) {\n  const tView = view[TVIEW];\n  if (tView.firstTemplatePass) {\n    tView.expandoStartIndex++;\n    tView.blueprint.push(null);\n    tView.data.push(null);\n    view.push(null);\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param templateFn Template function with the instructions.\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T,\n    providedRendererFactory: RendererFactory3, hostView: LView | null,\n    directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null,\n    sanitizer?: Sanitizer | null): LView {\n  if (hostView == null) {\n    resetComponentState();\n    const renderer = providedRendererFactory.createRenderer(null, null);\n\n    // We need to create a root view so it's possible to look up the host element through its index\n    const hostLView = createLView(\n        null, createTView(-1, null, 1, 0, null, null, null), {},\n        LViewFlags.CheckAlways | LViewFlags.IsRoot, providedRendererFactory, renderer);\n    enterView(hostLView, null);  // SUSPECT! why do we need to enter the View?\n\n    const componentTView =\n        getOrCreateTView(templateFn, consts, vars, directives || null, pipes || null, null);\n    hostView = createLView(\n        hostLView, componentTView, context, LViewFlags.CheckAlways, providedRendererFactory,\n        renderer, sanitizer);\n    hostView[HOST_NODE] = createNodeAtIndex(0, TNodeType.Element, hostNode, null, null);\n  }\n  renderComponentOrTemplate(hostView, context, templateFn);\n  return hostView;\n}\n\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport function createEmbeddedViewAndNode<T>(\n    tView: TView, context: T, declarationView: LView, renderer: Renderer3, queries: LQueries | null,\n    injectorIndex: number): LView {\n  const _isParent = getIsParent();\n  const _previousOrParentTNode = getPreviousOrParentTNode();\n  setIsParent(true);\n  setPreviousOrParentTNode(null !);\n\n  const lView = createLView(declarationView, tView, context, LViewFlags.CheckAlways);\n  lView[DECLARATION_VIEW] = declarationView;\n\n  if (queries) {\n    lView[QUERIES] = queries.createView();\n  }\n  createViewNode(-1, lView);\n\n  if (tView.firstTemplatePass) {\n    tView.node !.injectorIndex = injectorIndex;\n  }\n\n  setIsParent(_isParent);\n  setPreviousOrParentTNode(_previousOrParentTNode);\n  return lView;\n}\n\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport function renderEmbeddedTemplate<T>(viewToRender: LView, tView: TView, context: T) {\n  const _isParent = getIsParent();\n  const _previousOrParentTNode = getPreviousOrParentTNode();\n  setIsParent(true);\n  setPreviousOrParentTNode(null !);\n  let oldView: LView;\n  if (viewToRender[FLAGS] & LViewFlags.IsRoot) {\n    // This is a root view inside the view tree\n    tickRootContext(getRootContext(viewToRender));\n  } else {\n    try {\n      setIsParent(true);\n      setPreviousOrParentTNode(null !);\n\n      oldView = enterView(viewToRender, viewToRender[HOST_NODE]);\n      namespaceHTML();\n      tView.template !(getRenderFlags(viewToRender), context);\n      // This must be set to false immediately after the first creation run because in an\n      // ngFor loop, all the views will be created together before update mode runs and turns\n      // off firstTemplatePass. If we don't set it here, instances will perform directive\n      // matching, etc again and again.\n      viewToRender[TVIEW].firstTemplatePass = false;\n      setFirstTemplatePass(false);\n\n      refreshDescendantViews(viewToRender);\n    } finally {\n      leaveView(oldView !);\n      setIsParent(_isParent);\n      setPreviousOrParentTNode(_previousOrParentTNode);\n    }\n  }\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n */\nexport function nextContext<T = any>(level: number = 1): T {\n  return nextContextImpl(level);\n}\n\nfunction renderComponentOrTemplate<T>(\n    hostView: LView, context: T, templateFn?: ComponentTemplate<T>) {\n  const rendererFactory = hostView[RENDERER_FACTORY];\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  const normalExecutionPath = !getCheckNoChangesMode();\n  try {\n    if (normalExecutionPath && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n\n    if (isCreationMode(hostView)) {\n      // creation mode pass\n      if (templateFn) {\n        namespaceHTML();\n        templateFn(RenderFlags.Create, context !);\n      }\n\n      refreshDescendantViews(hostView);\n      hostView[FLAGS] &= ~LViewFlags.CreationMode;\n    }\n\n    // update mode pass\n    templateFn && templateFn(RenderFlags.Update, context !);\n    refreshDescendantViews(hostView);\n  } finally {\n    if (normalExecutionPath && rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. Update block and create block are\n * always run separately.\n */\nfunction getRenderFlags(view: LView): RenderFlags {\n  return isCreationMode(view) ? RenderFlags.Create : RenderFlags.Update;\n}\n\n//////////////////////////\n//// Namespace\n//////////////////////////\n\nlet _currentNamespace: string|null = null;\n\nexport function namespaceSVG() {\n  _currentNamespace = 'http://www.w3.org/2000/svg';\n}\n\nexport function namespaceMathML() {\n  _currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\nexport function namespaceHTML() {\n  _currentNamespace = null;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes, classes, and styles to be written into the DOM\n *              element on creation. Use [AttributeMarker] to denote the meaning of this array.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function element(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  elementStart(index, name, attrs, localRefs);\n  elementEnd();\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrs Set of attributes to be used when matching directives.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n */\nexport function elementContainerStart(\n    index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const renderer = lView[RENDERER];\n  const tagName = 'ng-container';\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], tView.bindingStartIndex,\n                   'element containers should be created before any bindings');\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = renderer.createComment(ngDevMode ? tagName : '');\n\n  ngDevMode && assertDataInRange(lView, index - 1);\n  const tNode =\n      createNodeAtIndex(index, TNodeType.ElementContainer, native, tagName, attrs || null);\n\n  appendChild(native, tNode, lView);\n  createDirectivesAndLocals(tView, lView, localRefs);\n  attachPatchData(native, lView);\n}\n\n/** Mark the end of the <ng-container>. */\nexport function elementContainerEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertHasParent(getPreviousOrParentTNode());\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.ElementContainer);\n  const currentQueries = lView[QUERIES];\n  if (currentQueries) {\n    lView[QUERIES] = currentQueries.addNode(previousOrParentTNode as TElementContainerNode);\n  }\n\n  queueLifecycleHooks(tView, previousOrParentTNode);\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes, classes, and styles to be written into the DOM\n *              element on creation. Use [AttributeMarker] to denote the meaning of this array.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], tView.bindingStartIndex,\n                   'elements should be created before any bindings ');\n\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  const native = elementCreate(name);\n\n  ngDevMode && assertDataInRange(lView, index - 1);\n\n  const tNode = createNodeAtIndex(index, TNodeType.Element, native !, name, attrs || null);\n\n  if (attrs) {\n    // it's important to only prepare styling-related datastructures once for a given\n    // tNode and not each time an element is created. Also, the styling code is designed\n    // to be patched and constructed at various points, but only up until the first element\n    // is created. Then the styling context is locked and can only be instantiated for each\n    // successive element that is created.\n    if (tView.firstTemplatePass && !tNode.stylingTemplate && hasStyling(attrs)) {\n      tNode.stylingTemplate = initializeStaticStylingContext(attrs);\n    }\n    setUpAttributes(native, attrs);\n  }\n\n  appendChild(native, tNode, lView);\n  createDirectivesAndLocals(tView, lView, localRefs);\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n\n  // if a directive contains a host binding for \"class\" then all class-based data will\n  // flow through that (except for `[class.prop]` bindings). This also includes initial\n  // static class values as well. (Note that this will be fixed once map-based `[style]`\n  // and `[class]` bindings work for multiple directives.)\n  if (tView.firstTemplatePass) {\n    const inputData = initializeTNodeInputs(tNode);\n    if (inputData && inputData.hasOwnProperty('class')) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n  }\n\n  // There is no point in rendering styles when a class directive is present since\n  // it will take that over for us (this will be removed once #FW-882 is in).\n  if (tNode.stylingTemplate && (tNode.flags & TNodeFlags.hasClassInput) === 0) {\n    renderInitialStylesAndClasses(native, tNode.stylingTemplate, lView[RENDERER]);\n  }\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement {\n  let native: RElement;\n  const rendererToUse = overriddenRenderer || getLView()[RENDERER];\n\n  if (isProceduralRenderer(rendererToUse)) {\n    native = rendererToUse.createElement(name, _currentNamespace);\n  } else {\n    if (_currentNamespace === null) {\n      native = rendererToUse.createElement(name);\n    } else {\n      native = rendererToUse.createElementNS(_currentNamespace, name);\n    }\n  }\n  return native;\n}\n\n/**\n * Creates directive instances and populates local refs.\n *\n * @param localRefs Local refs of the node in question\n * @param localRefExtractor mapping function that extracts local ref value from TNode\n */\nfunction createDirectivesAndLocals(\n    tView: TView, viewData: LView, localRefs: string[] | null | undefined,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode) {\n  if (!getBindingsEnabled()) return;\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  if (getFirstTemplatePass()) {\n    ngDevMode && ngDevMode.firstTemplatePass++;\n\n    resolveDirectives(\n        tView, viewData, findDirectiveMatches(tView, viewData, previousOrParentTNode),\n        previousOrParentTNode, localRefs || null);\n  }\n  instantiateAllDirectives(tView, viewData, previousOrParentTNode);\n  invokeDirectivesHostBindings(tView, viewData, previousOrParentTNode);\n  saveResolvedLocalsInData(viewData, previousOrParentTNode, localRefExtractor);\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(\n    viewData: LView, tNode: TNode, localRefExtractor: LocalRefExtractor): void {\n  const localNames = tNode.localNames;\n  if (localNames) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param templateFn The template from which to get static data\n * @param consts The number of nodes, local refs, and pipes in this view\n * @param vars The number of bindings and pure function bindings in this view\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nexport function getOrCreateTView(\n    templateFn: ComponentTemplate<any>, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\n  // 1. It is a megamorphic call on each invocation.\n  // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\n  //    outer template invocation, which means that no such property will exist\n  // Correct solution is to only put `ngPrivateData` on the Component template\n  // and not on embedded templates.\n\n  return templateFn.ngPrivateData ||\n      (templateFn.ngPrivateData =\n           createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery) as never);\n}\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport function createTView(\n    viewIndex: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + consts;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW as any] = {\n    id: viewIndex,\n    blueprint: blueprint,\n    template: templateFn,\n    viewQuery: viewQuery,\n    node: null !,\n    data: blueprint.slice(),  // Fill in to match HEADER_OFFSET in LView\n    childIndex: -1,           // Children set in addToViewTree(), if any\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    expandoInstructions: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    firstChild: null,\n  };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LView {\n  const blueprint = new Array(initialViewLength)\n                        .fill(null, 0, bindingStartIndex)\n                        .fill(NO_CHANGE, bindingStartIndex) as LView;\n  blueprint[CONTAINER_INDEX] = -1;\n  blueprint[BINDING_INDEX] = bindingStartIndex;\n  return blueprint;\n}\n\nfunction setUpAttributes(native: RElement, attrs: TAttributes): void {\n  const renderer = getLView()[RENDERER];\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i++];\n    if (typeof attrName == 'number') {\n      if (attrName === AttributeMarker.NamespaceURI) {\n        // Namespaced attributes\n        const namespaceURI = attrs[i++] as string;\n        const attrName = attrs[i++] as string;\n        const attrVal = attrs[i++] as string;\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName, attrVal, namespaceURI) :\n            native.setAttributeNS(namespaceURI, attrName, attrVal);\n      } else {\n        // All other `AttributeMarker`s are ignored here.\n        break;\n      }\n    } else {\n      /// attrName is string;\n      const attrVal = attrs[i++];\n      if (attrName !== NG_PROJECT_AS_ATTR_NAME) {\n        // Standard attributes\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        if (isAnimationProp(attrName)) {\n          if (isProc) {\n            (renderer as ProceduralRenderer3).setProperty(native, attrName, attrVal);\n          }\n        } else {\n          isProc ?\n              (renderer as ProceduralRenderer3)\n                  .setAttribute(native, attrName as string, attrVal as string) :\n              native.setAttribute(attrName as string, attrVal as string);\n        }\n      }\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  const lView = getLView();\n  const tNode = getPreviousOrParentTNode();\n  const tView = lView[TVIEW];\n  const firstTemplatePass = tView.firstTemplatePass;\n  const tCleanup: false|any[] = firstTemplatePass && (tView.cleanup || (tView.cleanup = []));\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer);\n\n  // add native event listener - applicable to elements only\n  if (tNode.type === TNodeType.Element) {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    ngDevMode && ngDevMode.rendererAddEventListener++;\n    const renderer = lView[RENDERER];\n    const lCleanup = getCleanup(lView);\n    const lCleanupIndex = lCleanup.length;\n    let useCaptureOrSubIdx: boolean|number = useCapture;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      const cleanupFn = renderer.listen(native, eventName, listenerFn);\n      lCleanup.push(listenerFn, cleanupFn);\n      useCaptureOrSubIdx = lCleanupIndex + 1;\n    } else {\n      const wrappedListener = wrapListenerWithPreventDefault(listenerFn);\n      native.addEventListener(eventName, wrappedListener, useCapture);\n      lCleanup.push(wrappedListener);\n    }\n    tCleanup && tCleanup.push(eventName, tNode.index, lCleanupIndex, useCaptureOrSubIdx);\n  }\n\n  // subscribe to directive outputs\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(tNode, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let props: PropertyAliasValue|undefined;\n  if (outputs && (props = outputs[eventName])) {\n    const propsLength = props.length;\n    if (propsLength) {\n      const lCleanup = getCleanup(lView);\n      for (let i = 0; i < propsLength; i += 2) {\n        ngDevMode && assertDataInRange(lView, props[i] as number);\n        const subscription = lView[props[i] as number][props[i + 1]].subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(lView: LView, context: any, cleanupFn: Function): void {\n  const lCleanup = getCleanup(lView);\n  lCleanup.push(context);\n\n  if (lView[TVIEW].firstTemplatePass) {\n    getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LView, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertHasParent(getPreviousOrParentTNode());\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Element);\n  const lView = getLView();\n  const currentQueries = lView[QUERIES];\n  if (currentQueries) {\n    lView[QUERIES] = currentQueries.addNode(previousOrParentTNode as TElementNode);\n  }\n\n  queueLifecycleHooks(getLView()[TVIEW], previousOrParentTNode);\n  decreaseElementDepthCount();\n\n  // this is fired at the end of elementEnd because ALL of the stylingBindings code\n  // (for directives and the template) have now executed which means the styling\n  // context can be instantiated properly.\n  if (hasClassInput(previousOrParentTNode)) {\n    const stylingContext = getStylingContext(previousOrParentTNode.index, lView);\n    setInputsForProperty(\n        lView, previousOrParentTNode.inputs !['class'] !, getInitialClassNameValue(stylingContext));\n  }\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: SanitizerFn | null): void {\n  if (value !== NO_CHANGE) {\n    const lView = getLView();\n    const renderer = lView[RENDERER];\n    const element = getNativeByIndex(index, lView);\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveAttribute++;\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name) :\n                                       element.removeAttribute(name);\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element, name, strValue) :\n                                       element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @param nativeOnly Whether or not we should only set native properties and skip input check\n * (this is necessary for host property bindings)\n */\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean): void {\n  elementPropertyInternal(index, propName, value, sanitizer, nativeOnly);\n}\n\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub components renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @param nativeOnly Whether or not we should only set native properties and skip input check\n * (this is necessary for host property bindings)\n */\nexport function componentHostSyntheticProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean) {\n  elementPropertyInternal(index, propName, value, sanitizer, nativeOnly, loadComponentRenderer);\n}\n\nfunction loadComponentRenderer(tNode: TNode, lView: LView): Renderer3 {\n  const componentLView = lView[tNode.index] as LView;\n  return componentLView[RENDERER];\n}\n\nfunction elementPropertyInternal<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean,\n    loadRendererFn?: ((tNode: TNode, lView: LView) => Renderer3) | null): void {\n  if (value === NO_CHANGE) return;\n  const lView = getLView();\n  const element = getNativeByIndex(index, lView) as RElement | RComment;\n  const tNode = getTNode(index, lView);\n  let inputData: PropertyAliases|null|undefined;\n  let dataValue: PropertyAliasValue|undefined;\n  if (!nativeOnly && (inputData = initializeTNodeInputs(tNode)) &&\n      (dataValue = inputData[propName])) {\n    setInputsForProperty(lView, dataValue, value);\n    if (isComponent(tNode)) markDirtyIfOnPush(lView, index + HEADER_OFFSET);\n    if (ngDevMode) {\n      if (tNode.type === TNodeType.Element || tNode.type === TNodeType.Container) {\n        setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n      }\n    }\n  } else if (tNode.type === TNodeType.Element) {\n    const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    ngDevMode && ngDevMode.rendererSetProperty++;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(element as RElement, propName, value);\n    } else if (!isAnimationProp(propName)) {\n      (element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                          (element as any)[propName] = value;\n    }\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    lView: LView, type: TNodeType, adjustedIndex: number, tagName: string | null,\n    attrs: TAttributes | null, tViews: TView[] | null): TNode {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  ngDevMode && ngDevMode.tNode++;\n  const parent =\n      getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const parentInSameView = parent && lView && parent !== lView[HOST_NODE];\n  const tParent = parentInSameView ? parent as TElementNode | TContainerNode : null;\n\n  return {\n    type: type,\n    index: adjustedIndex,\n    injectorIndex: tParent ? tParent.injectorIndex : -1,\n    directiveStart: -1,\n    directiveEnd: -1,\n    flags: 0,\n    providerIndexes: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    tViews: tViews,\n    next: null,\n    child: null,\n    parent: tParent,\n    detached: null,\n    stylingTemplate: null,\n    projection: null\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(lView: LView, inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(lView, inputs[i] as number);\n    lView[inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\nfunction setNgReflectProperties(\n    lView: LView, element: RElement | RComment, type: TNodeType, inputs: PropertyAliasValue,\n    value: any) {\n  for (let i = 0; i < inputs.length; i += 2) {\n    const renderer = lView[RENDERER];\n    const attrName = normalizeDebugBindingName(inputs[i + 1] as string);\n    const debugValue = normalizeDebugBindingValue(value);\n    if (type === TNodeType.Element) {\n      isProceduralRenderer(renderer) ?\n          renderer.setAttribute((element as RElement), attrName, debugValue) :\n          (element as RElement).setAttribute(attrName, debugValue);\n    } else if (value !== undefined) {\n      const value = `bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`;\n      if (isProceduralRenderer(renderer)) {\n        renderer.setValue((element as RComment), value);\n      } else {\n        (element as RComment).textContent = value;\n      }\n    }\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param tNodeFlags node flags\n * @param direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(tNode: TNode, direction: BindingDirection): PropertyAliases|null {\n  const tView = getLView()[TVIEW];\n  let propStore: PropertyAliases|null = null;\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n\n  if (end > start) {\n    const isInput = direction === BindingDirection.Input;\n    const defs = tView.data;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDef<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to register all\n * dynamic style and class bindings on the element. Note for static values (no binding)\n * see `elementStart` and `elementHostAttrs`.\n *\n * @param classBindingNames An array containing bindable class names.\n *        The `elementClassProp` refers to the class name by index in this array.\n *        (i.e. `['foo', 'bar']` means `foo=0` and `bar=1`).\n * @param styleBindingNames An array containing bindable style properties.\n *        The `elementStyleProp` refers to the class name by index in this array.\n *        (i.e. `['width', 'height']` means `width=0` and `height=1`).\n * @param styleSanitizer An optional sanitizer function that will be used to sanitize any CSS\n *        property values that are applied to the element (during rendering).\n *        Note that the sanitizer instance itself is tied to the `directive` (if  provided).\n * @param directive A directive instance the styling is associated with. If not provided\n *        current view's controller instance is assumed.\n *\n * @publicApi\n */\nexport function elementStyling(\n    classBindingNames?: string[] | null, styleBindingNames?: string[] | null,\n    styleSanitizer?: StyleSanitizeFn | null, directive?: {}): void {\n  const tNode = getPreviousOrParentTNode();\n  if (!tNode.stylingTemplate) {\n    tNode.stylingTemplate = createEmptyStylingContext();\n  }\n  updateContextWithBindings(\n      tNode.stylingTemplate !, directive || null, classBindingNames, styleBindingNames,\n      styleSanitizer, hasClassInput(tNode));\n}\n\n/**\n * Assign static styling values to a host element.\n *\n * NOTE: This instruction is meant to used from `hostBindings` function only.\n *\n * @param directive A directive instance the styling is associated with.\n * @param attrs An array containing class and styling information. The values must be marked with\n *              `AttributeMarker`.\n *\n *        ```\n *        var attrs = [AttributeMarker.Classes, 'foo', 'bar',\n *                     AttributeMarker.Styles, 'width', '100px', 'height, '200px']\n *        elementHostAttrs(directive, attrs);\n *        ```\n *\n * @publicApi\n */\nexport function elementHostAttrs(directive: any, attrs: TAttributes) {\n  const tNode = getPreviousOrParentTNode();\n  if (!tNode.stylingTemplate) {\n    tNode.stylingTemplate = initializeStaticStylingContext(attrs);\n  }\n  patchContextWithStaticAttrs(tNode.stylingTemplate, attrs, directive);\n}\n\n/**\n * Apply styling binding to the element.\n *\n * This instruction is meant to be run after `elementStyle` and/or `elementStyleProp`.\n * if any styling bindings have changed then the changes are flushed to the element.\n *\n *\n * @param index Index of the element's with which styling is associated.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\ncomponents\n *\n * @publicApi\n */\nexport function elementStylingApply(index: number, directive?: any): void {\n  const lView = getLView();\n  const isFirstRender = (lView[FLAGS] & LViewFlags.FirstLViewPass) !== 0;\n  const totalPlayersQueued = renderStyling(\n      getStylingContext(index + HEADER_OFFSET, lView), lView[RENDERER], lView, isFirstRender, null,\n      null, directive);\n  if (totalPlayersQueued > 0) {\n    const rootContext = getRootContext(lView);\n    scheduleTick(rootContext, RootContextFlags.FlushPlayers);\n  }\n}\n\n/**\n * Update a style bindings value on an element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling element is updated as part of `elementStylingApply`.)\n *\n * @param index Index of the element's with which styling is associated.\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `elementStlyingBindings`.\n * @param value New value to write (null to remove). Note that if a directive also\n *        attempts to write to the same binding value then it will only be able to\n *        do so if the template binding value is `null` (or doesn't exist at all).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\ncomponents\n *\n * @publicApi\n */\nexport function elementStyleProp(\n    index: number, styleIndex: number, value: string | number | String | PlayerFactory | null,\n    suffix?: string | null, directive?: {}): void {\n  let valueToAdd: string|null = null;\n  if (value !== null) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      valueToAdd = stringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a String value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      valueToAdd = value as any as string;\n    }\n  }\n  updateElementStyleProp(\n      getStylingContext(index + HEADER_OFFSET, getLView()), styleIndex, valueToAdd, directive);\n}\n\n/**\n * Add or remove a class via a class binding on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case and, therefore,\n * the class itself must already be applied using `elementStyling` within\n * the creation block.\n *\n * @param index Index of the element's with which styling is associated.\n * @param classIndex Index of class to toggle. This index value refers to the\n *        index of the class in the class bindings array that was passed into\n *        `elementStlyingBindings` (which is meant to be called before this\n *        function is).\n * @param value A true/false value which will turn the class on or off.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\ncomponents\n *\n * @publicApi\n */\nexport function elementClassProp(\n    index: number, classIndex: number, value: boolean | PlayerFactory, directive?: {}): void {\n  const onOrOffClassValue =\n      (value instanceof BoundPlayerFactory) ? (value as BoundPlayerFactory<boolean>) : (!!value);\n  updateElementClassProp(\n      getStylingContext(index + HEADER_OFFSET, getLView()), classIndex, onOrOffClassValue,\n      directive);\n}\n\n/**\n * Update style and/or class bindings using object literal.\n *\n * This instruction is meant apply styling via the `[style]=\"exp\"` and `[class]=\"exp\"` template\n * bindings. When styles are applied to the Element they will then be placed with respect to\n * any styles set with `elementStyleProp`. If any styles are set to `null` then they will be\n * removed from the element.\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's with which styling is associated.\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\n *\n * @publicApi\n */\nexport function elementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | NO_CHANGE | null,\n    styles?: {[styleName: string]: any} | NO_CHANGE | null, directive?: {}): void {\n  if (directive != undefined)\n    return hackImplementationOfElementStylingMap(\n        index, classes, styles, directive);  // supported in next PR\n  const lView = getLView();\n  const tNode = getTNode(index, lView);\n  const stylingContext = getStylingContext(index + HEADER_OFFSET, lView);\n  if (hasClassInput(tNode) && classes !== NO_CHANGE) {\n    const initialClasses = getInitialClassNameValue(stylingContext);\n    const classInputVal =\n        (initialClasses.length ? (initialClasses + ' ') : '') + (classes as string);\n    setInputsForProperty(lView, tNode.inputs !['class'] !, classInputVal);\n  } else {\n    updateStylingMap(stylingContext, classes, styles);\n  }\n}\n\n/* START OF HACK BLOCK */\nfunction hackImplementationOfElementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | NO_CHANGE | null,\n    styles?: {[styleName: string]: any} | NO_CHANGE | null, directive?: {}): void {\n  throw new Error('unimplemented. Should not be needed by ViewEngine compatibility');\n}\n/* END OF HACK BLOCK */\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  const lView = getLView();\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex,\n                   'text nodes should be created before any bindings');\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  const textNative = createTextNode(value, lView[RENDERER]);\n  const tNode = createNodeAtIndex(index, TNodeType.Element, textNative, null, null);\n\n  // Text nodes are self closing.\n  setIsParent(false);\n  appendChild(textNative, tNode, lView);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    const lView = getLView();\n    ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n    const element = getNativeByIndex(index, lView) as any as RText;\n    ngDevMode && assertDefined(element, 'native element should exist');\n    ngDevMode && ngDevMode.rendererSetText++;\n    const renderer = lView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.setValue(element, stringify(value)) :\n                                     element.textContent = stringify(value);\n  }\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(\n    tView: TView, viewData: LView, def: ComponentDef<T>): T {\n  const rootTNode = getPreviousOrParentTNode();\n  if (tView.firstTemplatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    generateExpandoInstructionBlock(tView, rootTNode, 1);\n    baseResolveDirective(tView, viewData, def, def.factory);\n  }\n  const directive =\n      getNodeInjectable(tView.data, viewData, viewData.length - 1, rootTNode as TElementNode);\n  postProcessBaseDirective(viewData, rootTNode, directive, def as DirectiveDef<T>);\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(\n    tView: TView, viewData: LView, directives: DirectiveDef<any>[] | null, tNode: TNode,\n    localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'should run on first template pass only');\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  if (directives) {\n    initNodeFlags(tNode, tView.data.length, directives.length);\n    // When the same token is provided by several directives on the same node, some rules apply in\n    // the viewEngine:\n    // - viewProviders have priority over providers\n    // - the last directive in NgModule.declarations has priority over the previous one\n    // So to match these rules, the order in which providers are added in the arrays is very\n    // important.\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n      if (def.providersResolver) def.providersResolver(def);\n    }\n    generateExpandoInstructionBlock(tView, tNode, directives.length);\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n\n      const directiveDefIdx = tView.data.length;\n      baseResolveDirective(tView, viewData, def, def.factory);\n\n      saveNameToExportMap(tView.data !.length - 1, def, exportsMap);\n\n      // Init hooks are queued now so ngOnInit is called in host components before\n      // any projected components.\n      queueInitHooks(directiveDefIdx, def.onInit, def.doCheck, tView);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n}\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView: TView, lView: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (!getFirstTemplatePass() && start < end) {\n    getOrCreateNodeInjectorForNode(\n        tNode as TElementNode | TContainerNode | TElementContainerNode, lView);\n  }\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    if (isComponentDef(def)) {\n      addComponentLogic(lView, tNode, def as ComponentDef<any>);\n    }\n    const directive = getNodeInjectable(tView.data, lView !, i, tNode as TElementNode);\n    postProcessDirective(lView, directive, def, i);\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView: TView, viewData: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const expando = tView.expandoInstructions !;\n  const firstTemplatePass = getFirstTemplatePass();\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const directive = viewData[i];\n    if (def.hostBindings) {\n      const previousExpandoLength = expando.length;\n      setCurrentDirectiveDef(def);\n      def.hostBindings !(RenderFlags.Create, directive, tNode.index - HEADER_OFFSET);\n      setCurrentDirectiveDef(null);\n      // `hostBindings` function may or may not contain `allocHostVars` call\n      // (e.g. it may not if it only contains host listeners), so we need to check whether\n      // `expandoInstructions` has changed and if not - we still push `hostBindings` to\n      // expando block, to make sure we execute it for DI cycle\n      if (previousExpandoLength === expando.length && firstTemplatePass) {\n        expando.push(def.hostBindings);\n      }\n    } else if (firstTemplatePass) {\n      expando.push(null);\n    }\n  }\n}\n\n/**\n* Generates a new block in TView.expandoInstructions for this node.\n*\n* Each expando block starts with the element index (turned negative so we can distinguish\n* it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n*/\nexport function generateExpandoInstructionBlock(\n    tView: TView, tNode: TNode, directiveCount: number): void {\n  ngDevMode && assertEqual(\n                   tView.firstTemplatePass, true,\n                   'Expando block should only be generated on first template pass.');\n\n  const elementIndex = -(tNode.index - HEADER_OFFSET);\n  const providerStartIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const providerCount = tView.data.length - providerStartIndex;\n  (tView.expandoInstructions || (tView.expandoInstructions = [\n   ])).push(elementIndex, providerCount, directiveCount);\n}\n\n/**\n* On the first template pass, we need to reserve space for host binding values\n* after directives are matched (so all directives are saved, then bindings).\n* Because we are updating the blueprint, we only need to do this once.\n*/\nfunction prefillHostVars(tView: TView, lView: LView, totalHostVars: number): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  for (let i = 0; i < totalHostVars; i++) {\n    lView.push(NO_CHANGE);\n    tView.blueprint.push(NO_CHANGE);\n    tView.data.push(null);\n  }\n}\n\n/**\n * Process a directive on the current node after its creation.\n */\nfunction postProcessDirective<T>(\n    viewData: LView, directive: T, def: DirectiveDef<T>, directiveDefIdx: number): void {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  postProcessBaseDirective(viewData, previousOrParentTNode, directive, def);\n  ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');\n  if (previousOrParentTNode && previousOrParentTNode.attrs) {\n    setInputsFromAttrs(directiveDefIdx, directive, def.inputs, previousOrParentTNode);\n  }\n\n  if (def.contentQueries) {\n    def.contentQueries(directiveDefIdx);\n  }\n\n  if (isComponentDef(def)) {\n    const componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);\n    componentView[CONTEXT] = directive;\n  }\n}\n\n/**\n * A lighter version of postProcessDirective() that is used for the root component.\n */\nfunction postProcessBaseDirective<T>(\n    lView: LView, previousOrParentTNode: TNode, directive: T, def: DirectiveDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, lView);\n\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex,\n                   'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent(getIsParent());\n\n  attachPatchData(directive, lView);\n  if (native) {\n    attachPatchData(native, lView);\n  }\n\n  // TODO(misko): setUpAttributes should be a feature for better treeshakability.\n  if (def.attributes != null && previousOrParentTNode.type == TNodeType.Element) {\n    setUpAttributes(native as RElement, def.attributes as string[]);\n  }\n}\n\n\n\n/**\n* Matches the current node against all available selectors.\n* If a component is matched (at most one), it is returned in first position in the array.\n*/\nfunction findDirectiveMatches(tView: TView, viewData: LView, tNode: TNode): DirectiveDef<any>[]|\n    null {\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'should run on first template pass only');\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors !, /* isProjectionMode */ false)) {\n        matches || (matches = []);\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode,\n                viewData),\n            viewData, def.type);\n\n        if (isComponentDef(def)) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          tNode.flags = TNodeFlags.isComponent;\n\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nexport function queueComponentIndexForCheck(previousOrParentTNode: TNode): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  const tView = getLView()[TVIEW];\n  (tView.components || (tView.components = [])).push(previousOrParentTNode.index);\n}\n\n/**\n * Stores host binding fn and number of host vars so it will be queued for binding refresh during\n * CD.\n*/\nfunction queueHostBindingForCheck(\n    tView: TView, def: DirectiveDef<any>| ComponentDef<any>, hostVars: number): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  const expando = tView.expandoInstructions !;\n  const length = expando.length;\n  // Check whether a given `hostBindings` function already exists in expandoInstructions,\n  // which can happen in case directive definition was extended from base definition (as a part of\n  // the `InheritDefinitionFeature` logic). If we found the same `hostBindings` function in the\n  // list, we just increase the number of host vars associated with that function, but do not add it\n  // into the list again.\n  if (length >= 2 && expando[length - 2] === def.hostBindings) {\n    expando[length - 1] = (expando[length - 1] as number) + hostVars;\n  } else {\n    expando.push(def.hostBindings !, hostVars);\n  }\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n* Builds up an export map as directives are created, so local refs can be quickly mapped\n* to their directive instances.\n*/\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDef<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'expected firstTemplatePass to be true');\n  const flags = tNode.flags;\n  ngDevMode && assertEqual(\n                   flags === 0 || flags === TNodeFlags.isComponent, true,\n                   'expected node flags to not be initialized');\n\n  ngDevMode && assertNotEqual(\n                   numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,\n                   'Reached the max number of directives');\n  // When the first directive is created on a node, save the index\n  tNode.flags = flags & TNodeFlags.isComponent;\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\nfunction baseResolveDirective<T>(\n    tView: TView, viewData: LView, def: DirectiveDef<T>,\n    directiveFactory: (t: Type<T>| null) => any) {\n  tView.data.push(def);\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\n  tView.blueprint.push(nodeInjectorFactory);\n  viewData.push(nodeInjectorFactory);\n}\n\nfunction addComponentLogic<T>(\n    lView: LView, previousOrParentTNode: TNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, lView);\n\n  const tView = getOrCreateTView(\n      def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(\n      lView, previousOrParentTNode.index as number,\n      createLView(\n          lView, tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways,\n          rendererFactory, lView[RENDERER_FACTORY].createRenderer(native as RElement, def)));\n\n  componentView[HOST_NODE] = previousOrParentTNode as TElementNode;\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  componentView[HOST] = lView[previousOrParentTNode.index];\n  lView[previousOrParentTNode.index] = componentView;\n\n  if (getFirstTemplatePass()) {\n    queueComponentIndexForCheck(previousOrParentTNode);\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[P in keyof T]: string;}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    }\n    const minifiedInputName = inputs[attrName];\n    const attrValue = attrs[i + 1];\n\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrValue as string);\n    }\n\n    i += 2;\n  }\n  return initialInputData;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement | RComment,\n    hostTNode: TElementNode | TContainerNode | TElementContainerNode, currentView: LView,\n    native: RComment, isForViewContainerRef?: boolean): LContainer {\n  return [\n    isForViewContainerRef ? -1 : 0,          // active index\n    [],                                      // views\n    currentView,                             // parent\n    null,                                    // next\n    null,                                    // queries\n    hostNative,                              // host native\n    native,                                  // native\n    getRenderParent(hostTNode, currentView)  // renderParent\n  ];\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param consts The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n */\nexport function template(\n    index: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null,\n    localRefExtractor?: LocalRefExtractor) {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  // TODO: consider a separate node type for templates\n  const tNode = containerInternal(index, tagName || null, attrs || null);\n\n  if (getFirstTemplatePass()) {\n    tNode.tViews = createTView(\n        -1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n\n  createDirectivesAndLocals(tView, lView, localRefs, localRefExtractor);\n  const currentQueries = lView[QUERIES];\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  const native = getNativeByTNode(previousOrParentTNode, lView);\n  attachPatchData(native, lView);\n  if (currentQueries) {\n    lView[QUERIES] = currentQueries.addNode(previousOrParentTNode as TContainerNode);\n  }\n  queueLifecycleHooks(tView, tNode);\n  setIsParent(false);\n}\n\n/**\n * Creates an LContainer for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n */\nexport function container(index: number): void {\n  const tNode = containerInternal(index, null, null);\n  getFirstTemplatePass() && (tNode.tViews = []);\n  setIsParent(false);\n}\n\nfunction containerInternal(\n    index: number, tagName: string | null, attrs: TAttributes | null): TNode {\n  const lView = getLView();\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex,\n                   'container nodes should be created before any bindings');\n\n  const adjustedIndex = index + HEADER_OFFSET;\n  const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const tNode = createNodeAtIndex(index, TNodeType.Container, comment, tagName, attrs);\n  const lContainer = lView[adjustedIndex] =\n      createLContainer(lView[adjustedIndex], tNode, lView, comment);\n\n  appendChild(comment, tNode, lView);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(lView, index + HEADER_OFFSET, lContainer);\n\n  const currentQueries = lView[QUERIES];\n  if (currentQueries) {\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer[QUERIES] = currentQueries.container();\n  }\n\n  ngDevMode && assertNodeType(getPreviousOrParentTNode(), TNodeType.Container);\n  return tNode;\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  let previousOrParentTNode = loadInternal(tView.data, index) as TNode;\n  setPreviousOrParentTNode(previousOrParentTNode);\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n  setIsParent(true);\n\n  lView[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\n\n  // We need to execute init hooks here so ngOnInit hooks are called in top level views\n  // before they are called in embedded views (for backwards compatibility).\n  executeInitHooks(lView, tView, getCheckNoChangesMode());\n}\n\n/**\n * Marks the end of the LContainer.\n *\n * Marking the end of LContainer is the time when to child views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.View);\n    ngDevMode && assertHasParent(previousOrParentTNode);\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n\n  const lContainer = getLView()[previousOrParentTNode.index];\n  const nextIndex = lContainer[ACTIVE_INDEX];\n\n  // remove extra views at the end of the container\n  while (nextIndex < lContainer[VIEWS].length) {\n    removeView(lContainer, previousOrParentTNode as TContainerNode, nextIndex);\n  }\n}\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\n * by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lView: LView) {\n  for (let current = getLViewChild(lView); current !== null; current = current[NEXT]) {\n    // Note: current can be an LView or an LContainer instance, but here we are only interested\n    // in LContainer. We can tell it's an LContainer because its length is less than the LView\n    // header.\n    if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {\n      const container = current as LContainer;\n      for (let i = 0; i < container[VIEWS].length; i++) {\n        const dynamicViewData = container[VIEWS][i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\n        renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT] !);\n      }\n    }\n  }\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param lContainer to search for views\n * @param tContainerNode to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    lContainer: LContainer, tContainerNode: TContainerNode, startIdx: number,\n    viewBlockId: number): LView|null {\n  const views = lContainer[VIEWS];\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i][TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(lContainer, tContainerNode, i);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the searchdef.cont here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags {\n  const lView = getLView();\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  // The previous node can be a view node if we are processing an inline for loop\n  const containerTNode = previousOrParentTNode.type === TNodeType.View ?\n      previousOrParentTNode.parent ! :\n      previousOrParentTNode;\n  const lContainer = lView[containerTNode.index] as LContainer;\n\n  ngDevMode && assertNodeType(containerTNode, TNodeType.Container);\n  let viewToRender = scanForView(\n      lContainer, containerTNode as TContainerNode, lContainer[ACTIVE_INDEX] !, viewBlockId);\n\n  if (viewToRender) {\n    setIsParent(true);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    viewToRender = createLView(\n        lView,\n        getOrCreateEmbeddedTView(viewBlockId, consts, vars, containerTNode as TContainerNode), null,\n        LViewFlags.CheckAlways);\n\n    if (lContainer[QUERIES]) {\n      viewToRender[QUERIES] = lContainer[QUERIES] !.createView();\n    }\n\n    createViewNode(viewBlockId, viewToRender);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  }\n  if (lContainer) {\n    if (isCreationMode(viewToRender)) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(viewToRender, lContainer, lView, lContainer[ACTIVE_INDEX] !, -1);\n    }\n    lContainer[ACTIVE_INDEX] !++;\n  }\n  return isCreationMode(viewToRender) ? RenderFlags.Create | RenderFlags.Update :\n                                        RenderFlags.Update;\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param vars The number of bindings and pure function bindings in this template\n * @param container The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(\n    viewIndex: number, consts: number, vars: number, parent: TContainerNode): TView {\n  const tView = getLView()[TVIEW];\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = parent.tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] = createTView(\n        viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n  return containerTViews[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  const lView = getLView();\n  const viewHost = lView[HOST_NODE];\n\n  if (isCreationMode(lView)) {\n    refreshDescendantViews(lView);  // creation mode pass\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n  }\n  refreshDescendantViews(lView);  // update mode pass\n  leaveView(lView[PARENT] !);\n  setPreviousOrParentTNode(viewHost !);\n  setIsParent(false);\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param adjustedElementIndex  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nexport function componentRefresh<T>(adjustedElementIndex: number): void {\n  const lView = getLView();\n  ngDevMode && assertDataInRange(lView, adjustedElementIndex);\n  const hostView = getComponentViewByIndex(adjustedElementIndex, lView);\n  ngDevMode && assertNodeType(lView[TVIEW].data[adjustedElementIndex] as TNode, TNodeType.Element);\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    syncViewWithBlueprint(hostView);\n    checkView(hostView, hostView[CONTEXT]);\n  }\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param componentView The view to sync\n */\nfunction syncViewWithBlueprint(componentView: LView) {\n  const componentTView = componentView[TVIEW];\n  for (let i = componentView.length; i < componentTView.blueprint.length; i++) {\n    componentView[i] = componentTView.blueprint[i];\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nexport function viewAttached(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const componentNode = findComponentView(getLView())[HOST_NODE] as TElementNode;\n\n  if (!componentNode.projection) {\n    const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n    const pData: (TNode | null)[] = componentNode.projection =\n        new Array(noOfNodeBuckets).fill(null);\n    const tails: (TNode | null)[] = pData.slice();\n\n    let componentChild: TNode|null = componentNode.child;\n\n    while (componentChild !== null) {\n      const bucketIndex =\n          selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors !) : 0;\n      const nextNode = componentChild.next;\n\n      if (tails[bucketIndex]) {\n        tails[bucketIndex] !.next = componentChild;\n      } else {\n        pData[bucketIndex] = componentChild;\n        componentChild.next = null;\n      }\n      tails[bucketIndex] = componentChild;\n\n      componentChild = nextNode;\n    }\n  }\n}\n\n/**\n * Stack used to keep track of projection nodes in projection() instruction.\n *\n * This is deliberately created outside of projection() to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LView | TNode)[] = [];\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(nodeIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const lView = getLView();\n  const tProjectionNode =\n      createNodeAtIndex(nodeIndex, TNodeType.Projection, null, null, attrs || null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  setIsParent(false);\n\n  // re-distribution of projectable nodes is stored on a component's view level\n  const componentView = findComponentView(lView);\n  const componentNode = componentView[HOST_NODE] as TElementNode;\n  let nodeToProject = (componentNode.projection as(TNode | null)[])[selectorIndex];\n  let projectedView = componentView[PARENT] !;\n  let projectionNodeIndex = -1;\n\n  while (nodeToProject) {\n    if (nodeToProject.type === TNodeType.Projection) {\n      // This node is re-projected, so we must go up the tree to get its projected nodes.\n      const currentComponentView = findComponentView(projectedView);\n      const currentComponentHost = currentComponentView[HOST_NODE] as TElementNode;\n      const firstProjectedNode =\n          (currentComponentHost.projection as(TNode | null)[])[nodeToProject.projection as number];\n\n      if (firstProjectedNode) {\n        projectionNodeStack[++projectionNodeIndex] = nodeToProject;\n        projectionNodeStack[++projectionNodeIndex] = projectedView;\n\n        nodeToProject = firstProjectedNode;\n        projectedView = currentComponentView[PARENT] !;\n        continue;\n      }\n    } else {\n      // This flag must be set now or we won't know that this node is projected\n      // if the nodes are inserted into a container later.\n      nodeToProject.flags |= TNodeFlags.isProjected;\n      appendProjectedNode(nodeToProject, tProjectionNode, lView, projectedView);\n    }\n\n    // If we are finished with a list of re-projected nodes, we need to get\n    // back to the root projection node that was re-projected.\n    if (nodeToProject.next === null && projectedView !== componentView[PARENT] !) {\n      projectedView = projectionNodeStack[projectionNodeIndex--] as LView;\n      nodeToProject = projectionNodeStack[projectionNodeIndex--] as TNode;\n    }\n    nodeToProject = nodeToProject.next;\n  }\n}\n\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param state The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(\n    lView: LView, adjustedHostIndex: number, state: T): T {\n  const tView = lView[TVIEW];\n  const firstTemplatePass = getFirstTemplatePass();\n  if (lView[TAIL]) {\n    lView[TAIL] ![NEXT] = state;\n  } else if (firstTemplatePass) {\n    tView.childIndex = adjustedHostIndex;\n  }\n  lView[TAIL] = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  const childComponentLView = getComponentViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\n/** Wraps an event listener with preventDefault behavior. */\nfunction wrapListenerWithPreventDefault(listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_preventDefault(e: Event) {\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(lView: LView): void {\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView[FLAGS] |= LViewFlags.Dirty;\n    lView = lView[PARENT] !;\n  }\n  lView[FLAGS] |= LViewFlags.Dirty;\n  ngDevMode && assertDefined(lView[CONTEXT], 'rootContext should be defined');\n\n  const rootContext = lView[CONTEXT] as RootContext;\n  scheduleTick(rootContext, RootContextFlags.DetectChanges);\n}\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  rootContext.flags |= flags;\n\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res !(null);\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n\nfunction tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    renderComponentOrTemplate(readPatchedLView(rootComponent) !, rootComponent);\n  }\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const view = getComponentViewByInstance(component) !;\n  detectChangesInternal<T>(view, component);\n}\n\nexport function detectChangesInternal<T>(view: LView, context: T) {\n  const rendererFactory = view[RENDERER_FACTORY];\n\n  if (rendererFactory.begin) rendererFactory.begin();\n\n  if (isCreationMode(view)) {\n    checkView(view, context);  // creation mode pass\n  }\n  checkView(view, context);  // update mode pass\n\n  if (rendererFactory.end) rendererFactory.end();\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lView: LView): void {\n  tickRootContext(lView[CONTEXT] as RootContext);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChanges(component);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lView: LView): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nexport function checkView<T>(hostView: LView, component: T) {\n  const hostTView = hostView[TVIEW];\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  const templateFn = hostTView.template !;\n  const viewQuery = hostTView.viewQuery;\n\n  try {\n    namespaceHTML();\n    createViewQuery(viewQuery, hostView, component);\n    templateFn(getRenderFlags(hostView), component);\n    refreshDescendantViews(hostView);\n    updateViewQuery(viewQuery, hostView, component);\n  } finally {\n    leaveView(oldView);\n  }\n}\n\nfunction createViewQuery<T>(viewQuery: ComponentQuery<{}>| null, view: LView, component: T): void {\n  if (viewQuery && isCreationMode(view)) {\n    viewQuery(RenderFlags.Create, component);\n  }\n}\n\nfunction updateViewQuery<T>(viewQuery: ComponentQuery<{}>| null, view: LView, component: T): void {\n  if (viewQuery && !isCreationMode(view)) {\n    viewQuery(RenderFlags.Update, component);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n *\n * @publicApi\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  markViewDirty(getComponentViewByInstance(component));\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T): T|NO_CHANGE {\n  const lView = getLView();\n  return bindingUpdated(lView, lView[BINDING_INDEX]++, value) ? value : NO_CHANGE;\n}\n\n/**\n * Allocates the necessary amount of slots for host vars.\n *\n * @param count Amount of vars to be allocated\n */\nexport function allocHostVars(count: number): void {\n  if (!getFirstTemplatePass()) return;\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  queueHostBindingForCheck(tView, getCurrentDirectiveDef() !, count);\n  prefillHostVars(tView, lView, count);\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let different = false;\n  const lView = getLView();\n\n  let bindingIndex = lView[BINDING_INDEX];\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(lView, bindingIndex++, values[i]) && (different = true);\n  }\n  lView[BINDING_INDEX] = bindingIndex;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated(lView, lView[BINDING_INDEX], v0);\n  lView[BINDING_INDEX] += 1;\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated2(lView, lView[BINDING_INDEX], v0, v1);\n  lView[BINDING_INDEX] += 2;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated3(lView, lView[BINDING_INDEX], v0, v1, v2);\n  lView[BINDING_INDEX] += 3;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated4(lView, lView[BINDING_INDEX], v0, v1, v2, v3);\n  lView[BINDING_INDEX] += 4;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  lView[BINDING_INDEX] += 5;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  lView[BINDING_INDEX] += 6;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  lView[BINDING_INDEX] += 7;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  lView[BINDING_INDEX] += 8;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n  }\n  lView[adjustedIndex] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n */\nexport function reference<T>(index: number) {\n  const contextLView = getContextLView();\n  return loadInternal<T>(contextLView, index);\n}\n\nexport function loadQueryList<T>(queryListIdx: number): QueryList<T> {\n  const lView = getLView();\n  ngDevMode &&\n      assertDefined(\n          lView[CONTENT_QUERIES], 'Content QueryList array should be defined if reading a query.');\n  ngDevMode && assertDataInRange(lView[CONTENT_QUERIES] !, queryListIdx);\n\n  return lView[CONTENT_QUERIES] ![queryListIdx];\n}\n\n/** Retrieves a value from current `viewData`. */\nexport function load<T>(index: number): T {\n  return loadInternal<T>(getLView(), index);\n}\n\n\n\n///////////////////////////////\n//// DI\n///////////////////////////////\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags): T;\nexport function directiveInject<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  token = resolveForwardRef(token);\n  return getOrCreateInjectable<T>(\n      getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode,\n      getLView(), token, flags);\n}\n\n/**\n * Facade for the attribute injection from DI.\n */\nexport function injectAttribute(attrNameToInject: string): string|null {\n  return injectAttributeImpl(getPreviousOrParentTNode(), attrNameToInject);\n}\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport function registerContentQuery<Q>(\n    queryList: QueryList<Q>, currentDirectiveIndex: number): void {\n  const viewData = getLView();\n  const tView = viewData[TVIEW];\n  const savedContentQueriesLength =\n      (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\n  if (getFirstTemplatePass()) {\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex =\n        tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\n    if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\n      tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nfunction initializeTNodeInputs(tNode: TNode | null) {\n  // If tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked.\n  if (tNode) {\n    if (tNode.inputs === undefined) {\n      // mark inputs as checked\n      tNode.inputs = generatePropertyAliases(tNode, BindingDirection.Input);\n    }\n    return tNode.inputs;\n  }\n  return null;\n}\n\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n */\nexport function getCurrentView(): OpaqueViewState {\n  return getLView() as any as OpaqueViewState;\n}\n\nfunction getCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\n\nfunction getTViewCleanup(view: LView): any[] {\n  return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {callHooks} from './hooks';\nimport {LContainer, NATIVE, RENDER_PARENT, VIEWS, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeType, TViewNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {CLEANUP, CONTAINER_INDEX, FLAGS, HEADER_OFFSET, HOST_NODE, HookData, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeType} from './node_assert';\nimport {findComponentView, getNativeByTNode, isLContainer, isRootView, readElementValue, stringify} from './util';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\n/** Retrieves the parent element of a given node. */\nexport function getParentNative(tNode: TNode, currentView: LView): RElement|RComment|null {\n  if (tNode.parent == null) {\n    return getHostNative(currentView);\n  } else {\n    const parentTNode = getFirstParentNative(tNode);\n    return getNativeByTNode(parentTNode, currentView);\n  }\n}\n\n/**\n * Get the first parent of a node that isn't an IcuContainer TNode\n */\nfunction getFirstParentNative(tNode: TNode): TNode {\n  let parent = tNode.parent;\n  while (parent && parent.type === TNodeType.IcuContainer) {\n    parent = parent.parent;\n  }\n  return parent !;\n}\n\n/**\n * Gets the host element given a view. Will return null if the current view is an embedded view,\n * which does not have a host element.\n */\nexport function getHostNative(currentView: LView): RElement|null {\n  const hostTNode = currentView[HOST_NODE] as TElementNode;\n  return hostTNode && hostTNode.type !== TNodeType.View ?\n      (getNativeByTNode(hostTNode, currentView[PARENT] !) as RElement) :\n      null;\n}\n\nexport function getLContainer(tNode: TViewNode, embeddedView: LView): LContainer|null {\n  if (tNode.index === -1) {\n    // This is a dynamically created view inside a dynamic container.\n    // If the host index is -1, the view has not yet been inserted, so it has no parent.\n    const containerHostIndex = embeddedView[CONTAINER_INDEX];\n    return containerHostIndex > -1 ? embeddedView[PARENT] ![containerHostIndex] : null;\n  } else {\n    // This is a inline view node (e.g. embeddedViewStart)\n    return embeddedView[PARENT] ![tNode.parent !.index] as LContainer;\n  }\n}\n\n\n/**\n * Retrieves render parent for a given view.\n * Might be null if a view is not yet attached to any container.\n */\nexport function getContainerRenderParent(tViewNode: TViewNode, view: LView): RElement|null {\n  const container = getLContainer(tViewNode, view);\n  return container ? container[RENDER_PARENT] : null;\n}\n\nconst enum WalkTNodeTreeAction {\n  /** node insert in the native environment */\n  Insert = 0,\n\n  /** node detach from the native environment */\n  Detach = 1,\n\n  /** node destruction using the renderer's API */\n  Destroy = 2,\n}\n\n\n/**\n * Stack used to keep track of projection nodes in walkTNodeTree.\n *\n * This is deliberately created outside of walkTNodeTree to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LView | TNode)[] = [];\n\n/**\n * Walks a tree of TNodes, applying a transformation on the element nodes, either only on the first\n * one found, or on all of them.\n *\n * @param viewToWalk the view to walk\n * @param action identifies the action to be performed on the elements\n * @param renderer the current renderer.\n * @param renderParent Optional the render parent node to be set in all LContainers found,\n * required for action modes Insert and Destroy.\n * @param beforeNode Optional the node before which elements should be added, required for action\n * Insert.\n */\nfunction walkTNodeTree(\n    viewToWalk: LView, action: WalkTNodeTreeAction, renderer: Renderer3,\n    renderParent: RElement | null, beforeNode?: RNode | null) {\n  const rootTNode = viewToWalk[TVIEW].node as TViewNode;\n  let projectionNodeIndex = -1;\n  let currentView = viewToWalk;\n  let tNode: TNode|null = rootTNode.child as TNode;\n  while (tNode) {\n    let nextTNode: TNode|null = null;\n    if (tNode.type === TNodeType.Element) {\n      executeNodeAction(\n          action, renderer, renderParent, getNativeByTNode(tNode, currentView), beforeNode);\n      const nodeOrContainer = currentView[tNode.index];\n      if (isLContainer(nodeOrContainer)) {\n        // This element has an LContainer, and its comment needs to be handled\n        executeNodeAction(action, renderer, renderParent, nodeOrContainer[NATIVE], beforeNode);\n      }\n    } else if (tNode.type === TNodeType.Container) {\n      const lContainer = currentView ![tNode.index] as LContainer;\n      executeNodeAction(action, renderer, renderParent, lContainer[NATIVE], beforeNode);\n\n      if (renderParent) lContainer[RENDER_PARENT] = renderParent;\n\n      if (lContainer[VIEWS].length) {\n        currentView = lContainer[VIEWS][0];\n        nextTNode = currentView[TVIEW].node;\n\n        // When the walker enters a container, then the beforeNode has to become the local native\n        // comment node.\n        beforeNode = lContainer[NATIVE];\n      }\n    } else if (tNode.type === TNodeType.Projection) {\n      const componentView = findComponentView(currentView !);\n      const componentHost = componentView[HOST_NODE] as TElementNode;\n      const head: TNode|null =\n          (componentHost.projection as(TNode | null)[])[tNode.projection as number];\n\n      // Must store both the TNode and the view because this projection node could be nested\n      // deeply inside embedded views, and we need to get back down to this particular nested view.\n      projectionNodeStack[++projectionNodeIndex] = tNode;\n      projectionNodeStack[++projectionNodeIndex] = currentView !;\n      if (head) {\n        currentView = componentView[PARENT] !;\n        nextTNode = currentView[TVIEW].data[head.index] as TNode;\n      }\n    } else {\n      // Otherwise, this is a View or an ElementContainer\n      nextTNode = tNode.child;\n    }\n\n    if (nextTNode === null) {\n      // this last node was projected, we need to get back down to its projection node\n      if (tNode.next === null && (tNode.flags & TNodeFlags.isProjected)) {\n        currentView = projectionNodeStack[projectionNodeIndex--] as LView;\n        tNode = projectionNodeStack[projectionNodeIndex--] as TNode;\n      }\n      nextTNode = tNode.next;\n\n      /**\n       * Find the next node in the TNode tree, taking into account the place where a node is\n       * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n       *\n       * If there is no sibling node, then it goes to the next sibling of the parent node...\n       * until it reaches rootNode (at which point null is returned).\n       */\n      while (!nextTNode) {\n        // If parent is null, we're crossing the view boundary, so we should get the host TNode.\n        tNode = tNode.parent || currentView[TVIEW].node;\n\n        if (tNode === null || tNode === rootTNode) return null;\n\n        // When exiting a container, the beforeNode must be restored to the previous value\n        if (tNode.type === TNodeType.Container) {\n          currentView = currentView[PARENT] !;\n          beforeNode = currentView[tNode.index][NATIVE];\n        }\n\n        if (tNode.type === TNodeType.View && currentView[NEXT]) {\n          currentView = currentView[NEXT] as LView;\n          nextTNode = currentView[TVIEW].node;\n        } else {\n          nextTNode = tNode.next;\n        }\n      }\n    }\n    tNode = nextTNode;\n  }\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction executeNodeAction(\n    action: WalkTNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    node: RComment | RElement | RText, beforeNode?: RNode | null) {\n  if (action === WalkTNodeTreeAction.Insert) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).insertBefore(parent !, node, beforeNode as RNode | null) :\n        parent !.insertBefore(node, beforeNode as RNode | null, true);\n  } else if (action === WalkTNodeTreeAction.Detach) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).removeChild(parent !, node) :\n        parent !.removeChild(node);\n  } else if (action === WalkTNodeTreeAction.Destroy) {\n    ngDevMode && ngDevMode.rendererDestroyNode++;\n    (renderer as ProceduralRenderer3).destroyNode !(node);\n  }\n}\n\nexport function createTextNode(value: any, renderer: Renderer3): RText {\n  return isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                          renderer.createTextNode(stringify(value));\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param viewToWalk The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    viewToWalk: LView, insertMode: true, beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(viewToWalk: LView, insertMode: false): void;\nexport function addRemoveViewFromContainer(\n    viewToWalk: LView, insertMode: boolean, beforeNode?: RNode | null): void {\n  const renderParent = getContainerRenderParent(viewToWalk[TVIEW].node as TViewNode, viewToWalk);\n  ngDevMode && assertNodeType(viewToWalk[TVIEW].node as TNode, TNodeType.View);\n  if (renderParent) {\n    const renderer = viewToWalk[RENDERER];\n    walkTNodeTree(\n        viewToWalk, insertMode ? WalkTNodeTreeAction.Insert : WalkTNodeTreeAction.Detach, renderer,\n        renderParent, beforeNode);\n  }\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  if (rootView[TVIEW].childIndex === -1) {\n    return cleanUpView(rootView);\n  }\n  let viewOrContainer: LView|LContainer|null = getLViewChild(rootView);\n\n  while (viewOrContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (viewOrContainer.length >= HEADER_OFFSET) {\n      // If LView, traverse down to child.\n      const view = viewOrContainer as LView;\n      if (view[TVIEW].childIndex > -1) next = getLViewChild(view);\n    } else {\n      // If container, traverse down to its first LView.\n      const container = viewOrContainer as LContainer;\n      if (container[VIEWS].length) next = container[VIEWS][0];\n    }\n\n    if (next == null) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (viewOrContainer && !viewOrContainer ![NEXT] && viewOrContainer !== rootView) {\n        cleanUpView(viewOrContainer);\n        viewOrContainer = getParentState(viewOrContainer, rootView);\n      }\n      cleanUpView(viewOrContainer || rootView);\n      next = viewOrContainer && viewOrContainer ![NEXT];\n    }\n    viewOrContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param parentView The new parent of the inserted view\n * @param index The index at which to insert the view\n * @param containerIndex The index of the container node, if dynamic\n */\nexport function insertView(\n    lView: LView, lContainer: LContainer, parentView: LView, index: number,\n    containerIndex: number) {\n  const views = lContainer[VIEWS];\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    views[index - 1][NEXT] = lView;\n  }\n\n  if (index < views.length) {\n    lView[NEXT] = views[index];\n    views.splice(index, 0, lView);\n  } else {\n    views.push(lView);\n    lView[NEXT] = null;\n  }\n\n  // Dynamically inserted views need a reference to their parent container's host so it's\n  // possible to jump from a view to its container's next when walking the node tree.\n  if (containerIndex > -1) {\n    lView[CONTAINER_INDEX] = containerIndex;\n    lView[PARENT] = parentView;\n  }\n\n  // Notify query that a new view has been added\n  if (lView[QUERIES]) {\n    lView[QUERIES] !.insertView(index);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @param detached Whether or not this view is already detached.\n * @returns Detached LView instance.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number, detached: boolean): LView {\n  const views = lContainer[VIEWS];\n  const viewToDetach = views[removeIndex];\n  if (removeIndex > 0) {\n    views[removeIndex - 1][NEXT] = viewToDetach[NEXT] as LView;\n  }\n  views.splice(removeIndex, 1);\n  if (!detached) {\n    addRemoveViewFromContainer(viewToDetach, false);\n  }\n\n  if (viewToDetach[QUERIES]) {\n    viewToDetach[QUERIES] !.removeView();\n  }\n  viewToDetach[CONTAINER_INDEX] = -1;\n  viewToDetach[PARENT] = null;\n  // Unsets the attached flag\n  viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n  return viewToDetach;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param lContainer The container from which to remove a view\n * @param tContainer The TContainer node associated with the LContainer\n * @param removeIndex The index of the view to remove\n */\nexport function removeView(\n    lContainer: LContainer, containerHost: TElementNode | TContainerNode | TElementContainerNode,\n    removeIndex: number) {\n  const view = lContainer[VIEWS][removeIndex];\n  detachView(lContainer, removeIndex, !!containerHost.detached);\n  destroyLView(view);\n}\n\n/** Gets the child of the given LView */\nexport function getLViewChild(lView: LView): LView|LContainer|null {\n  const childIndex = lView[TVIEW].childIndex;\n  return childIndex === -1 ? null : lView[childIndex];\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param view The view to be destroyed.\n */\nexport function destroyLView(view: LView) {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n    walkTNodeTree(view, WalkTNodeTreeAction.Destroy, renderer, null);\n  }\n  destroyViewTree(view);\n  // Sets the destroyed flag\n  view[FLAGS] |= LViewFlags.Destroyed;\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(state: LView | LContainer, rootView: LView): LView|LContainer|null {\n  let tNode;\n  if (state.length >= HEADER_OFFSET && (tNode = (state as LView) ![HOST_NODE]) &&\n      tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getLContainer(tNode as TViewNode, state as LView) as LContainer;\n  } else {\n    // otherwise, use parent view for containers or component views\n    return state[PARENT] === rootView ? null : state[PARENT];\n  }\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param view The LView to clean up\n */\nfunction cleanUpView(viewOrContainer: LView | LContainer): void {\n  if ((viewOrContainer as LView).length >= HEADER_OFFSET) {\n    const view = viewOrContainer as LView;\n    executeOnDestroys(view);\n    executePipeOnDestroys(view);\n    removeListeners(view);\n    const hostTNode = view[HOST_NODE];\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (hostTNode && hostTNode.type === TNodeType.Element && isProceduralRenderer(view[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (view[RENDERER] as ProceduralRenderer3).destroy();\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(lView: LView): void {\n  const tCleanup = lView[TVIEW].cleanup !;\n  if (tCleanup != null) {\n    const lCleanup = lView[CLEANUP] !;\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a listener with the native renderer\n        const idx = tCleanup[i + 1];\n        const listener = lCleanup[tCleanup[i + 2]];\n        const native = readElementValue(lView[idx]);\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // DOM listener\n          native.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[-useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n        i += 2;\n      } else if (typeof tCleanup[i] === 'number') {\n        // This is a listener with renderer2 (cleanup fn can be found by index)\n        const cleanupFn = lCleanup[tCleanup[i]];\n        cleanupFn();\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LView): void {\n  const tView = view[TVIEW];\n  let destroyHooks: HookData|null;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    callHooks(view, destroyHooks);\n  }\n}\n\n/** Calls pipe destroy hooks for this view */\nfunction executePipeOnDestroys(lView: LView): void {\n  const pipeDestroyHooks = lView[TVIEW] && lView[TVIEW].pipeDestroyHooks;\n  if (pipeDestroyHooks) {\n    callHooks(lView !, pipeDestroyHooks);\n  }\n}\n\nexport function getRenderParent(tNode: TNode, currentView: LView): RElement|null {\n  if (canInsertNativeNode(tNode, currentView)) {\n    // If we are asked for a render parent of the root component we need to do low-level DOM\n    // operation as LTree doesn't exist above the topmost host node. We might need to find a render\n    // parent of the topmost host node if the root component injects ViewContainerRef.\n    if (isRootView(currentView)) {\n      return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));\n    }\n\n    const hostTNode = currentView[HOST_NODE];\n\n    const tNodeParent = tNode.parent;\n    if (tNodeParent != null && tNodeParent.type === TNodeType.ElementContainer) {\n      tNode = getHighestElementContainer(tNodeParent);\n    }\n\n    return tNode.parent == null && hostTNode !.type === TNodeType.View ?\n        getContainerRenderParent(hostTNode as TViewNode, currentView) :\n        getParentNative(tNode, currentView) as RElement;\n  }\n  return null;\n}\n\nfunction canInsertNativeChildOfElement(tNode: TNode): boolean {\n  // If the parent is null, then we are inserting across views. This happens when we\n  // insert a root element of the component view into the component host element and it\n  // should always be eager.\n  if (tNode.parent == null ||\n      // We should also eagerly insert if the parent is a regular, non-component element\n      // since we know that this relationship will never be broken.\n      tNode.parent.type === TNodeType.Element && !(tNode.parent.flags & TNodeFlags.isComponent)) {\n    return true;\n  }\n\n  // Parent is a Component. Component's content nodes are not inserted immediately\n  // because they will be projected, and so doing insert at this point would be wasteful.\n  // Since the projection would than move it to its final destination.\n  return false;\n}\n\n/**\n * We might delay insertion of children for a given view if it is disconnected.\n * This might happen for 2 main reasons:\n * - view is not inserted into any container (view was created but not inserted yet)\n * - view is inserted into a container but the container itself is not inserted into the DOM\n * (container might be part of projection or child of a view that is not inserted yet).\n *\n * In other words we can insert children of a given view if this view was inserted into a container\n * and\n * the container itself has its render parent determined.\n */\nfunction canInsertNativeChildOfView(viewTNode: TViewNode, view: LView): boolean {\n  // Because we are inserting into a `View` the `View` may be disconnected.\n  const container = getLContainer(viewTNode, view) !;\n  if (container == null || container[RENDER_PARENT] == null) {\n    // The `View` is not inserted into a `Container` or the parent `Container`\n    // itself is disconnected. So we have to delay.\n    return false;\n  }\n\n  // The parent `Container` is in inserted state, so we can eagerly insert into\n  // this location.\n  return true;\n}\n\n/**\n * Returns whether a native element can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is mare for projection but has not been inserted\n *   into destination.\n *\n\n *\n * @param tNode The tNode of the node that we want to insert.\n * @param currentView Current LView being processed.\n * @return boolean Whether the node should be inserted now (or delayed until later).\n */\nexport function canInsertNativeNode(tNode: TNode, currentView: LView): boolean {\n  let currentNode = tNode;\n  let parent: TNode|null = tNode.parent;\n\n  if (tNode.parent) {\n    if (tNode.parent.type === TNodeType.ElementContainer) {\n      currentNode = getHighestElementContainer(tNode);\n      parent = currentNode.parent;\n    } else if (tNode.parent.type === TNodeType.IcuContainer) {\n      currentNode = getFirstParentNative(currentNode);\n      parent = currentNode.parent;\n    }\n  }\n  if (parent === null) parent = currentView[HOST_NODE];\n\n  if (parent && parent.type === TNodeType.View) {\n    return canInsertNativeChildOfView(parent as TViewNode, currentView);\n  } else {\n    // Parent is a regular element or a component\n    return canInsertNativeChildOfElement(currentNode);\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nexport function nativeInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null): void {\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode);\n  } else {\n    parent.insertBefore(child, beforeNode, true);\n  }\n}\n\n/**\n * Returns a native parent of a given native node.\n */\nexport function nativeParentNode(renderer: Renderer3, node: RNode): RElement|null {\n  return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode) as RElement;\n}\n\n/**\n * Returns a native sibling of a given native node.\n */\nexport function nativeNextSibling(renderer: Renderer3, node: RNode): RNode|null {\n  return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param childEl The child that should be appended\n * @param childTNode The TNode of the child element\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(\n    childEl: RNode | null = null, childTNode: TNode, currentView: LView): boolean {\n  if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\n    const renderer = currentView[RENDERER];\n    const parentEl = getParentNative(childTNode, currentView);\n    const parentTNode: TNode = childTNode.parent || currentView[HOST_NODE] !;\n\n    if (parentTNode.type === TNodeType.View) {\n      const lContainer = getLContainer(parentTNode as TViewNode, currentView) as LContainer;\n      const views = lContainer[VIEWS];\n      const index = views.indexOf(currentView);\n      nativeInsertBefore(\n          renderer, lContainer[RENDER_PARENT] !, childEl,\n          getBeforeNodeForView(index, views, lContainer[NATIVE]));\n    } else if (parentTNode.type === TNodeType.ElementContainer) {\n      const renderParent = getRenderParent(childTNode, currentView) !;\n      nativeInsertBefore(renderer, renderParent, childEl, parentEl);\n    } else if (parentTNode.type === TNodeType.IcuContainer) {\n      const icuAnchorNode = getNativeByTNode(childTNode.parent !, currentView) !as RElement;\n      nativeInsertBefore(renderer, parentEl as RElement, childEl, icuAnchorNode);\n    } else {\n      isProceduralRenderer(renderer) ? renderer.appendChild(parentEl !as RElement, childEl) :\n                                       parentEl !.appendChild(childEl);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Gets the top-level ng-container if ng-containers are nested.\n *\n * @param ngContainer The TNode of the starting ng-container\n * @returns tNode The TNode of the highest level ng-container\n */\nfunction getHighestElementContainer(ngContainer: TNode): TNode {\n  while (ngContainer.parent != null && ngContainer.parent.type === TNodeType.ElementContainer) {\n    ngContainer = ngContainer.parent;\n  }\n  return ngContainer;\n}\n\nexport function getBeforeNodeForView(index: number, views: LView[], containerNative: RComment) {\n  if (index + 1 < views.length) {\n    const view = views[index + 1] as LView;\n    const viewTNode = view[HOST_NODE] as TViewNode;\n    return viewTNode.child ? getNativeByTNode(viewTNode.child, view) : containerNative;\n  } else {\n    return containerNative;\n  }\n}\n\n/**\n * Removes the `child` element from the DOM if not in view and not projected.\n *\n * @param childTNode The TNode of the child to remove\n * @param childEl The child that should be removed\n * @param currentView The current LView\n * @returns Whether or not the child was removed\n */\nexport function removeChild(childTNode: TNode, childEl: RNode | null, currentView: LView): boolean {\n  // We only remove the element if not in View or not projected.\n  if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\n    const parentNative = getParentNative(childTNode, currentView) !as RElement;\n    const renderer = currentView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.removeChild(parentNative as RElement, childEl) :\n                                     parentNative !.removeChild(childEl);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param projectedTNode The TNode to be projected\n * @param tProjectionNode The projection (ng-content) TNode\n * @param currentView Current LView\n * @param projectionView Projection view (view above current)\n */\nexport function appendProjectedNode(\n    projectedTNode: TNode, tProjectionNode: TNode, currentView: LView,\n    projectionView: LView): void {\n  const native = getNativeByTNode(projectedTNode, projectionView);\n  appendChild(native, tProjectionNode, currentView);\n\n  // the projected contents are processed while in the shadow view (which is the currentView)\n  // therefore we need to extract the view where the host element lives since it's the\n  // logical container of the content projected views\n  attachPatchData(native, projectionView);\n\n  const renderParent = getRenderParent(tProjectionNode, currentView);\n\n  const nodeOrContainer = projectionView[projectedTNode.index];\n  if (projectedTNode.type === TNodeType.Container) {\n    // The node we are adding is a container and we are adding it to an element which\n    // is not a component (no more re-projection).\n    // Alternatively a container is projected at the root of a component's template\n    // and can't be re-projected (as not content of any component).\n    // Assign the final projection location in those cases.\n    nodeOrContainer[RENDER_PARENT] = renderParent;\n    const views = nodeOrContainer[VIEWS];\n    for (let i = 0; i < views.length; i++) {\n      addRemoveViewFromContainer(views[i], true, nodeOrContainer[NATIVE]);\n    }\n  } else {\n    if (projectedTNode.type === TNodeType.ElementContainer) {\n      let ngContainerChildTNode: TNode|null = projectedTNode.child as TNode;\n      while (ngContainerChildTNode) {\n        appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView);\n        ngContainerChildTNode = ngContainerChildTNode.next;\n      }\n    }\n\n    if (isLContainer(nodeOrContainer)) {\n      nodeOrContainer[RENDER_PARENT] = renderParent;\n      appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\nimport {Type} from '../core';\nimport {Injector} from '../di/injector';\nimport {Sanitizer} from '../sanitization/security';\n\nimport {assertComponentType, assertDefined} from './assert';\nimport {getComponentDef} from './definition';\nimport {diPublicInInjector, getOrCreateNodeInjectorForNode} from './di';\nimport {publishDefaultGlobalUtils} from './global_utils';\nimport {queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {CLEAN_PROMISE, createLView, createNodeAtIndex, createTNode, createTView, getOrCreateTView, initNodeFlags, instantiateRootComponent, locateHostElement, queueComponentIndexForCheck, refreshDescendantViews} from './instructions';\nimport {ComponentDef, ComponentType, RenderFlags} from './interfaces/definition';\nimport {TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {PlayerHandler} from './interfaces/player';\nimport {RElement, Renderer3, RendererFactory3, domRendererFactory3} from './interfaces/renderer';\nimport {CONTEXT, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, LView, LViewFlags, RootContext, RootContextFlags, TVIEW} from './interfaces/view';\nimport {enterView, getPreviousOrParentTNode, leaveView, resetComponentState, setCurrentDirectiveDef} from './state';\nimport {defaultScheduler, getRootView, readPatchedLView, stringify} from './util';\n\n\n\n/** Options that control how the component should be bootstrapped. */\nexport interface CreateComponentOptions {\n  /** Which renderer factory to use. */\n  rendererFactory?: RendererFactory3;\n\n  /** A custom sanitizer instance */\n  sanitizer?: Sanitizer;\n\n  /** A custom animation player handler */\n  playerHandler?: PlayerHandler;\n\n  /**\n   * Host element on which the component will be bootstrapped. If not specified,\n   * the component definition's `tag` is used to query the existing DOM for the\n   * element to bootstrap.\n   */\n  host?: RElement|string;\n\n  /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n  injector?: Injector;\n\n  /**\n   * List of features to be applied to the created component. Features are simply\n   * functions that decorate a component with a certain behavior.\n   *\n   * Typically, the features in this list are features that cannot be added to the\n   * other features list in the component definition because they rely on other factors.\n   *\n   * Example: `RootLifecycleHooks` is a function that adds lifecycle hook capabilities\n   * to root components in a tree-shakable way. It cannot be added to the component\n   * features list because there's no way of knowing when the component will be used as\n   * a root component.\n   */\n  hostFeatures?: HostFeature[];\n\n  /**\n   * A function which is used to schedule change detection work in the future.\n   *\n   * When marking components as dirty, it is necessary to schedule the work of\n   * change detection in the future. This is done to coalesce multiple\n   * {@link markDirty} calls into a single changed detection processing.\n   *\n   * The default value of the scheduler is the `requestAnimationFrame` function.\n   *\n   * It is also useful to override this function for testing purposes.\n   */\n  scheduler?: (work: () => void) => void;\n}\n\n/** See CreateComponentOptions.hostFeatures */\ntype HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\n\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nexport const NULL_INJECTOR: Injector = {\n  get: (token: any, notFoundValue?: any) => {\n    throw new Error('NullInjector: Not found: ' + stringify(token));\n  }\n};\n\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\nexport function renderComponent<T>(\n    componentType: ComponentType<T>|\n        Type<T>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */\n    ,\n    opts: CreateComponentOptions = {}): T {\n  ngDevMode && publishDefaultGlobalUtils();\n  ngDevMode && assertComponentType(componentType);\n  const rendererFactory = opts.rendererFactory || domRendererFactory3;\n  const sanitizer = opts.sanitizer || null;\n  const componentDef = getComponentDef<T>(componentType) !;\n  if (componentDef.type != componentType) componentDef.type = componentType;\n\n  // The first index of the first selector is the tag name.\n  const componentTag = componentDef.selectors ![0] ![0] as string;\n  const hostRNode = locateHostElement(rendererFactory, opts.host || componentTag);\n  const rootFlags = componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                          LViewFlags.CheckAlways | LViewFlags.IsRoot;\n  const rootContext = createRootContext(opts.scheduler, opts.playerHandler);\n\n  const renderer = rendererFactory.createRenderer(hostRNode, componentDef);\n  const rootView: LView = createLView(\n      null, createTView(-1, null, 1, 0, null, null, null), rootContext, rootFlags, rendererFactory,\n      renderer, undefined, opts.injector || null);\n\n  const oldView = enterView(rootView, null);\n  let component: T;\n  try {\n    if (rendererFactory.begin) rendererFactory.begin();\n    const componentView = createRootComponentView(\n        hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\n    component = createRootComponent(\n        componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\n\n    refreshDescendantViews(rootView);  // creation mode pass\n    rootView[FLAGS] &= ~LViewFlags.CreationMode;\n    refreshDescendantViews(rootView);  // update mode pass\n  } finally {\n    leaveView(oldView);\n    if (rendererFactory.end) rendererFactory.end();\n  }\n\n  return component;\n}\n\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param renderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport function createRootComponentView(\n    rNode: RElement | null, def: ComponentDef<any>, rootView: LView,\n    rendererFactory: RendererFactory3, renderer: Renderer3, sanitizer?: Sanitizer | null): LView {\n  resetComponentState();\n  const tView = rootView[TVIEW];\n  const componentView = createLView(\n      rootView,\n      getOrCreateTView(\n          def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery),\n      null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, rendererFactory, renderer,\n      sanitizer);\n  const tNode = createNodeAtIndex(0, TNodeType.Element, rNode, null, null);\n\n  if (tView.firstTemplatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), rootView, def.type);\n    tNode.flags = TNodeFlags.isComponent;\n    initNodeFlags(tNode, rootView.length, 1);\n    queueComponentIndexForCheck(tNode);\n  }\n\n  // Store component view at node index, with node as the HOST\n  componentView[HOST] = rootView[HEADER_OFFSET];\n  componentView[HOST_NODE] = tNode as TElementNode;\n  return rootView[HEADER_OFFSET] = componentView;\n}\n\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport function createRootComponent<T>(\n    componentView: LView, componentDef: ComponentDef<T>, rootView: LView, rootContext: RootContext,\n    hostFeatures: HostFeature[] | null): any {\n  const tView = rootView[TVIEW];\n  // Create directive instance with factory() and store at next index in viewData\n  const component = instantiateRootComponent(tView, rootView, componentDef);\n\n  rootContext.components.push(component);\n  componentView[CONTEXT] = component;\n\n  hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));\n\n  if (tView.firstTemplatePass && componentDef.hostBindings) {\n    const rootTNode = getPreviousOrParentTNode();\n    setCurrentDirectiveDef(componentDef);\n    componentDef.hostBindings(RenderFlags.Create, component, rootTNode.index - HEADER_OFFSET);\n    setCurrentDirectiveDef(null);\n  }\n\n  return component;\n}\n\n\nexport function createRootContext(\n    scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler|null): RootContext {\n  return {\n    components: [],\n    scheduler: scheduler || defaultScheduler,\n    clean: CLEAN_PROMISE,\n    playerHandler: playerHandler || null,\n    flags: RootContextFlags.Empty\n  };\n}\n\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {features: [RootLifecycleHooks]});\n * ```\n */\nexport function LifecycleHooksFeature(component: any, def: ComponentDef<any>): void {\n  const rootTView = readPatchedLView(component) ![TVIEW];\n  const dirIndex = rootTView.data.length - 1;\n\n  queueInitHooks(dirIndex, def.onInit, def.doCheck, rootTView);\n  // TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on\n  // LNode).\n  queueLifecycleHooks(rootTView, { directiveStart: dirIndex, directiveEnd: dirIndex + 1 } as TNode);\n}\n\n/**\n * Retrieve the root context for any component by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param component any component\n */\nfunction getRootContext(component: any): RootContext {\n  const rootContext = getRootView(component)[CONTEXT] as RootContext;\n  ngDevMode && assertDefined(rootContext, 'rootContext');\n  return rootContext;\n}\n\n\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nexport function whenRendered(component: any): Promise<null> {\n  return getRootContext(component).clean;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectInjector} from '../render3/di';\nimport {Type} from '../type';\nimport {stringify} from '../util';\nimport {noop} from '../util/noop';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {InjectFlags, inject} from './injector_compatibility';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if(ngDevMode) debugger;\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  /** @nocollapse */\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => Injector = () => SWITCH_INJECTOR_FACTORY();\n}\n\nexport const SWITCH_INJECTOR_FACTORY__POST_R3__ = function() {\n  return injectInjector();\n};\nconst SWITCH_INJECTOR_FACTORY__PRE_R3__ = noop;\nconst SWITCH_INJECTOR_FACTORY: typeof injectInjector = SWITCH_INJECTOR_FACTORY__PRE_R3__;\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'Éµ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;","import { root } from '../util/root';\n\n/** Symbol.observable addition */\n/* Note: This will add Symbol.observable globally for all TypeScript users,\n  however, we are no longer polyfilling Symbol.observable */\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\n/** Symbol.observable or a string \"@@observable\". Used for interop */\nexport const observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nfunction ObjectUnsubscribedErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'object unsubscribed';\n  this.name = 'ObjectUnsubscribedError';\n  return this;\n}\n\nObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;","export interface EmptyError extends Error {\n}\n\nexport interface EmptyErrorCtor {\n  new(): EmptyError;\n}\n\nfunction EmptyErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'no elements in sequence';\n  this.name = 'EmptyError';\n  return this;\n}\n\nEmptyErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = EmptyErrorImpl as any;","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nexport const Type = Function;\n\nexport function isType(v: any): v is Type<any> {\n  return typeof v === 'function';\n}\n\nexport interface Type<T> extends Function { new (...args: any[]): T; }\n\nexport type Mutable<T extends{[x: string]: any}, K extends string> = {\n  [P in K]: T[P];\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {Type} from '../type';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {inject, injectArgs} from './injector_compatibility';\nimport {ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './provider';\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\nconst EMPTY_ARRAY: any[] = [];\n\nexport function convertInjectableProviderToFactory(\n    type: Type<any>, provider?: ValueSansProvider | ExistingSansProvider | StaticClassSansProvider |\n        ConstructorSansProvider | FactorySansProvider | ClassSansProvider): () => any {\n  if (!provider) {\n    const reflectionCapabilities = new ReflectionCapabilities();\n    const deps = reflectionCapabilities.parameters(type);\n    // TODO - convert to flags.\n    return () => new type(...injectArgs(deps as any[]));\n  }\n\n  if (USE_VALUE in provider) {\n    const valueProvider = (provider as ValueSansProvider);\n    return () => valueProvider.useValue;\n  } else if ((provider as ExistingSansProvider).useExisting) {\n    const existingProvider = (provider as ExistingSansProvider);\n    return () => inject(existingProvider.useExisting);\n  } else if ((provider as FactorySansProvider).useFactory) {\n    const factoryProvider = (provider as FactorySansProvider);\n    return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY));\n  } else if ((provider as StaticClassSansProvider | ClassSansProvider).useClass) {\n    const classProvider = (provider as StaticClassSansProvider | ClassSansProvider);\n    let deps = (provider as StaticClassSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new classProvider.useClass(...injectArgs(deps));\n  } else {\n    let deps = (provider as ConstructorSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new type(...injectArgs(deps !));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../../di/injectable';\nimport {ClassSansProvider, ExistingSansProvider, FactorySansProvider, ValueProvider, ValueSansProvider} from '../../di/provider';\nimport {Type} from '../../type';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {NG_INJECTABLE_DEF} from '../fields';\n\nimport {R3InjectableMetadataFacade, getCompilerFacade} from './compiler_facade';\nimport {angularCoreEnv} from './environment';\nimport {convertDependencies, reflectDependencies} from './util';\n\n\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * `ngInjectableDef` onto the injectable type.\n */\nexport function compileInjectable(type: Type<any>, srcMeta?: Injectable): void {\n  let def: any = null;\n\n  // if NG_INJECTABLE_DEF is already defined on this class then don't overwrite it\n  if (type.hasOwnProperty(NG_INJECTABLE_DEF)) return;\n\n  Object.defineProperty(type, NG_INJECTABLE_DEF, {\n    get: () => {\n      if (def === null) {\n        // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n        const meta: Injectable = srcMeta || {providedIn: null};\n        const hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) ||\n            isUseValueProvider(meta) || isUseExistingProvider(meta);\n\n\n        const compilerMeta: R3InjectableMetadataFacade = {\n          name: type.name,\n          type: type,\n          typeArgumentCount: 0,\n          providedIn: meta.providedIn,\n          ctorDeps: reflectDependencies(type),\n          userDeps: undefined\n        };\n        if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n          compilerMeta.userDeps = convertDependencies(meta.deps);\n        }\n        if (!hasAProvider) {\n          // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.\n          // The deps will have been reflected above, causing the factory to create the class by\n          // calling\n          // its constructor with injected deps.\n          compilerMeta.useClass = type;\n        } else if (isUseClassProvider(meta)) {\n          // The user explicitly specified useClass, and may or may not have provided deps.\n          compilerMeta.useClass = meta.useClass;\n        } else if (isUseValueProvider(meta)) {\n          // The user explicitly specified useValue.\n          compilerMeta.useValue = meta.useValue;\n        } else if (isUseFactoryProvider(meta)) {\n          // The user explicitly specified useFactory.\n          compilerMeta.useFactory = meta.useFactory;\n        } else if (isUseExistingProvider(meta)) {\n          // The user explicitly specified useExisting.\n          compilerMeta.useExisting = meta.useExisting;\n        } else {\n          // Can't happen - either hasAProvider will be false, or one of the providers will be set.\n          throw new Error(`Unreachable state.`);\n        }\n        def = getCompilerFacade().compileInjectable(\n            angularCoreEnv, `ng://${type.name}/ngInjectableDef.js`, compilerMeta);\n      }\n      return def;\n    },\n  });\n}\n\ntype UseClassProvider = Injectable & ClassSansProvider & {deps?: any[]};\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\nfunction isUseClassProvider(meta: Injectable): meta is UseClassProvider {\n  return (meta as UseClassProvider).useClass !== undefined;\n}\n\nfunction isUseValueProvider(meta: Injectable): meta is Injectable&ValueSansProvider {\n  return USE_VALUE in meta;\n}\n\nfunction isUseFactoryProvider(meta: Injectable): meta is Injectable&FactorySansProvider {\n  return (meta as FactorySansProvider).useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta: Injectable): meta is Injectable&ExistingSansProvider {\n  return (meta as ExistingSansProvider).useExisting !== undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {NgModuleDef} from '../metadata/ng_module';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {Mutable, Type} from '../type';\nimport {noSideEffects, stringify} from '../util';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from './empty';\nimport {NG_COMPONENT_DEF, NG_DIRECTIVE_DEF, NG_MODULE_DEF, NG_PIPE_DEF} from './fields';\nimport {BaseDef, ComponentDef, ComponentDefFeature, ComponentQuery, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFeature, DirectiveType, DirectiveTypesOrFactory, HostBindingsFunction, PipeDef, PipeType, PipeTypesOrFactory} from './interfaces/definition';\nimport {CssSelectorList} from './interfaces/projection';\n\nlet _renderCompCount = 0;\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ngComponentDef = defineComponent({\n *     ...\n *   });\n * }\n * ```\n */\nexport function defineComponent<T>(componentDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this component. */\n  selectors: CssSelectorList;\n\n  /**\n   * Factory method used to create an instance of directive.\n   */\n  factory: (t: Type<T>| null) => T;\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  consts: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  vars: number;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  attributes?: string[];\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['public', 'declared']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ((dirIndex: number) => void);\n\n  /** Refreshes content queries associated with directives in a given view */\n  contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string;\n\n  /**\n   * Template function use for rendering DOM.\n   *\n   * This function has following structure.\n   *\n   * ```\n   * function Template<T>(ctx:T, creationMode: boolean) {\n   *   if (creationMode) {\n   *     // Contains creation mode instructions.\n   *   }\n   *   // Contains binding update instructions\n   * }\n   * ```\n   *\n   * Common instructions are:\n   * Creation mode instructions:\n   *  - `elementStart`, `elementEnd`\n   *  - `text`\n   *  - `container`\n   *  - `listener`\n   *\n   * Binding update instructions:\n   * - `bind`\n   * - `elementAttribute`\n   * - `elementProperty`\n   * - `elementClass`\n   * - `elementStyle`\n   *\n   */\n  template: ComponentTemplate<T>;\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instruction to be inserted into the template function.\n   *\n   * Query-related instructions need to be pulled out to a specific function as a timing of\n   * execution is different as compared to all other instructions (after change detection hooks but\n   * before view hooks).\n   */\n  viewQuery?: ComponentQuery<T>| null;\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n   */\n  features?: ComponentDefFeature[];\n\n  /**\n   * Defines template and style encapsulation options available for Component's {@link Component}.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   *\n   * see: animation\n   */\n  data?: {[kind: string]: any};\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  styles?: string[];\n\n  /**\n   * The strategy that the default change detector uses to detect changes.\n   * When set, takes effect the next time change detection is triggered.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Registry of directives and components that may be found in this component's view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directives?: DirectiveTypesOrFactory | null;\n\n  /**\n   * Registry of pipes that may be found in this component's view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipes?: PipeTypesOrFactory | null;\n}): never {\n  const type = componentDefinition.type;\n  const typePrototype = type.prototype;\n  const declaredInputs: {[key: string]: string} = {} as any;\n  const def: Mutable<ComponentDef<any>, keyof ComponentDef<any>> = {\n    type: type,\n    providersResolver: null,\n    consts: componentDefinition.consts,\n    vars: componentDefinition.vars,\n    factory: componentDefinition.factory,\n    template: componentDefinition.template || null !,\n    hostBindings: componentDefinition.hostBindings || null,\n    contentQueries: componentDefinition.contentQueries || null,\n    contentQueriesRefresh: componentDefinition.contentQueriesRefresh || null,\n    attributes: componentDefinition.attributes || null,\n    declaredInputs: declaredInputs,\n    inputs: null !,   // assigned in noSideEffects\n    outputs: null !,  // assigned in noSideEffects\n    exportAs: componentDefinition.exportAs || null,\n    onInit: typePrototype.ngOnInit || null,\n    doCheck: typePrototype.ngDoCheck || null,\n    afterContentInit: typePrototype.ngAfterContentInit || null,\n    afterContentChecked: typePrototype.ngAfterContentChecked || null,\n    afterViewInit: typePrototype.ngAfterViewInit || null,\n    afterViewChecked: typePrototype.ngAfterViewChecked || null,\n    onDestroy: typePrototype.ngOnDestroy || null,\n    onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n    directiveDefs: null !,  // assigned in noSideEffects\n    pipeDefs: null !,       // assigned in noSideEffects\n    selectors: componentDefinition.selectors,\n    viewQuery: componentDefinition.viewQuery || null,\n    features: componentDefinition.features || null,\n    data: componentDefinition.data || {},\n    // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the\n    // next line. Also `None` should be 0 not 2.\n    encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n    id: 'c',\n    styles: componentDefinition.styles || EMPTY_ARRAY,\n    _: null as never,\n  };\n  def._ = noSideEffects(() => {\n    const directiveTypes = componentDefinition.directives !;\n    const feature = componentDefinition.features;\n    const pipeTypes = componentDefinition.pipes !;\n    def.id += _renderCompCount++;\n    def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n    def.outputs = invertObject(componentDefinition.outputs),\n    feature && feature.forEach((fn) => fn(def));\n    def.directiveDefs = directiveTypes ?\n        () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\n                  .map(extractDirectiveDef) :\n        null;\n    def.pipeDefs = pipeTypes ?\n        () => (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) :\n        null;\n  }) as never;\n  return def as never;\n}\n\nexport function extractDirectiveDef(type: DirectiveType<any>& ComponentType<any>):\n    DirectiveDef<any>|ComponentDef<any> {\n  const def = getComponentDef(type) || getDirectiveDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);\n  }\n  return def !;\n}\n\nexport function extractPipeDef(type: PipeType<any>): PipeDef<any> {\n  const def = getPipeDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is not a 'PipeType'.`);\n  }\n  return def !;\n}\n\nexport function defineNgModule<T>(def: {type: T} & Partial<NgModuleDef<T>>): never {\n  const res: NgModuleDef<T> = {\n    type: def.type,\n    bootstrap: def.bootstrap || EMPTY_ARRAY,\n    declarations: def.declarations || EMPTY_ARRAY,\n    imports: def.imports || EMPTY_ARRAY,\n    exports: def.exports || EMPTY_ARRAY,\n    transitiveCompileScopes: null,\n  };\n  return res as never;\n}\n\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj: any, secondary?: any): any {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup: any = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName: string = obj[minifiedKey];\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        (secondary[publicName] = declaredName);\n      }\n    }\n  }\n  return newLookup;\n}\n\n/**\n * Create a base definition\n *\n * # Example\n * ```\n * class ShouldBeInherited {\n *   static ngBaseDef = defineBase({\n *      ...\n *   })\n * }\n * @param baseDefinition The base definition parameters\n */\nexport function defineBase<T>(baseDefinition: {\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: [ 'declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['declared', 'public']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `outputs`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n}): BaseDef<T> {\n  const declaredInputs: {[P in keyof T]: P} = {} as any;\n  return {\n    inputs: invertObject(baseDefinition.inputs, declaredInputs),\n    declaredInputs: declaredInputs,\n    outputs: invertObject(baseDefinition.outputs),\n  };\n}\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ngDirectiveDef = defineDirective({\n *     ...\n *   });\n * }\n * ```\n */\nexport const defineDirective = defineComponent as any as<T>(directiveDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  selectors: CssSelectorList;\n\n  /**\n   * Factory method used to create an instance of directive.\n   */\n  factory: (t: Type<T>| null) => T;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  attributes?: string[];\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['declared', 'public']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n   */\n  features?: DirectiveDefFeature[];\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ((directiveIndex: number) => void);\n\n  /** Refreshes content queries associated with directives in a given view */\n  contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string;\n}) => never;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ngPipeDef = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n */\nexport function definePipe<T>(pipeDef: {\n  /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n  name: string,\n\n  /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n  type: Type<T>,\n\n  /** A factory for creating a pipe instance. */\n  factory: (t: Type<T>| null) => T,\n\n  /** Whether the pipe is pure. */\n  pure?: boolean\n}): never {\n  return (<PipeDef<T>>{\n    name: pipeDef.name,\n    factory: pipeDef.factory,\n    pure: pipeDef.pure !== false,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  }) as never;\n}\n\n/**\n * The following getter methods retrieve the definition form the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T>|null {\n  return (type as any)[NG_COMPONENT_DEF] || null;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T>|null {\n  return (type as any)[NG_DIRECTIVE_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T>|null {\n  return (type as any)[NG_PIPE_DEF] || null;\n}\n\nexport function getNgModuleDef<T>(type: any, throwNotFound: true): NgModuleDef<T>;\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T>|null;\nexport function getNgModuleDef<T>(type: any, throwNotFound?: boolean): NgModuleDef<T>|null {\n  const ngModuleDef = (type as any)[NG_MODULE_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ngModuleDef' property.`);\n  }\n  return ngModuleDef;\n}\n","import { Component, ÉµrenderComponent as renderComponent } from '@angular/core';\n\n@Component({ selector: 'hello-world', template: 'Hello World!' })\nclass HelloWorld { }\n\nrenderComponent(HelloWorld);\n"]}