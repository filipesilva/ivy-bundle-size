{"version":3,"sources":["../../../../../../../../../external/npm/node_modules/tslib/tslib.es6.js","../../../../../../../external/angular/packages/core/src/util/property.ts","../../../../../../../external/angular/packages/core/src/render3/fields.ts","../../../../../../../external/angular/packages/core/src/di/defs.ts","../../../../../../../external/angular/packages/core/src/di/injection_token.ts","../../../../../../../external/angular/packages/core/src/util/decorators.ts","../../../../../../../external/angular/packages/core/src/metadata/di.ts","../../../../../../../external/angular/packages/core/src/change_detection/constants.ts","../../../../../../../external/angular/packages/core/src/util.ts","../../../../../../../external/angular/packages/core/src/di/forward_ref.ts","../../../../../../../external/angular/packages/core/src/metadata/view.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/injector.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/container.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/context.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/view.ts","../../../../../../../external/angular/packages/core/src/render3/util.ts","../../../../../../../external/angular/packages/core/src/render3/jit/compiler_facade_interface.ts","../../../../../../../external/angular/packages/core/src/di/injector_compatibility.ts","../../../../../../../external/angular/packages/core/src/render3/state.ts","../../../../../../../external/angular/packages/core/src/di/metadata.ts","../../../../../../../external/angular/packages/core/src/render3/hooks.ts","../../../../../../../external/angular/packages/core/src/render3/di.ts","../../../../../../../external/angular/packages/core/src/render3/context_discovery.ts","../../../../../../../external/angular/packages/core/src/util/ng_reflect.ts","../../../../../../../external/angular/packages/core/src/change_detection/change_detection_util.ts","../../../../../../../external/angular/packages/core/src/render3/tokens.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/renderer.ts","../../../../../../../external/angular/packages/core/src/render3/node_manipulation.ts","../../../../../../../external/angular/packages/core/src/render3/styling/util.ts","../../../../../../../external/angular/packages/core/src/render3/instructions.ts","../../../../../../../external/angular/packages/core/src/render3/component.ts","../../../../../../../external/angular/packages/core/src/util/noop.ts","../../../../../../../external/angular/packages/core/src/di/injector.ts","../../../../../../../external/angular/packages/core/src/di/scope.ts","../../../../../../../external/angular/packages/core/src/linker/component_factory.ts","../../../../../../../external/angular/packages/core/src/linker/component_factory_resolver.ts","../../../../../../../external/angular/packages/core/src/render3/view_engine_compatibility.ts","../../../../../../../external/angular/packages/core/src/version.ts","../../../../../../../external/angular/packages/core/src/linker/ng_module_factory.ts","../../../../../../../external/angular/packages/core/src/render3/view_ref.ts","../../../../../../../external/angular/packages/core/src/linker/element_ref.ts","../../../../../../../external/angular/packages/core/src/render/api.ts","../../../../../../../external/angular/packages/core/src/sanitization/security.ts","../../../../../../../external/angular/packages/core/src/render3/component_ref.ts","../../../../../../../external/angular/packages/core/src/render3/definition.ts","../../../../../../../external/angular/packages/core/src/render3/interfaces/projection.ts","../../../../../../../external/angular/packages/core/src/is_dev_mode.ts","../../../../../../../external/angular/packages/core/src/sanitization/html_sanitizer.ts","../../../../../external/rxjs/internal/util/isFunction.ts","../../../../../external/rxjs/internal/config.ts","../../../../../external/rxjs/internal/util/hostReportError.ts","../../../../../external/rxjs/internal/Observer.ts","../../../../../external/rxjs/internal/util/isArray.ts","../../../../../external/rxjs/internal/util/isObject.ts","../../../../../external/rxjs/internal/util/errorObject.ts","../../../../../external/rxjs/internal/util/tryCatch.ts","../../../../../external/rxjs/internal/util/UnsubscriptionError.ts","../../../../../external/rxjs/internal/Subscription.ts","../../../../../external/rxjs/internal/symbol/rxSubscriber.ts","../../../../../external/rxjs/internal/Subscriber.ts","../../../../../external/rxjs/internal/symbol/observable.ts","../../../../../external/rxjs/internal/util/noop.ts","../../../../../external/rxjs/internal/Observable.ts","../../../../../external/rxjs/internal/util/toSubscriber.ts","../../../../../external/rxjs/internal/util/canReportError.ts","../../../../../external/rxjs/internal/util/pipe.ts","../../../../../external/rxjs/internal/util/ObjectUnsubscribedError.ts","../../../../../external/rxjs/internal/SubjectSubscription.ts","../../../../../external/rxjs/internal/Subject.ts","../../../../../external/rxjs/internal/operators/refCount.ts","../../../../../external/rxjs/internal/observable/ConnectableObservable.ts","../../../../../external/rxjs/internal/util/subscribeToArray.ts","../../../../../external/rxjs/internal/observable/fromArray.ts","../../../../../external/rxjs/internal/util/identity.ts","../../../../../external/rxjs/internal/util/EmptyError.ts","../../../../../external/rxjs/internal/operators/map.ts","../../../../../external/rxjs/internal/OuterSubscriber.ts","../../../../../external/rxjs/internal/InnerSubscriber.ts","../../../../../external/rxjs/internal/util/subscribeToPromise.ts","../../../../../external/rxjs/internal/symbol/iterator.ts","../../../../../external/rxjs/internal/util/subscribeToIterable.ts","../../../../../external/rxjs/internal/util/subscribeToObservable.ts","../../../../../external/rxjs/internal/util/isArrayLike.ts","../../../../../external/rxjs/internal/util/isPromise.ts","../../../../../external/rxjs/internal/util/subscribeTo.ts","../../../../../external/rxjs/internal/operators/mergeMap.ts","../../../../../external/rxjs/internal/util/subscribeToResult.ts","../../../../../../../external/angular/packages/core/src/event_emitter.ts","../../../../../../../external/angular/packages/core/src/linker/template_ref.ts","../../../../../../../external/angular/packages/core/src/type.ts","../../../../../../../external/angular/packages/core/src/sanitization/style_sanitizer.ts","../../../../../../../external/angular/packages/core/src/reflection/reflection_capabilities.ts","../../../../../../../external/angular/packages/core/src/metadata/directives.ts","../../../../../../../external/angular/packages/core/src/di/util.ts","../../../../../../../external/angular/packages/core/src/metadata/ng_module.ts","../../../../../../../external/angular/packages/core/src/di/injectable.ts","../../../../../../../external/angular/packages/core/src/render3/jit/injectable.ts","../../../../../../../external/angular/packages/core/src/errors.ts","../../../../../../../external/angular/packages/core/src/error_handler.ts","../../../../../../../external/angular/packages/core/src/di/reflective_key.ts","../../../../../../../external/angular/packages/core/src/reflection/reflection.ts","../../../../../../../external/angular/packages/core/src/reflection/reflector.ts","../../../../../../../external/angular/packages/core/src/di/reflective_injector.ts","../../../../../external/rxjs/internal/operators/multicast.ts","../../../../../external/rxjs/internal/operators/share.ts","../../../../../../../external/angular/packages/core/src/util/lang.ts","../../../../../../../external/angular/packages/core/src/application_init.ts","../../../../../../../external/angular/packages/core/src/application_tokens.ts","../../../../../../../external/angular/packages/core/src/console.ts","../../../../../../../external/angular/packages/core/src/linker/compiler.ts","../../../../../../../external/angular/packages/core/src/profile/wtf_impl.ts","../../../../../../../external/angular/packages/core/src/profile/profile.ts","../../../../../../../external/angular/packages/core/src/zone/ng_zone.ts","../../../../../../../external/angular/packages/core/src/application_ref.ts","../../../../../../../external/angular/packages/core/src/testability/testability.ts","../../../../../external/rxjs/internal/observable/merge.ts","../../../../../external/rxjs/internal/util/isScheduler.ts","../../../../../external/rxjs/internal/operators/mergeAll.ts","../../../../../external/rxjs/internal/observable/from.ts","../../../../../external/rxjs/internal/util/isInteropObservable.ts","../../../../../external/rxjs/internal/observable/fromObservable.ts","../../../../../external/rxjs/internal/observable/fromPromise.ts","../../../../../external/rxjs/internal/util/isIterable.ts","../../../../../external/rxjs/internal/observable/fromIterable.ts","../../../../../../../external/angular/packages/core/src/linker/query_list.ts","../../../../../../../external/angular/packages/core/src/linker/view_container_ref.ts","../../../../../../../external/angular/packages/core/src/change_detection/change_detector_ref.ts","../../../../../../../external/angular/packages/core/src/debug/debug_node.ts","../../../../../../../external/angular/packages/core/src/change_detection/differs/default_iterable_differ.ts","../../../../../../../external/angular/packages/core/src/change_detection/differs/default_keyvalue_differ.ts","../../../../../../../external/angular/packages/core/src/change_detection/differs/iterable_differs.ts","../../../../../../../external/angular/packages/core/src/change_detection/differs/keyvalue_differs.ts","../../../../../../../external/angular/packages/core/src/change_detection/change_detection.ts","../../../../../../../external/angular/packages/core/src/platform_core_providers.ts","../../../../../../../external/angular/packages/core/src/i18n/tokens.ts","../../../../../../../external/angular/packages/core/src/application_module.ts","../../../../../../../external/angular/packages/core/src/view/types.ts","../../../../../../../external/angular/packages/core/src/view/errors.ts","../../../../../../../external/angular/packages/core/src/view/util.ts","../../../../../../../external/angular/packages/core/src/view/element.ts","../../../../../../../external/angular/packages/core/src/view/ng_module.ts","../../../../../../../external/angular/packages/core/src/view/view_attach.ts","../../../../../../../external/angular/packages/core/src/view/refs.ts","../../../../../../../external/angular/packages/core/src/view/provider.ts","../../../../../../../external/angular/packages/core/src/view/query.ts","../../../../../../../external/angular/packages/core/src/view/ng_content.ts","../../../../../../../external/angular/packages/core/src/view/text.ts","../../../../../../../external/angular/packages/core/src/view/view.ts","../../../../../../../external/angular/packages/core/src/view/pure_expression.ts","../../../../../../../external/angular/packages/core/src/view/services.ts","../../../../../../../external/angular/packages/core/src/view/entrypoint.ts","../../../../../../../external/angular/packages/common/src/location/platform_location.ts","../../../../../../../external/angular/packages/common/src/pipes/deprecated/intl.ts","../../../../../../../external/angular/packages/common/src/location/location_strategy.ts","../../../../../../../external/angular/packages/common/src/i18n/localization.ts","../../../../../../../external/angular/packages/common/src/pipes/deprecated/number_pipe.ts","../../../../../../../external/angular/packages/common/src/pipes/async_pipe.ts","../../../../../../../external/angular/packages/common/src/pipes/slice_pipe.ts","../../../../../../../external/angular/packages/common/src/dom_tokens.ts","../../../../../../../external/angular/packages/common/src/version.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/dom_adapter.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/browser_adapter.ts","../../../../../../../external/angular/packages/common/src/cookie.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/generic_browser_adapter.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/dom_tokens.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/location/history.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/location/browser_platform_location.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/server-transition.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/testability.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/debug/ng_probe.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/events/event_manager.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/dom_renderer.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/events/dom_events.ts","../../../../../../../external/angular/packages/platform-browser/src/dom/events/hammer_gestures.ts","../../../../../../../external/angular/packages/platform-browser/src/browser.ts","../../../../../../../external/angular/packages/common/src/platform_id.ts","../../../../../../../external/angular/packages/platform-browser/src/version.ts","../../../../../../../external/angular/packages/platform-browser/src/browser/title.ts","../../../../src/app.module.ts","../../../../src/app.module.ts.AppComponent.html","../../../../src/main.ngc.ts"],"names":["extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","next","value","done","__read","e","ar","push","error","__spread","concat","getClosureSafeProperty","objWithPropertyToExtract","Error","fillProperties","source","NG_COMPONENT_DEF","ngComponentDef","NG_INJECTABLE_DEF","ngDirectiveDef","ngInjectableDef","NG_BASE_DEF","ngInjectorDef","ngPipeDef","ngModuleDef","ngBaseDef","NG_ELEMENT_ID","__NG_ELEMENT_ID__","defineInjectable","opts","providedIn","factory","undefined","getInjectableDef","type","InjectionToken","_desc","options","ngMetadataName","toString","ANNOTATIONS","PARAMETERS","PROP_METADATA","makeDecorator","name","props","parentClass","additionalProcessing","typeFn","metaCtor","makeMetadataCtor","DecoratorFactory","args","_i","apply","annotationInstance","_a","bind","TypeDecorator","cls","annotationCls","ctor","values","propName","makeParamDecorator","ParamDecoratorFactory","ParamDecorator","annotation","unusedKey","index","parameters","makePropDecorator","PropDecoratorFactory","decoratorInstance","PropDecorator","meta","unshift","attributeName","Query","ChangeDetectionStrategy","selector","data","first","isViewQuery","descendants","__window","window","__self","self","WorkerGlobalScope","_global","global","promise","Promise","resolve","_symbolIterator","getSymbolIterator","Symbol_1","keys","getOwnPropertyNames","Map","scheduleMicroTask","fn","Zone","then","current","looseIdentical","a","isNaN","stringify","token","map","join","overriddenName","res","newLineIndex","indexOf","substring","__forward_ref__","forwardRef","forwardRefFn","resolveForwardRef","NodeInjectorFactory","ViewEncapsulation","ACTIVE_INDEX","VIEWS","MONKEY_PATCH_KEY_NAME","TNODE","PARENT_INJECTOR","INJECTOR_BLOOM_PARENT_SIZE","NO_PARENT_INJECTOR","FactoryPrototype","isViewProvider","injectImplementation","resolving","canSeeViewProviders","injectImpl","TVIEW","FLAGS","PARENT","NEXT","HOST","HOST_NODE","BINDING_INDEX","CLEANUP","CONTEXT","INJECTOR","RENDERER_FACTORY","RENDERER","SANITIZER","CONTAINER_INDEX","DECLARATION_VIEW","HEADER_OFFSET","stringify$1","readElementValue","isArray","getNativeByTNode","tNode","hostView","getComponentViewByIndex","nodeIndex","slotValue","isComponentDef","def","template","readPatchedData","readPatchedLView","lView","getParentInjectorIndex","parentLocation","getParentInjectorView","location","startView","viewOffset","getParentInjectorViewOffset","parentView","defaultScheduler","requestAnimationFrame","setTimeout","findComponentView","rootTNode","_injectImplementation","previousOrParentTNode","isParent","Inject","Optional","Self","SkipSelf","InjectFlags","_currentInjector","setCurrentInjector","injector","former","setInjectImplementation","impl","previous","inject","flags","Default","injectInjectorOnly","injectRootLimpMode","get","notFoundValue","injectableDef","injectArgs","types","arg","j","queueContentHooks","tView","afterContentInit","contentHooks","afterContentChecked","contentCheckHooks","queueViewHooks","afterViewInit","viewHooks","afterViewChecked","viewCheckHooks","queueDestroyHooks","onDestroy","destroyHooks","executeHooks","currentView","allHooks","checkHooks","checkNoChangesMode","hooksToCall","callHooks","arr","getLView","getPreviousOrParentTNode","setPreviousOrParentTNode","setTNodeAndViewData","view","getIsParent","setIsParent","isCreationMode","getCheckNoChangesMode","setCheckNoChangesMode","mode","firstTemplatePass","getFirstTemplatePass","setFirstTemplatePass","enterView","newView","hostTNode","oldView","leaveView","bindingStartIndex","includeViewProviders","setIncludeViewProviders","v","oldValue","BLOOM_MASK","BLOOM_SIZE","nextNgElementId","insertBloom","footer","getInjectorIndex","injectorIndex","parent","getParentInjectorLocation","NOT_FOUND","searchTokensOnInjector","previousTView","hostTElementNode","currentTView","injectableIdx","locateDirectiveOrProvider","canAccessViewProviders","isHostSpecialCase","nodeProviderIndexes","providerIndexes","tInjectables","injectablesStart","directivesStart","directiveStart","cptViewProvidersCount","endIndex","directiveEnd","providerTokenOrDef","dirDef","isComponent","Host","getNodeInjectable","tData","lData","isFactory","obj","getPrototypeOf","previousIncludeViewProviders","previousInjectImplementation","savePreviousOrParentTNode","saveLView","bloomHasToken","bloomHash","injectorView","b6","b5","shouldSearchParent","isFirstHostTNode","NodeInjector","_tNode","_lView","getOrCreateInjectable","bloomHashBitOrFactory","charCodeAt","tokenId","instance","moduleInjector","attachPatchData","CAMEL_CASE_REGEXP","normalizeDebugBindingValue","slice","devModeEqual","isListLikeIterableA","isListLikeIterable","isListLikeIterableB","areIterablesEqual","comparator","iterator1","iterator2","item1","item2","WrappedValue","wrapped","wrap","unwrap","isWrapped","SimpleChange","previousValue","currentValue","firstChange","isFirstChange","isJsObject","NO_CHANGE","isProceduralRenderer","renderer","domRendererFactory3","createRenderer","hostElement","rendererType","document","projectionNodeStack","executeNodeAction","action","node","beforeNode","insertBefore","removeChild","destroyNode","getLViewChild","childIndex","getParentState","state","rootView","getLContainer","embeddedView","containerHostIndex","cleanUpView","viewOrContainer","executeOnDestroys","executePipeOnDestroys","pipeDestroyHooks","removeListeners","tCleanup","cleanup","lCleanup","listener","native","useCaptureOrSubIdx","removeEventListener","unsubscribe","cleanupFn","destroy","_CLEAN_PROMISE","refreshDescendantViews","executeInitHooks","initHooks","refreshDynamicEmbeddedViews","container_1","dynamicViewData","renderEmbeddedTemplate","refreshContentQueries","contentQueries","directiveDefIdx","contentQueriesRefresh","setHostBindings","viewData","expandoInstructions","bindingRootIndex","expandoStartIndex","currentDirectiveIndex","currentElementIndex","instruction","providerCount","refreshChildComponents","components","viewAttached","syncViewWithBlueprint","componentView","componentTView","blueprint","checkView","createLView","parentLView","context","rendererFactory","sanitizer","createNodeAtIndex","attrs","adjustedIndex","createTNode","child","firstChild","viewToRender","_isParent","_previousOrParentTNode","tickRootContext","getRootContext","viewOrComponent","getRootView","namespaceHTML","getRenderFlags","renderComponentOrTemplate","templateFn","normalExecutionPath","begin","end","_currentNamespace","createTView","viewIndex","consts","vars","directives","pipes","viewQuery","initialViewLength","createViewBlueprint","fill","id","directiveRegistry","pipeRegistry","tagName","tViews","tParent","localNames","initialInputs","inputs","outputs","detached","stylingTemplate","projection","rootContext","rootComponent","detectChangesInternal","detectChangesInRootView","component","hostTView","createViewQuery","updateViewQuery","CLEAN_PROMISE","createRootContext","scheduler","playerHandler","clean","LifecycleHooksFeature","rootTView","dirIndex","queueInitHooks","onInit","doCheck","queueLifecycleHooks","noop","SOURCE","_THROW_IF_NOT_FOUND","NullInjector","Injector","StaticInjector","providers","THROW_IF_NOT_FOUND","NULL","SWITCH_INJECTOR_FACTORY","IDENT","EMPTY","CIRCULAR","MULTI_PROVIDER_FN","USE_VALUE","provide","String","useValue","NULL_INJECTOR","NEW_LINE","NO_NEW_LINE","NULL_INJECTOR$1","records","_records","set","deps","useNew","recursivelyProcessProviders","provider","staticError","resolvedProvider","resolveProvider","computeDeps","providerDeps","annotations","useExisting","useFactory","useClass","multi","multiProvider","multiProviderMixError","record","tryResolveToken","resolveToken","depRecords","depRecord","childRecord","tokenPath","message","formatError","tokens","forEach","text","charAt","substr","parts","JSON","replace","APP_ROOT","ComponentRef","ComponentFactory","ERROR_COMPONENT","R3ElementRef","Version","_NullComponentFactoryResolver","resolveComponentFactory","noComponentFactoryError","ComponentFactoryResolver","CodegenComponentFactoryResolver","factories","_parent","_ngModule","_factories","componentType","ComponentFactoryBoundToModule","_super","ngModule","_this","ngContentSelectors","tslib_1.__extends","projectableNodes","rootSelectorOrNode","NgModuleRef","NgModuleFactory","RootViewRef","_view","detectChanges","checkNoChanges","checkNoChangesInRootView","ViewRef","_context","_componentIndex","_appRef","_viewContainerRef","_tViewNode","collectNativeNodes","parentTNode","result","tNodeChild","_lookUpContext","detachView","detach","destroyLView","walkTNodeTree","viewToWalk","renderParent","projectionNodeIndex","nextTNode","nodeOrContainer","lContainer","head","destroyViewTree","callback","storeCleanupFn","getCleanup","getTViewCleanup","markForCheck","markViewDirty","scheduleTick","res_1","nothingScheduled","flushPlayers","reattach","getComponentViewByInstance","componentInstance","findViaComponent","componentIndices","elementComponentIndex","createLContext","localRefs","attachToViewContainerRef","vcRef","detachFromAppRef","attachToAppRef","appRef","ElementRef","nativeElement","SWITCH_ELEMENT_REF_FACTORY","Renderer","RendererFactory2","Renderer2","SWITCH_RENDERER2_FACTORY","SecurityContext","Sanitizer","VERSION","full","major","split","minor","patch","ComponentFactoryResolver$1","ComponentFactoryResolver$$1","componentDef","getComponentDef","viewEngine_ComponentFactoryResolver","toRefArray","array","nonMinified","templateName","ROOT_CONTEXT","SCHEDULER","NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR","ComponentFactory$1","ComponentFactory$$1","selectors","isInternalRootView","rootViewInjector","createChainedInjector","hostRNode","elementCreate","overriddenRenderer","rendererToUse","createElement","createElementNS","locateHostElement","elementOrSelector","defaultRenderer","selectRootElement","querySelector","rootFlags","onPush","setAttribute","tElementNode","rootLView","oldLView","createRootComponentView","rNode","resetComponentState","getOrCreateTView","ngPrivateData","directiveDefs","pipeDefs","diPublicInInjector","bloomAdd","bloomBit","mask","getOrCreateNodeInjectorForNode","existingInjectorIndex","parentLoc","parentIndex","hasParentInjector","parentData","initNodeFlags","numberOfDirectives","queueComponentIndexForCheck","getTNode","nodeList","firstTNode","previousTNode","splice","createRootComponent","hostFeatures","instantiateRootComponent","providersResolver","generateExpandoInstructionBlock","directiveCount","elementIndex","baseResolveDirective","directiveFactory","nodeInjectorFactory","directive","postProcessBaseDirective","attributes","setUpAttributes","isProc","attrName","namespaceURI","attrName_1","attrVal","setAttributeNS","setProperty","feature","hostBindings","addToViewTree","adjustedHostIndex","componentRef","createElementRef","ElementRefToken","ElementRef_","viewEngine_ElementRef","viewEngine_ComponentFactory","ComponentRef$1","ComponentRef$$1","_rootLView","destroyCbs","changeDetectorRef","createViewNode","viewEngine_ComponentRef","_devMode","_runModeLocked","isDevMode","tagSet","tags","_b","tslib_1.__values","_c","merge","sets","sets_1","sets_1_1","VOID_ELEMENTS","OPTIONAL_END_TAG_BLOCK_ELEMENTS","OPTIONAL_END_TAG_INLINE_ELEMENTS","OPTIONAL_END_TAG_ELEMENTS","isFunction","x","_enable_super_gross_mode_that_will_cause_bad_things","config","useDeprecatedSynchronousErrorHandling","hostReportError","err","empty","closed","complete","isObject","tryCatchTarget","errorObject","tryCatcher","tryCatch","UnsubscriptionErrorImpl","errors","UnsubscriptionError","Subscription","_parents","_subscriptions","_unsubscribe","hasErrors","len","remove","flattenUnsubscriptionErrors","sub","add","teardown","subscription","_addParent","tmp","subscriptions","subscriptionIndex","reduce","errs","rxSubscriber","Math","random","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","_parentSubscription","destination","emptyObserver","SafeSubscriber","rxSubscriberSymbol","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","__tryOrSetError","__tryOrUnsub","wrappedComplete","observable","noop$1","Observable","subscribe","_isScalar","_subscribe","lift","operator","sink","toSubscriber","nextOrObserver","_trySubscribe","canReportError","observer","console","warn","promiseCtor","getPromiseCtor","reject","Symbol_observable","pipe","operations","pipeFromArray","fns","piped","input","prev","toPromise","ObjectUnsubscribedErrorImpl","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","thrownError","AnonymousSubject","copy","asObservable","refCount","refCountOperatorFunction","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","connection","connect","sharedConnection","_connection","connectableProto","ConnectableObservable","subjectFactory","_isComplete","getSubject","_subject","ConnectableSubscriber","higherOrderRefCount","connectableObservableDescriptor","writable","subscribeToArray","fromArray","schedule","identity","MapOperator","project","thisArg","MapSubscriber","count","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","InnerSubscriber","subscribeToPromise","getSymbolIterator$1","subscribeToIterable","iterable","Symbol_iterator","item","return","subscribeToObservable","obs","TypeError","isArrayLike","isPromise","subscribeTo","MergeMapOperator","concurrent","Number","POSITIVE_INFINITY","MergeMapSubscriber","hasCompleted","buffer","active","_tryNext","_innerSub","ish","innerSubscriber","subscribeToResult","outerSubscriber","shift","EventEmitter","isAsync","__isAsync","emit","generatorOrNext","schedulerFn","errorFn","completeFn","TemplateRef","SWITCH_TEMPLATE_REF_FACTORY","Type","RegExp","Function","isType","DELEGATE_CTOR","INHERITED_CLASS","INHERITED_CLASS_WITH_CTOR","ReflectionCapabilities","reflect","_reflect","isReflectionEnabled","_zipTypesAndAnnotations","paramTypes","paramAnnotations","_ownParameters","parentCtor","typeStr","exec","tsickleCtorParams","ctorParameters","paramTypes_1","ctorParam","paramAnnotations_1","convertTsickleDecoratorIntoMetadata","getOwnMetadata","getParentCtor","_ownAnnotations","typeOrFunc","ownAnnotations","_ownPropMetadata","propMetadata","propDecorators","propDecorators_1","propMetadata_1","prop","parentPropMetadata_1","ownPropMetadata","hasLifecycleHook","lcProperty","guards","getter","setter","method","importUri","resourceUri","resolveIdentifier","moduleUrl","members","runtime","resolveEnum","enumIdentifier","decoratorInvocations","decoratorInvocation","parentProto","changeDetection","dir","SWITCH_COMPILE_DIRECTIVE","SWITCH_COMPILE_COMPONENT","pure","SWITCH_COMPILE_PIPE","updateBaseDefFromIOProp","getProp","inheritedBaseDef","baseDef","declaredInputs","initializeBaseDef","bindingPropertyName","hostPropertyName","eventName","EMPTY_ARRAY","convertInjectableProviderToFactory","deps_1","reflectionCapabilities","valueProvider_1","existingProvider_1","factoryProvider_1","classProvider_1","deps_2","deps_3","NgModule","SWITCH_COMPILE_NGMODULE","preR3NgModuleCompile","moduleType","imports","exports","defineInjector","Injectable","SWITCH_COMPILE_INJECTABLE","render2CompileInjectable","injectableType","ERROR_DEBUG_CONTEXT","ERROR_ORIGINAL_ERROR","ERROR_LOGGER","getDebugContext","getOriginalError","defaultErrorLogger","ErrorHandler","_console","handleError","originalError","_findOriginalError","_findContext","errorLogger","getErrorLogger","ReflectiveKey","displayName","_globalKeyRegistry","numberOfKeys","KeyRegistry","_allKeys","has","newKey","size","Reflector","updateCapabilities","caps","identifier","MulticastOperator","shareSubjectFactory","isPromise$1","APP_INITIALIZER","ApplicationInitStatus","appInits","initialized","donePromise","rej","runInitializers","asyncInitPromises","initResult","all","catch","tslib_1.__param","APP_ID_RANDOM_PROVIDER","_appIdRandomProviderFactory","_randomChar","fromCharCode","floor","PLATFORM_INITIALIZER","PLATFORM_ID","APP_BOOTSTRAP_LISTENER","Console","log","_throwError","trace","events","Compiler_compileModuleSync","Compiler_compileModuleAsync","Compiler_compileModuleAndAllComponentsSync","Compiler_compileModuleAndAllComponentsAsync","Compiler","compileModuleSync","compileModuleAsync","compileModuleAndAllComponentsSync","compileModuleAndAllComponentsAsync","clearCache","clearCacheFor","getModuleId","CompilerFactory","wtfEnabled","detectWTF","wtf","noopScope","arg0","arg1","wtfCreateScope","createScope","signature","wtfLeave","leave","scope","returnValue","leaveScope","NgZone","enableLongStackTrace","hasPendingMicrotasks","hasPendingMacrotasks","isStable","onUnstable","onMicrotaskEmpty","onStable","onError","assertZonePatched","_nesting","_outer","_inner","fork","forkInnerZoneWithAngularBehavior","zone","properties","isAngularZone","onInvokeTask","delegate","task","applyThis","applyArgs","onEnter","invokeTask","onLeave","onInvoke","invoke","onHasTask","hasTaskState","hasTask","change","microTask","checkStable","macroTask","onHandleError","runOutsideAngular","isInAngularZone","assertInAngularZone","assertNotInAngularZone","run","runTask","scheduleEventTask","EMPTY_PAYLOAD","cancelTask","runGuarded","noop$2","_platform","NoopNgZone","Testability","_ngZone","_pendingCount","_isZoneStable","_didWork","_callbacks","taskTrackingZone","_watchAngularEvents","_runCallbacksIfReady","increasePendingRequestCount","decreasePendingRequestCount","cb","pop","clearTimeout","timeoutId","doneCb","pending_1","getPendingTasks","filter","updateCb","macroTasks","creationLocation","addCallback","timeout","whenStable","getPendingRequestCount","findProviders","using","exactMatch","TestabilityRegistry","_applications","_testabilityGetter","addToWindow","registerApplication","testability","unregisterApplication","delete","unregisterAllApplications","clear","getTestability","elem","getAllTestabilities","from","getAllRootElements","findTestabilityInTree","findInAncestors","_NoopGetTestability","registry","ALLOW_MULTIPLE_PLATFORMS","createPlatformFactory","parentPlatformFactory","marker","extraProviders","platform","getPlatform","injectedProviders","createPlatform","destroyed","PlatformRef","inits","init","assertPlatform","requiredToken","_injector","_modules","_destroyListeners","_destroyed","bootstrapModuleFactory","moduleFactory","ngZone","getNgZone","ngZoneOption","ngZoneInjector","moduleRef","exceptionHandler","_callAndReportToErrorHandler","errorHandler","initStatus","_moduleDoBootstrap","bootstrapModule","compilerOptions","optionsReducer","compileNgModuleFactory__PRE_R3__","createCompiler","compileNgModuleFactory","ApplicationRef","_bootstrapComponents","f","bootstrap","ngDoBootstrap","module","dst","objs","_zone","_exceptionHandler","_componentFactoryResolver","_initStatus","_bootstrapListeners","_views","_runningTick","_enforceNoNewChanges","_stable","componentTypes","tick","isCurrentlyStable","stableSub","unstableSub","merge$1","observables","last","isScheduler","mergeAll","mergeMap","resultSelector","isInteropObservable","fromObservable","fromPromise","isIterable","fromIterable","mapOperation","ii","share","multicast","subjectOrSubjectFactory","multicastOperatorFunction","componentOrFactory","componentFactory","compRef","_unloadComponent","_loadComponent","ApplicationRef_1","_tickScope","attachView","viewRef","ngOnDestroy","list","el","QueryList$1","QueryList","dirty","_results","changes","find","some","toArray","reset","flatten$2","flat","flatItem","flatten","notifyOnChanges","setDirty","ViewContainerRef","SWITCH_VIEW_CONTAINER_REF_FACTORY","ChangeDetectorRef","SWITCH_CHANGE_DETECTOR_REF_FACTORY","EventListener","DebugNode__PRE_R3__","nativeNode","_debugContext","listeners","DebugElement__PRE_R3__","addChild","references","providerTokens","classes","styles","childNodes","insertChildrenAfter","newChildren","siblingIndex","refChild","newChild","refIndex","query","predicate","queryAll","matches","_queryElementChildren","queryAllNodes","_queryNodeChildren","triggerEventHandler","eventObj","element","parentNode","_nativeNodeToDebugNode","getDebugNode","getDebugNode__PRE_R3__","indexDebugNode","DefaultIterableDifferFactory","supports","trackByFn","DefaultIterableDiffer","trackByIdentity","_linkedRecords","_unlinkedRecords","_previousItHead","_itHead","_itTail","_additionsHead","_additionsTail","_movesHead","_movesTail","_removalsHead","_removalsTail","_identityChangesHead","_identityChangesTail","_trackByFn","forEachItem","forEachOperation","nextIt","nextRemove","addRemoveOffset","moveOffsets","currentIndex","getPreviousIndex","adjPreviousIndex","_nextRemoved","previousIndex","localMovePreviousIndex","localCurrentIndex","offset","forEachPreviousItem","_nextPrevious","forEachAddedItem","_nextAdded","forEachMovedItem","_nextMoved","forEachRemovedItem","forEachIdentityChange","_nextIdentityChange","diff","collection","check","_reset","itemTrackBy","mayBeDirty","index_1","trackById","_verifyReinsertion","_addIdentityChange","_mismatch","iterateListLike","_truncate","isDirty","nextRecord","previousRecord","_prev","_remove","_moveAfter","_reinsertAfter","_addAfter","IterableChangeRecord_","reinsertRecord","_addToMoves","_addToRemovals","_unlink","prevRecord","_prevRemoved","_insertAfter","_DuplicateMap","put","toIndex","_prevDup","_nextDup","_DuplicateItemRecordList","_head","_tail","atOrAfterIndex","duplicates","recordList","moveOffset","DefaultKeyValueDifferFactory","DefaultKeyValueDiffer","_mapHead","_appendAfter","_previousMapHead","_changesHead","_changesTail","forEachChangedItem","_nextChanged","_forEach","_maybeAddToChanges","_getOrCreateRecordForKey","_insertBeforeOrAppend","before","record_1","KeyValueChangeRecord_","_addToAdditions","newValue","_addToChanges","k","IterableDiffers","copied","extend","getTypeNameForDebugging","KeyValueDiffers","kv","keyValDiff","defaultIterableDiffers","defaultKeyValueDiffers","platformCore","LOCALE_ID","APPLICATION_MODULE_PROVIDERS","_keyValueDiffersFactory","_localeFactory","locale","shiftInitState","priorInitState","newInitState","initState","initIndex","shouldCallLifecycleInitHook","asTextData","nodes","asElementData","asProviderData","asPureExpressionData","asQueryList","ApplicationModule","Services","setCurrentNode","createRootView","createEmbeddedView","createComponentView","createNgModuleRef","overrideProvider","overrideComponentView","clearOverrides","checkAndUpdateView","checkNoChangesView","destroyView","resolveDep","createDebugContext","handleEvent","updateDirectives","updateRenderer","dirtyParentQueries","expressionChangedAfterItHasBeenCheckedError","currValue","isFirstCheck","msg","viewDebugError","_addDebugContext","logError","viewDestroyedError","NOOP","_tokenKeyCache","tokenKey","_renderCompCount","checkBinding","bindingIdx","oldValues","bindingIndex","checkAndUpdateBinding","checkBindingNoChanges","bindingName","bindings","markParentViewsForCheck","currView","viewContainerParent","markParentViewsForCheckProjectedViews","endView","dispatchEvent","event","root","declaredViewContainer","parentNodeDef","viewParentEl","renderNode","renderElement","renderText","isComponentView","isEmbeddedView","splitMatchedQueriesDsl","matchedQueriesDsl","matchedQueries","matchedQueryIds","queryId","valueType","filterQueryId","splitDepsDsl","sourceName","configurable","getParentRenderElement","renderHost","componentRendererType","encapsulation","Native","DEFINITION_CACHE","WeakMap","resolveDefinition","visitRootRenderNodes","nextSibling","lastRenderRootNode","visitSiblingRenderNodes","startIndex","nodeDef","visitRenderNode","childCount","visitProjectedRenderNodes","ngContentIndex","compView","hostElDef","projectedNodes","execRenderNodeAction","ngContent","rn","bindingFlags","embeddedViews","viewContainer","_embeddedViews","appendChild","NS_PREFIX_RE","splitNamespace","match","calcBindingFlags","elDef","selectorOrNode","ns","createComment","parentEl","ShadowDom","listenToElementOutputs","output","handleEventClosure","renderEventHandlerClosure","listenTarget","listenerView","disposable","listen","disposables","outputIndex","checkAndUpdateElementValue","binding","elData","setElementAttribute","securityContext","renderValue","sanitize","removeAttribute","setElementClass","addClass","removeClass","setElementStyle","STYLE","unit","suffix","setStyle","removeStyle","setElementProperty","UNDEFINED_VALUE","InjectorRefTokenKey","INJECTORRefTokenKey","NgModuleRefTokenKey","moduleProvideDef","resolveNgModuleDep","depDef","tokenKey_1","providerDef","_def","providersByKey","providerInstance","_providers","_createProviderInstance","targetsModule","moduleTransitivelyPresent","modules","isRoot","injectable","_createClass","depValues","_callFactory","detachEmbeddedView","elementData","removeFromArray","renderDetachView","renderAttachEmbeddedView","prevView","prevRenderNode","addToArray","EMPTY_CONTEXT","ComponentFactory_","viewDefFactory","_inputs","_outputs","inputsArr","outputsArr","viewDef","componentNodeIndex","componentProvider","ComponentRef_","ViewRef_","_viewRef","_component","_elDef","Injector_","createViewContainerData","ViewContainerRef_","_data","ref","templateRef","insert","createComponent","ngModuleRef","contextInjector","parentInjector","viewRef_","attachEmbeddedView","attachProjectedView","vcElementData","dvcElementData","projectedViews","_projectedViews","markNodeAsProjectedTemplate","nodeFlags","childFlags","move","moveEmbeddedView","oldViewIndex","newViewIndex","createChangeDetectorRef","rootRenderNodes","renderNodes","fs","TemplateRef_","_parentView","createInjector$1","createRendererV1","RendererAdapter","namespaceAndName","createViewRoot","createTemplateAnchor","parentElement","comment","createText","projectNodes","attachViewAfter","viewRootNodes","viewAllNodes","listenGlobal","propertyName","propertyValue","attributeValue","setBindingDebugInfo","className","isAdd","styleName","styleValue","invokeElementMethod","methodName","setText","setValue","animate","bootstrapComponents","NgModuleRef_","_moduleType","initNgModule","provDef","injectFlags","callNgModuleLifecycle","lifecycles","Set","RendererV1TokenKey","RendererV1","Renderer2TokenKey","ElementRefTokenKey","ViewContainerRefTokenKey","TemplateRefTokenKey","ChangeDetectorRefTokenKey","createProviderInstance","createPipeInstance","createClass","createDirectiveInstance","outputObservable","eventHandlerClosure","_createProviderInstance$1","allowPrivateServices","callFactory","searchView","findCompView","createInjector","providerDef_1","allProviders","publicProviders","providerData","updateProp","nonMinifiedName","callLifecycleHooksChildrenFirst","parent_1","callProviderLifecycles","directChildFlags","callElementProvidersLifecycles","ngAfterContentInit","ngAfterContentChecked","ngAfterViewInit","ngAfterViewChecked","queryIds","nodeMatchedQueries","tplDef","filterId","checkAndUpdateQuery","queryList","directiveInstance","newValues","elementDef","calcQueryValues","notify","boundValue","bindingType","queryDef","getQueryValue","childMatchedQueries","dvc","projectedView","queryValueType","appendNgContent","prefix","_addInterpolationPart","viewBindingCount","viewDisposableCount","viewNodeFlags","viewRootNodeFlags","viewMatchedQueries","currentParent","currentRenderParent","currentElementHasPublicProviders","currentElementHasPrivateProviders","validateNode","isNgContainer","newParent","rootNodeFlags","bindingCount","outputCount","nodeCount","parentEnd","anchorDef","createView","initView","createViewNodes","compRenderer","nodeData","compViewDef","createTemplateData","execComponentViewsAction","ViewAction","CreateViewNodes","execQueriesAction","markProjectedViewsForCheck","execEmbeddedViewsAction","CheckNoChanges","CheckAndUpdate","callInit","checkAndUpdateNode","argStyle","v0","v1","v2","v3","v4","v5","v6","v7","v8","v9","checkAndUpdateNodeInline","checkAndUpdateElementInline","bindLen","changed","checkAndUpdateTextInline","checkAndUpdateDirectiveInline","ngOnChanges","ngOnInit","ngDoCheck","checkAndUpdatePureExpressionInline","transform","checkAndUpdateNodeDynamic","checkAndUpdateElementDynamic","checkAndUpdateTextDynamic","checkAndUpdateDirectiveDynamic","checkAndUpdatePureExpressionDynamic","params","i_1","checkNoChangesNode","checkNoChangesNodeInline","checkNoChangesNodeDynamic","checkNoChangesQuery","Destroy","detachProjectedView","destroyViewNodes","callViewAction","viewState","execProjectedViewsAction","CheckNoChangesProjectedViews","CheckAndUpdateProjectedViews","queryFlags","staticDynamicQueryFlag","checkType","createProdRootView","elInjector","createRootData","debugCreateRootView","DebugRendererFactory2","defWithOverride","applyProviderOverridesToView","callWithDebugContext","DebugAction","debugCreateEmbeddedView","debugCreateComponentView","viewDefOverrides","debugCreateNgModuleRef","applyProviderOverridesToNgModule","calcHasOverrides","hasOverrides","hasDeprecatedOverrides","providerOverrides","override","deprecatedBehavior","providerOverridesWithScope","applyProviderOverrides","moduleSet_1","debugOverrideProvider","debugOverrideComponentView","comp","compFactory","getComponentViewDefinitionFactory","debugClearOverrides","elementIndicesWithOverwrittenProviders","findElementIndicesWithOverwrittenProviders","elIndicesWithOverwrittenProviders","lastElementDef","applyProviderOverridesToElement","elIndex","prodCheckAndUpdateNode","checkIndex","prodCheckNoChangesNode","debugCheckAndUpdateView","debugCheckNoChangesView","debugDestroyView","_currentAction","_currentView","_currentNodeIndex","debugSetCurrentNode","debugHandleEvent","debugUpdateDirectives","nextDirectiveWithBinding","debugCheckDirectivesFn","debugCheckAndUpdateNode","debugCheckNoChangesNode","debugUpdateRenderer","nextRenderNodeWithBinding","debugCheckRenderNodeFn","givenValues","bindingValues","camelCaseToDashCase","toLowerCase","attr","DebugContext_","elView","elOrCompView","childDef","collectReferences","findHostElement","logViewDef","logNodeIndex","renderNodeIndex","getRenderNodeIndex","currRenderNodeIndex","refName","oldAction","oldNodeIndex","isViewDebugError","viewWrappedDebugError","getCurrentDebugContext","renderData","DebugRenderer2","whenRenderingDone","debugContextFactory","removeDebugNodeFromIndex","namespace","debugCtx","debugEl","debugChildEl","debugRefEl","oldChild","preserveContent","style","NgModuleFactory_","_ngModuleDefFactory","initServicesIfNeeded","services","createDebugServices","createProdServices","cloneNgModuleDefinition","PlatformLocation","digitModifier","inner","date","hourExtractor","intlDateFormat","Intl","DateTimeFormat","format","timeZoneGetter$1","timezone","hour","hour12","timeZoneName","hour12Modify","digitCondition","nameCondition","combine","merged","opt","datePartGetterFactory","ret","timeZoneGetter","ObservableStrategy","createSubscription","async","updateLatestValue","dispose","PromiseStrategy","DOCUMENT","_DOM","getDOM","nodeContains","_attrToPropMap","class","innerHtml","readonly","tabindex","_keyMap","\b","\t","","\u001b","Del","Esc","Left","Right","Up","Down","Menu","Scroll","Win","_chromeNumKeyPadMap","A","B","C","D","E","F","G","H","I","J","K","M","N","O","`","","contains","compareDocumentPosition","urlParsingNode","BrowserDomAdapter","parse","templateHtml","makeCurrent","setRootDomAdapter","adapter","hasProperty","getProperty","logGroup","group","logGroupEnd","groupEnd","nodeA","nodeB","querySelectorAll","on","evt","addEventListener","onAndCancel","createMouseEvent","eventType","getDefaultDocument","createEvent","initEvent","preventDefault","isPrevented","defaultPrevented","getInnerHTML","innerHTML","getTemplateContent","isTemplateElement","content","getOuterHTML","outerHTML","nodeName","nodeValue","childNodesAsList","clearNodes","replaceChild","insertAllBefore","insertAfter","setInnerHTML","getText","textContent","getValue","getChecked","checked","setChecked","createTemplate","html","doc","createTextNode","createScriptTag","attrValue","createStyleElement","css","createShadowRoot","getShadowRoot","shadowRoot","getHost","host","clone","cloneNode","getElementsByClassName","getElementsByTagName","classList","hasClass","stylename","getStyle","hasStyle","attributeMap","elAttrs","attrib","hasAttribute","attribute","hasAttributeNS","getAttribute","getAttributeNS","removeAttributeNS","templateAwareRoot","createHtmlDocument","implementation","createHTMLDocument","getBoundingClientRect","top","bottom","left","right","width","height","getTitle","title","setTitle","newTitle","elementMatches","isElementNode","msMatchesSelector","webkitMatchesSelector","isTextNode","nodeType","Node","TEXT_NODE","isCommentNode","COMMENT_NODE","ELEMENT_NODE","hasShadowRoot","HTMLElement","isShadowRoot","DocumentFragment","importIntoDoc","importNode","adoptNode","getHref","getEventKey","keyIdentifier","startsWith","parseInt","getGlobalEventTarget","body","getHistory","history","getLocation","getBaseHref","href","getBaseElementHref","baseElement","relativePath","url","pathname","resetBaseElement","getUserAgent","navigator","userAgent","setData","getData","getComputedStyle","supportsWebAnimation","Element","performanceNow","performance","now","Date","getTime","supportsCookies","getCookie","cookieStr","encodeURIComponent","cookie","eqIndex","_d","cookieValue","trim","decodeURIComponent","parseCookieValue","setCookie","GenericBrowserDomAdapter","_animationPrefix","_transitionEnd","element_1","domPrefixes","transEndEventNames_1","WebkitTransition","MozTransition","OTransition","transition","getDistributedNodes","resolveAndSetHref","baseUrl","supportsDOMEvents","supportsNativeShadowDOM","getAnimationPrefix","getTransitionEnd","supportsAnimation","DomAdapter","resourceLoaderType","commonDOCUMENT","supportsState","pushState","BrowserPlatformLocation","_doc","_init","_history","getBaseHrefFromDOM","onPopState","onHashChange","newPath","search","hash","replaceState","forward","back","BrowserGetTestability","setTestabilityGetter","testabilities","didWork","decrement","didWork_","core.Optional","blackListedMap","__symbol__","blackListedEvents","platformBrowser","initDomAdapter","_document","AppComponent","AppModule","createNgModuleFactory","ngModuleType","defFactory","moduleDef","createRendererType2","_l","textDef","staticText","createComponentFactory","fixedAttrs","bindingDefs","suffixOrSecurityContext","ns_1","name_1","outputDefs","_e","resolveRendererType2","isFilled","None","directiveDef","depDefs","enableProdMode","AppModuleNgFactory"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty as any) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport function fillProperties(target: {[key: string]: string}, source: {[key: string]: string}) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMPONENT_DEF = getClosureSafeProperty({ngComponentDef: getClosureSafeProperty});\nexport const NG_DIRECTIVE_DEF = getClosureSafeProperty({ngDirectiveDef: getClosureSafeProperty});\nexport const NG_INJECTABLE_DEF = getClosureSafeProperty({ngInjectableDef: getClosureSafeProperty});\nexport const NG_INJECTOR_DEF = getClosureSafeProperty({ngInjectorDef: getClosureSafeProperty});\nexport const NG_PIPE_DEF = getClosureSafeProperty({ngPipeDef: getClosureSafeProperty});\nexport const NG_MODULE_DEF = getClosureSafeProperty({ngModuleDef: getClosureSafeProperty});\nexport const NG_BASE_DEF = getClosureSafeProperty({ngBaseDef: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nexport const NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NG_INJECTABLE_DEF, NG_INJECTOR_DEF} from '../render3/fields';\nimport {Type} from '../type';\n\nimport {ClassProvider, ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, StaticClassProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './provider';\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectableDef<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any>|'root'|'any'|null;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: () => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T|undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorDef<T> {\n  factory: () => T;\n\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the ngInjectableDef property for example).\n  providers: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n              StaticClassProvider|ClassProvider|any[])[];\n\n  imports: (InjectorType<any>|InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has an `InjectableDef` static field.\n *\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ngInjectableDef: never;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ngInjectorDef: never;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n               StaticClassProvider|ClassProvider|any[])[];\n}\n\n\n/**\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\n * in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @publicApi\n */\nexport function defineInjectable<T>(opts: {\n  providedIn?: Type<any>| 'root' | 'any' | null,\n  factory: () => T,\n}): never {\n  return ({\n    providedIn: opts.providedIn as any || null, factory: opts.factory, value: undefined,\n  } as InjectableDef<T>) as never;\n}\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\n *   create the type must be provided. If that factory function needs to inject arguments, it can\n *   use the `inject` function.\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has an `ngInjectableDef` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @publicApi\n */\nexport function defineInjector(options: {factory: () => any, providers?: any[], imports?: any[]}):\n    never {\n  return ({\n    factory: options.factory, providers: options.providers || [], imports: options.imports || [],\n  } as InjectorDef<any>) as never;\n}\n\n/**\n * Read the `ngInjectableDef` type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have `ngInjectableDef`\n */\nexport function getInjectableDef<T>(type: any): InjectableDef<T>|null {\n  return type && type.hasOwnProperty(NG_INJECTABLE_DEF) ? (type as any)[NG_INJECTABLE_DEF] : null;\n}\n\n/**\n * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have `ngInjectorDef`\n */\nexport function getInjectorDef<T>(type: any): InjectorDef<T>|null {\n  return type && type.hasOwnProperty(NG_INJECTOR_DEF) ? (type as any)[NG_INJECTOR_DEF] : null;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\nimport {defineInjectable} from './defs';\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function. See below for an example.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Example\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nexport class InjectionToken<T> {\n  /** @internal */\n  readonly ngMetadataName = 'InjectionToken';\n\n  readonly ngInjectableDef: never|undefined;\n\n  constructor(protected _desc: string, options?: {\n    providedIn?: Type<any>| 'root' | null,\n    factory: () => T\n  }) {\n    if (options !== undefined) {\n      this.ngInjectableDef = defineInjectable({\n        providedIn: options.providedIn || 'root',\n        factory: options.factory,\n      });\n    } else {\n      this.ngInjectableDef = undefined;\n    }\n  }\n\n  toString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nexport interface InjectableDefToken<T> extends InjectionToken<T> { ngInjectableDef: never; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as ES7\n * decorators as well as\n * Angular DSL syntax.\n *\n * ES7 syntax:\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport interface TypeDecorator {\n  /**\n   * Invoke as ES7 decorator.\n   */\n  <T extends Type<any>>(type: T): T;\n\n  // Make TypeDecorator assignable to built-in ParameterDecorator type.\n  // ParameterDecorator is declared in lib.d.ts as a `declare type`\n  // so we cannot declare this interface as a subtype.\n  // see https://github.com/angular/angular/issues/3379#issuecomment-126169417\n  (target: Object, propertyKey?: string|symbol, parameterIndex?: number): void;\n}\n\nexport const ANNOTATIONS = '__annotations__';\nexport const PARAMETERS = '__parameters__';\nexport const PROP_METADATA = '__prop__metadata__';\n\n/**\n * @suppress {globalThis}\n */\nexport function makeDecorator<T>(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (type: Type<T>) => void,\n    typeFn?: (type: Type<T>, ...args: any[]) => void):\n    {new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any;} {\n  const metaCtor = makeMetadataCtor(props);\n\n  function DecoratorFactory(...args: any[]): (cls: Type<T>) => any {\n    if (this instanceof DecoratorFactory) {\n      metaCtor.call(this, ...args);\n      return this;\n    }\n\n    const annotationInstance = new (DecoratorFactory as any)(...args);\n    return function TypeDecorator(cls: Type<T>) {\n      if (typeFn) typeFn(cls, ...args);\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n          (cls as any)[ANNOTATIONS] :\n          Object.defineProperty(cls, ANNOTATIONS, {value: []})[ANNOTATIONS];\n      annotations.push(annotationInstance);\n\n\n      if (additionalProcessing) additionalProcessing(cls);\n\n      return cls;\n    };\n  }\n\n  if (parentClass) {\n    DecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  DecoratorFactory.prototype.ngMetadataName = name;\n  (DecoratorFactory as any).annotationCls = DecoratorFactory;\n  return DecoratorFactory as any;\n}\n\nfunction makeMetadataCtor(props?: (...args: any[]) => any): any {\n  return function ctor(...args: any[]) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nexport function makeParamDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  const metaCtor = makeMetadataCtor(props);\n  function ParamDecoratorFactory(...args: any[]): any {\n    if (this instanceof ParamDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n    const annotationInstance = new (<any>ParamDecoratorFactory)(...args);\n\n    (<any>ParamDecorator).annotation = annotationInstance;\n    return ParamDecorator;\n\n    function ParamDecorator(cls: any, unusedKey: any, index: number): any {\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const parameters = cls.hasOwnProperty(PARAMETERS) ?\n          (cls as any)[PARAMETERS] :\n          Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];\n\n      // there might be gaps if some in between parameters do not have annotations.\n      // we pad with nulls.\n      while (parameters.length <= index) {\n        parameters.push(null);\n      }\n\n      (parameters[index] = parameters[index] || []).push(annotationInstance);\n      return cls;\n    }\n  }\n  if (parentClass) {\n    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n  ParamDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>ParamDecoratorFactory).annotationCls = ParamDecoratorFactory;\n  return ParamDecoratorFactory;\n}\n\nexport function makePropDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any {\n  const metaCtor = makeMetadataCtor(props);\n\n  function PropDecoratorFactory(...args: any[]): any {\n    if (this instanceof PropDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n\n    const decoratorInstance = new (<any>PropDecoratorFactory)(...args);\n\n    function PropDecorator(target: any, name: string) {\n      const constructor = target.constructor;\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n          (constructor as any)[PROP_METADATA] :\n          Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];\n      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n      meta[name].unshift(decoratorInstance);\n\n      if (additionalProcessing) additionalProcessing(target, name, ...args);\n    }\n\n    return PropDecorator;\n  }\n\n  if (parentClass) {\n    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  PropDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;\n  return PropDecoratorFactory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\nimport {Type} from '../type';\nimport {makeParamDecorator, makePropDecorator} from '../util/decorators';\n\n/**\n * This token can be used to create a virtual provider that will populate the\n * `entryComponents` fields of components and ng modules based on its `useValue`.\n * All components that are referenced in the `useValue` value (either directly\n * or in a nested array or map) will be added to the `entryComponents` property.\n *\n * @usageNotes\n * ### Example\n * The following example shows how the router can populate the `entryComponents`\n * field of an NgModule based on the router configuration which refers\n * to components.\n *\n * ```typescript\n * // helper function inside the router\n * function provideRoutes(routes) {\n *   return [\n *     {provide: ROUTES, useValue: routes},\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n *   ];\n * }\n *\n * // user code\n * let routes = [\n *   {path: '/root', component: RootComp},\n *   {path: '/teams', component: TeamsComp}\n * ];\n *\n * @NgModule({\n *   providers: [provideRoutes(routes)]\n * })\n * class ModuleWithRoutes {}\n * ```\n *\n * @publicApi\n */\nexport const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken<any>('AnalyzeForEntryComponents');\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Specifies that a constant attribute value should be injected.\n   *\n   * The directive can inject constant string literals of host element attributes.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * A decorator can inject string literal `text` like so:\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * ### Example as TypeScript Decorator\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   * ### Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function(title) {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...})\n   * ]\n   * MyComponent.parameters = [\n   *   [new ng.Attribute('title')]\n   * ]\n   * ```\n   *\n   * @publicApi\n   */\n  (name: string): any;\n  new (name: string): Attribute;\n}\n\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute { attributeName?: string; }\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator =\n    makeParamDecorator('Attribute', (attributeName?: string) => ({attributeName}));\n\n/**\n * Type of the Query metadata.\n *\n * @publicApi\n */\nexport interface Query {\n  descendants: boolean;\n  first: boolean;\n  read: any;\n  isViewQuery: boolean;\n  selector: any;\n}\n\n/**\n * Base class for query metadata.\n *\n * @see `ContentChildren`.\n * @see `ContentChild`.\n * @see `ViewChildren`.\n * @see `ViewChild`.\n *\n * @publicApi\n */\nexport abstract class Query {}\n\n/**\n * Type of the ContentChildren decorator / constructor function.\n *\n * @see `ContentChildren`.\n * @publicApi\n */\nexport interface ContentChildrenDecorator {\n  /**\n   * Configures a content query.\n   *\n   * You can use ContentChildren to get the `QueryList` of elements or directives from the\n   * content DOM. Any time a child element is added, removed, or moved, the query list will be\n   * updated, and the changes observable of the query list will emit a new value.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **descendants** - include only direct children or all descendants.\n   * * **read** - read a different token from the queried elements.\n   *\n   * @usageNotes\n   * ### Basic Example\n   *\n   * Here is a simple demonstration of how the `ContentChildren` decorator can be used.\n   *\n   * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}\n   *\n   * ### Tab-pane Example\n   *\n   * Here is a slightly more realistic example that shows how `ContentChildren` decorators\n   * can be used to implement a tab pane component.\n   *\n   * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {descendants?: boolean, read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {descendants?: boolean, read?: any}): Query;\n}\n\n/**\n * Type of the ContentChildren metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport type ContentChildren = Query;\n\n/**\n * ContentChildren decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport const ContentChildren: ContentChildrenDecorator = makePropDecorator(\n    'ContentChildren',\n    (selector?: any, data: any = {}) =>\n        ({selector, first: false, isViewQuery: false, descendants: false, ...data}),\n    Query);\n\n/**\n * Type of the ContentChild decorator / constructor function.\n *\n * @publicApi\n */\nexport interface ContentChildDecorator {\n  /**\n   * Configures a content query.\n   *\n   * You can use ContentChild to get the first element or the directive matching the selector from\n   * the content DOM. If the content DOM changes, and a new child matches the selector,\n   * the property will be updated.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **read** - read a different token from the queried element.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ContentChild;\n}\n\n/**\n * Type of the ContentChild metadata.\n *\n * @see `ContentChild`.\n *\n * @publicApi\n */\nexport type ContentChild = Query;\n\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n *\n * @publicApi\n */\nexport const ContentChild: ContentChildDecorator = makePropDecorator(\n    'ContentChild', (selector?: any, data: any = {}) =>\n                        ({selector, first: true, isViewQuery: false, descendants: true, ...data}),\n    Query);\n\n/**\n * Type of the ViewChildren decorator / constructor function.\n *\n * @see `ViewChildren`.\n *\n * @publicApi\n */\nexport interface ViewChildrenDecorator {\n  /**\n   * Configures a view query.\n   *\n   * You can use ViewChildren to get the `QueryList` of elements or directives from the\n   * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,\n   * and the changes observable of the query list will emit a new value.\n   *\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **read** - read a different token from the queried elements.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ViewChildren;\n}\n\n/**\n * Type of the ViewChildren metadata.\n *\n * @publicApi\n */\nexport type ViewChildren = Query;\n\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const ViewChildren: ViewChildrenDecorator = makePropDecorator(\n    'ViewChildren', (selector?: any, data: any = {}) =>\n                        ({selector, first: false, isViewQuery: true, descendants: true, ...data}),\n    Query);\n\n/**\n * Type of the ViewChild decorator / constructor function.\n *\n * @see `ViewChild`.\n * @publicApi\n */\nexport interface ViewChildDecorator {\n  /**\n   * @description\n   * Property decorator that configures a view query.\n   * The change detector looks for the first element or the directive matching the selector\n   * in the view DOM. If the view DOM changes, and a new child matches the selector,\n   * the property is updated.\n   *\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **read** - read a different token from the queried elements.\n   *\n   * Supported selectors include:\n   *   * any class with the `@Component` or `@Directive` decorator\n   *   * a template reference variable as a string (e.g. query `<my-component #cmp></my-component>\n   * with `@ViewChild('cmp')`)\n   *   * any provider defined in the child component tree of the current component (e.g.\n   * `@ViewChild(SomeService) someService: SomeService`)\n   *   * any provider defined through a string token (e.g. `@ViewChild('someToken') someTokenVal:\n   * any`)\n   *   * a `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChild(TemplateRef)\n   * template;`)\n   *\n   * @usageNotes\n   *\n   * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ViewChild;\n}\n\n/**\n * Type of the ViewChild metadata.\n *\n * @publicApi\n */\nexport type ViewChild = Query;\n\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const ViewChild: ViewChildDecorator = makePropDecorator(\n    'ViewChild', (selector: any, data: any) =>\n                     ({selector, first: true, isViewQuery: true, descendants: true, ...data}),\n    Query);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @publicApi\n */\nexport enum ChangeDetectionStrategy {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   */\n  OnPush = 0,\n\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  Default = 1,\n}\n\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport enum ChangeDetectorStatus {\n  /**\n   * A state in which, after calling `detectChanges()`, the change detector\n   * state becomes `Checked`, and must be explicitly invoked or reactivated.\n   */\n  CheckOnce,\n\n  /**\n   * A state in which change detection is skipped until the change detector mode\n   * becomes `CheckOnce`.\n   */\n  Checked,\n\n  /**\n   * A state in which change detection continues automatically until explicitly\n   * deactivated.\n   */\n  CheckAlways,\n\n  /**\n   * A state in which a change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n  Detached,\n\n  /**\n   * Indicates that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state do not detect changes.\n   */\n  Errored,\n\n  /**\n   * Indicates that the change detector has been destroyed.\n   */\n  Destroyed,\n}\n\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy):\n    boolean {\n  return changeDetectionStrategy == null ||\n      changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any /** TODO #9100 */;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any /** TODO #9100 */;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nconst _global: {[name: string]: any} = __global || __window || __self;\n\nconst promise: Promise<any> = Promise.resolve(0);\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n\n// When Symbol.iterator doesn't exist, retrieves the key used in es6-shim\ndeclare const Symbol: any;\nlet _symbolIterator: any = null;\nexport function getSymbolIterator(): string|symbol {\n  if (!_symbolIterator) {\n    const Symbol = _global['Symbol'];\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' &&\n            (Map as any).prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n  return _symbolIterator;\n}\n\nexport function scheduleMicroTask(fn: Function) {\n  if (typeof Zone === 'undefined') {\n    // use promise to schedule microTask instead of use Zone\n    promise.then(() => { fn && fn.apply(null, null); });\n  } else {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n  }\n}\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n  return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token instanceof Array) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport function noSideEffects(fn: () => void): string {\n  return '' + {toString: fn};\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\nimport {getClosureSafeProperty} from '../util/property';\n\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport interface ForwardRefFn { (): any; }\n\nconst __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n  (<any>forwardRefFn).__forward_ref__ = forwardRef;\n  (<any>forwardRefFn).toString = function() { return stringify(this()); };\n  return (<Type<any>><any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport function resolveForwardRef<T>(type: T): T {\n  const fn: any = type;\n  if (typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n      fn.__forward_ref__ === forwardRef) {\n    return fn();\n  } else {\n    return type;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines template and style encapsulation options available for Component's {@link Component}.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport enum ViewEncapsulation {\n  /**\n   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n   * Element and pre-processing the style rules provided via {@link Component#styles styles} or\n   * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\n   * selectors.\n   *\n   * This is the default option.\n   */\n  Emulated = 0,\n  /**\n   * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\n   * Use the native encapsulation mechanism of the renderer.\n   *\n   * For the DOM this means using the deprecated [Shadow DOM\n   * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  Native = 1,\n  /**\n   * Don't provide any template or style encapsulation.\n   */\n  None = 2,\n\n  /**\n   * Use Shadow DOM to encapsulate styles.\n   *\n   * For the DOM this means using modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  ShadowDom = 3\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {InjectFlags} from '../../di/injector_compatibility';\nimport {Type} from '../../type';\nimport {TElementNode} from './node';\nimport {LView, TData} from './view';\n\nexport const TNODE = 8;\nexport const PARENT_INJECTOR = 8;\nexport const INJECTOR_BLOOM_PARENT_SIZE = 9;\n\n/**\n * Represents a relative location of parent injector.\n *\n * The interfaces encodes number of parents `LView`s to traverse and index in the `LView`\n * pointing to the parent injector.\n */\nexport interface RelativeInjectorLocation { __brand__: 'RelativeInjectorLocationFlags'; }\n\nexport const enum RelativeInjectorLocationFlags {\n  InjectorIndexMask = 0b111111111111111,\n  ViewOffsetShift = 16,\n  NO_PARENT = -1,\n}\n\nexport const NO_PARENT_INJECTOR: RelativeInjectorLocation = -1 as any;\n\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n\n/**\n* Factory for creating instances of injectors in the NodeInjector.\n*\n* This factory is complicated by the fact that it can resolve `multi` factories as well.\n*\n* NOTE: Some of the fields are optional which means that this class has two hidden classes.\n* - One without `multi` support (most common)\n* - One with `multi` values, (rare).\n*\n* Since VMs can cache up to 4 inline hidden classes this is OK.\n*\n* - Single factory: Only `resolving` and `factory` is defined.\n* - `providers` factory: `componentProviders` is a number and `index = -1`.\n* - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n*/\nexport class NodeInjectorFactory {\n  /**\n   * The inject implementation to be activated when using the factory.\n   */\n  injectImpl: null|(<T>(token: Type<T>|InjectionToken<T>, flags: InjectFlags) => T);\n\n  /**\n   * Marker set to true during factory invocation to see if we get into recursive loop.\n   * Recursive loop causes an error to be displayed.\n   */\n  resolving = false;\n\n  /**\n   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n   */\n  canSeeViewProviders: boolean;\n\n  /**\n   * An array of factories to use in case of `multi` provider.\n   */\n  multi?: Array<() => any>;\n\n  /**\n   * Number of `multi`-providers which belong to the component.\n   *\n   * This is needed because when multiple components and directives declare the `multi` provider\n   * they have to be concatenated in the correct order.\n   *\n   * Example:\n   *\n   * If we have a component and directive active an a single element as declared here\n   * ```\n   * component:\n   *   provides: [ {provide: String, useValue: 'component', multi: true} ],\n   *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],\n   *\n   * directive:\n   *   provides: [ {provide: String, useValue: 'directive', multi: true} ],\n   * ```\n   *\n   * Then the expected results are:\n   *\n   * ```\n   * providers: ['component', 'directive']\n   * viewProviders: ['component', 'componentView', 'directive']\n   * ```\n   *\n   * The way to think about it is that the `viewProviders` have been inserted after the component\n   * but before the directives, which is why we need to know how many `multi`s have been declared by\n   * the component.\n   */\n  componentProviders?: number;\n\n  /**\n   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n   * See `providerFactory`.\n   */\n  index?: number;\n\n  /**\n   * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is\n   * possible for `viewProvides` to shadow the `provides`. For this reason we store the\n   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n   *\n   * Example:\n   *\n   * Given:\n   * ```\n   * provides: [ {provide: String, useValue: 'all', multi: true} ],\n   * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n   * ```\n   *\n   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n   * of view injection. We further have to make sure that the shared instances (in our case\n   * `all`) are the exact same instance in both the content as well as the view injection. (We\n   * have to make sure that we don't double instantiate.) For this reason the `viewProvides`\n   * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the\n   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n   * ['all', 'viewOnly']`).\n   */\n  providerFactory?: NodeInjectorFactory|null;\n\n\n  constructor(\n      /**\n       * Factory to invoke in order to create a new instance.\n       */\n      public factory:\n          (this: NodeInjectorFactory, _: null,\n           /**\n            * array where injectables tokens are stored. This is used in\n            * case of an error reporting to produce friendlier errors.\n            */\n           tData: TData,\n           /**\n            * array where existing instances of injectables are stored. This is used in case\n            * of multi shadow is needed. See `multi` field documentation.\n            */\n           lView: LView,\n           /**\n            * The TNode of the same element injector.\n            */\n           tNode: TElementNode) => any,\n      /**\n       * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n       */\n      isViewProvider: boolean,\n      injectImplementation: null|(<T>(token: Type<T>|InjectionToken<T>, flags: InjectFlags) => T)) {\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\n\nconst FactoryPrototype = NodeInjectorFactory.prototype;\nexport function isFactory(obj: any): obj is NodeInjectorFactory {\n  // See: https://jsperf.com/instanceof-vs-getprototypeof\n  return obj != null && typeof obj == 'object' && Object.getPrototypeOf(obj) == FactoryPrototype;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LQueries} from './query';\nimport {RComment, RElement} from './renderer';\nimport {StylingContext} from './styling';\nimport {HOST, LView, NEXT, PARENT, QUERIES} from './view';\n\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport const ACTIVE_INDEX = 0;\nexport const VIEWS = 1;\n// PARENT, NEXT, QUERIES, and HOST are indices 2, 3, 4, and 5.\n// As we already have these constants in LView, we don't need to re-create them.\nexport const NATIVE = 6;\nexport const RENDER_PARENT = 7;\n// Because interfaces in TS/JS cannot be instanceof-checked this means that we\n// need to rely on predictable characteristics of data-structures to check if they\n// are what we expect for them to be. The `LContainer` interface code below has a\n// fixed length and the constant value below references that. Using the length value\n// below we can predictably gaurantee that we are dealing with an `LContainer` array.\n// This value MUST be kept up to date with the length of the `LContainer` array\n// interface below so that runtime type checking can work.\nexport const LCONTAINER_LENGTH = 8;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The next active index in the views array to read or write to. This helps us\n   * keep track of where we are in the views array.\n   * In the case the LContainer is created for a ViewContainerRef,\n   * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\n   * i.e. provided directly by the user of the ViewContainerRef API.\n   */\n  [ACTIVE_INDEX]: number;\n\n  /**\n   * A list of the container's currently active child views. Views will be inserted\n   * here as they are added and spliced from here when they are removed. We need\n   * to keep a record of current views so we know which views are already in the DOM\n   * (and don't need to be re-added) and so we can remove views from the DOM when they\n   * are no longer required.\n   */\n  [VIEWS]: LView[];\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView|null;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * Queries active for this container - all the views inserted to / removed from\n   * this container are reported to queries referenced here.\n   */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   *\n   * It could also be a styling context if this is a node with a style/class\n   * binding.\n   */\n  [HOST]: RElement|RComment|StylingContext|LView;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  [NATIVE]: RComment;\n\n  /**\n   * Parent Element which will contain the location where all of the views will be\n   * inserted into to.\n   *\n   * If `renderParent` is `null` it is headless. This means that it is contained\n   * in another view which in turn is contained in another container and\n   * therefore it does not yet have its own parent.\n   *\n   * If `renderParent` is not `null` then it may be:\n   * - same as `tContainerNode.parent` in which case it is just a normal container.\n   * - different from `tContainerNode.parent` in which case it has been re-projected.\n   *   In other words `tContainerNode.parent` is logical parent where as\n   *   `tContainerNode.projectedParent` is render parent.\n   *\n   * When views are inserted into `LContainer` then `renderParent` is:\n   * - `null`, we are in a view, keep going up a hierarchy until actual\n   *   `renderParent` is found.\n   * - not `null`, then use the `projectedParent.native` as the `RElement` to insert\n   * views into.\n   */\n  [RENDER_PARENT]: RElement|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {RElement} from './renderer';\nimport {LView} from './view';\n\n/**\n * This property will be monkey-patched on elements, components and directives\n */\nexport const MONKEY_PATCH_KEY_NAME = '__ngContext__';\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nexport interface LContext {\n  /**\n   * The component's parent view data.\n   */\n  lView: LView;\n\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex: number;\n\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native: RElement;\n\n  /**\n   * The instance of the Component node.\n   */\n  component: {}|null|undefined;\n\n  /**\n   * The list of active directives that exist on this element.\n   */\n  directives: any[]|null|undefined;\n\n  /**\n   * The map of local references (local reference name => element or directive instance) that exist\n   * on this element.\n   */\n  localRefs: {[key: string]: any}|null|undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {Injector} from '../../di/injector';\nimport {QueryList} from '../../linker';\nimport {Sanitizer} from '../../sanitization/security';\nimport {Type} from '../../type';\nimport {LContainer} from './container';\nimport {ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList} from './definition';\nimport {I18nUpdateOpCodes, TI18n} from './i18n';\nimport {TElementNode, TNode, TViewNode} from './node';\nimport {PlayerHandler} from './player';\nimport {LQueries} from './query';\nimport {RElement, Renderer3, RendererFactory3} from './renderer';\nimport {StylingContext} from './styling';\n\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const TVIEW = 0;\nexport const FLAGS = 1;\nexport const PARENT = 2;\nexport const NEXT = 3;\nexport const QUERIES = 4;\nexport const HOST = 5;\nexport const HOST_NODE = 6;  // Rename to `T_HOST`?\nexport const BINDING_INDEX = 7;\nexport const CLEANUP = 8;\nexport const CONTEXT = 9;\nexport const INJECTOR = 10;\nexport const RENDERER_FACTORY = 11;\nexport const RENDERER = 12;\nexport const SANITIZER = 13;\nexport const TAIL = 14;\nexport const CONTAINER_INDEX = 15;\nexport const CONTENT_QUERIES = 16;\nexport const DECLARATION_VIEW = 17;\n/** Size of LView's header. Necessary to adjust for it when setting slots.  */\nexport const HEADER_OFFSET = 18;\n\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView extends Array<any> {\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly[TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * The parent view is needed when we exit the view and must restore the previous\n   * `LView`. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * This is the \"insertion\" view for embedded views. This allows us to properly\n   * destroy embedded views.\n   */\n  [PARENT]: LView|null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * The host node for this LView instance, if this is a component view.\n   *\n   * If this is an embedded view, HOST will be null.\n   */\n  [HOST]: RElement|StylingContext|null;\n\n  /**\n   * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.\n   *\n   * If `TViewNode`, this is an embedded view of a container. We need this to be able to\n   * efficiently find the `LViewNode` when inserting the view into an anchor.\n   *\n   * If `TElementNode`, this is the LView of a component.\n   *\n   * If null, this is the root view of an application (root component is in this view).\n   */\n  [HOST_NODE]: TViewNode|TElementNode|null;\n\n  /**\n   * The binding index we should access next.\n   *\n   * This is stored so that bindings can continue where they left off\n   * if a view is left midway through processing bindings (e.g. if there is\n   * a setter that creates an embedded view, like in ngIf).\n   */\n  [BINDING_INDEX]: number;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   */\n  // TODO: flatten into LView[]\n  [CLEANUP]: any[]|null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component the context contains change detection data.\n   * - For non-root components, the context is the component instance,\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: {}|RootContext|null;\n\n  /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly[INJECTOR]: Injector|null;\n\n  /** Renderer to be used for this view. */\n  [RENDERER_FACTORY]: RendererFactory3;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer3;\n\n  /** An optional custom sanitizer. */\n  [SANITIZER]: Sanitizer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [TAIL]: LView|LContainer|null;\n\n  /**\n   * The index of the parent container's host node. Applicable only to embedded views that\n   * have been inserted dynamically. Will be -1 for component views and inline views.\n   *\n   * This is necessary to jump from dynamically created embedded views to their parent\n   * containers because their parent cannot be stored on the TViewNode (views may be inserted\n   * in multiple containers, so the parent cannot be shared between view instances).\n   */\n  [CONTAINER_INDEX]: number;\n\n  /**\n   * Stores QueryLists associated with content queries of a directive. This data structure is\n   * filled-in as part of a directive creation process and is later used to retrieve a QueryList to\n   * be refreshed.\n   */\n  [CONTENT_QUERIES]: QueryList<any>[]|null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * Only applicable for dynamically created views. Will be null for inline/component views.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView|null;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b000000001,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 0b000000010,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b000000100,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b000001000,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b000010000,\n\n  /**\n   *  Whether or not the init hooks have run.\n   *\n   * If on, the init hooks haven't yet been run and should be executed by the first component that\n   * runs OR the first cR() instruction that runs (so inits are run for the top level view before\n   * any embedded views).\n   */\n  RunInit = 0b000100000,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 0b001000000,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 0b010000000,\n}\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the template function as ngPrivateData.\n */\nexport interface TView {\n  /**\n   * ID for inline views to determine whether a view is the same as the previous view\n   * in a certain position. If it's not, we know the new view needs to be inserted\n   * and the one that exists needs to be removed (e.g. if/else statements)\n   *\n   * If this is -1, then this is a component view or a dynamically created view.\n   */\n  readonly id: number;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ComponentQuery<{}>|null;\n\n  /**\n   * Pointer to the `TNode` that represents the root of the view.\n   *\n   * If this is a `TViewNode` for an `LViewNode`, this is an embedded view of a container.\n   * We need this pointer to be able to efficiently find this node when inserting the view\n   * into an anchor.\n   *\n   * If this is a `TElementNode`, this is the view of a root component. It has exactly one\n   * root TNode.\n   *\n   * If this is null, this is the view of a component that is not at root. We do not store\n   * the host TNodes for child component views because they can potentially have several\n   * different host TNodes, depending on where the component is being used. These host\n   * TNodes cannot be shared (due to different indices, etc).\n   */\n  node: TViewNode|TElementNode|null;\n\n  /** Whether or not this template has been processed. */\n  firstTemplatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"consts\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Index of the host node of the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   *\n   * For embedded views, we store the index of an LContainer's host rather than the first\n   * LView to avoid managing splicing when views are added/removed.\n   */\n  childIndex: number;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode|null;\n\n  /**\n   * Set of instructions used to process host bindings efficiently.\n   *\n   * See VIEW_DATA.md for more information.\n   */\n  expandoInstructions: (number|HostBindingsFunction<any>|null)[]|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  initHooks: HookData|null;\n\n  /**\n   * Array of ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  checkHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: HookData|null;\n\n  /**\n   * Array of pipe ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Index of pipe in data\n   * Odd indices: Hook function\n   *\n   * These must be stored separately from directive destroy hooks because their contexts\n   * are stored in data.\n   */\n  pipeDestroyHooks: HookData|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element `element = lView[tView.cleanup[i+1]]`\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's a renderer2 style listener or ViewRef destroy hook being stored:\n   * 1st index is: index of the cleanup function in LView.cleanupInstances[]\n   * 2nd index is: `null`\n   *               `lView[CLEANUP][tView.cleanup[i+0]]()`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A list of indices for child directives that have content queries.\n   *\n   * Even indices: Directive indices\n   * Odd indices: Starting index of content queries (stored in CONTENT_QUERIES) for this directive\n   */\n  contentQueries: number[]|null;\n}\n\nexport const enum RootContextFlags {Empty = 0b00, DetectChanges = 0b01, FlushPlayers = 0b10}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: {}[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * Even indices: Directive index\n * Odd indices: Hook function\n */\nexport type HookData = (number | (() => void))[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData =\n    (TNode | PipeDef<any>| DirectiveDef<any>| ComponentDef<any>| number | Type<any>|\n     InjectionToken<any>| TI18n | I18nUpdateOpCodes | null)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../util';\n\nimport {assertDataInRange, assertDefined, assertGreaterThan, assertLessThan} from './assert';\nimport {ACTIVE_INDEX, LCONTAINER_LENGTH, LContainer} from './interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags} from './interfaces/injector';\nimport {TContainerNode, TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {RComment, RElement, RText} from './interfaces/renderer';\nimport {StylingContext} from './interfaces/styling';\nimport {CONTEXT, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, LView, LViewFlags, PARENT, RootContext, TData, TVIEW, TView} from './interfaces/view';\n\n/**\n * Returns whether the values are different from a change detection stand point.\n *\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\n */\nexport function isDifferent(a: any, b: any): boolean {\n  // NaN is the only value that is not equal to itself so the first\n  // test checks if both a and b are not NaN\n  return !(a !== a && b !== b) && a !== b;\n}\n\nexport function stringify(value: any): string {\n  if (typeof value == 'function') return value.name || value;\n  if (typeof value == 'string') return value;\n  if (value == null) return '';\n  if (typeof value == 'object' && typeof value.type == 'function')\n    return value.type.name || value.type;\n  return '' + value;\n}\n\n/**\n * Flattens an array in non-recursive way. Input arrays are not modified.\n */\nexport function flatten(list: any[]): any[] {\n  const result: any[] = [];\n  let i = 0;\n\n  while (i < list.length) {\n    const item = list[i];\n    if (Array.isArray(item)) {\n      if (item.length > 0) {\n        list = item.concat(list.slice(i + 1));\n        i = 0;\n      } else {\n        i++;\n      }\n    } else {\n      result.push(item);\n      i++;\n    }\n  }\n\n  return result;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function loadInternal<T>(view: LView | TData, index: number): T {\n  ngDevMode && assertDataInRange(view, index + HEADER_OFFSET);\n  return view[index + HEADER_OFFSET];\n}\n\n/**\n * Takes the value of a slot in `LView` and returns the element node.\n *\n * Normally, element nodes are stored flat, but if the node has styles/classes on it,\n * it might be wrapped in a styling context. Or if that node has a directive that injects\n * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,\n * it will be wrapped in LView. It could even have all three, so we keep looping\n * until we find something that isn't an array.\n *\n * @param value The initial value in `LView`\n */\nexport function readElementValue(value: RElement | StylingContext | LContainer | LView): RElement {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RElement {\n  return readElementValue(lView[index + HEADER_OFFSET]);\n}\n\nexport function getNativeByTNode(tNode: TNode, hostView: LView): RElement|RText|RComment {\n  return readElementValue(hostView[tNode.index]);\n}\n\nexport function getTNode(index: number, view: LView): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, view[TVIEW].data.length, 'wrong index for TNode');\n  return view[TVIEW].data[index + HEADER_OFFSET] as TNode;\n}\n\nexport function getComponentViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  const slotValue = hostView[nodeIndex];\n  return slotValue.length >= HEADER_OFFSET ? slotValue : slotValue[HOST];\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isLContainer(value: RElement | RComment | LContainer | StylingContext): boolean {\n  // Styling contexts are also arrays, but their first index contains an element node\n  return Array.isArray(value) && value.length === LCONTAINER_LENGTH;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param component any component\n */\nexport function getRootView(target: LView | {}): LView {\n  ngDevMode && assertDefined(target, 'component');\n  let lView = Array.isArray(target) ? (target as LView) : readPatchedLView(target) !;\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView = lView[PARENT] !;\n  }\n  return lView;\n}\n\nexport function getRootContext(viewOrComponent: LView | {}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LView|LContext|null {\n  ngDevMode && assertDefined(target, 'Target expected');\n  return target[MONKEY_PATCH_KEY_NAME];\n}\n\nexport function readPatchedLView(target: any): LView|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lView;\n  }\n  return null;\n}\n\nexport function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nexport function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n}\n\nexport function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) >> RelativeInjectorLocationFlags.ViewOffsetShift;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nexport function getParentInjectorView(location: RelativeInjectorLocation, startView: LView): LView {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    viewOffset--;\n  }\n  return parentView;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the TNode of the parent injector is found.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @param startTNode The TNode instance of the starting element\n * @returns The TNode of the parent injector\n */\nexport function getParentInjectorTNode(\n    location: RelativeInjectorLocation, startView: LView, startTNode: TNode): TElementNode|\n    TContainerNode|null {\n  if (startTNode.parent && startTNode.parent.injectorIndex !== -1) {\n    // view offset is 0\n    const injectorIndex = startTNode.parent.injectorIndex;\n    let parentTNode = startTNode.parent;\n    while (parentTNode.parent != null && injectorIndex == parentTNode.injectorIndex) {\n      parentTNode = parentTNode.parent;\n    }\n    return parentTNode;\n  }\n\n  let viewOffset = getParentInjectorViewOffset(location);\n  // view offset is 1\n  let parentView = startView;\n  let parentTNode = startView[HOST_NODE] as TElementNode;\n\n  // view offset is superior to 1\n  while (viewOffset > 1) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    parentTNode = parentView[HOST_NODE] as TElementNode;\n    viewOffset--;\n  }\n  return parentTNode;\n}\n\nexport const defaultScheduler =\n    (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame ||  // browser only\n     setTimeout                                                                // everything else\n     ).bind(global);\n\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\nexport function addAllToArray(items: any[], arr: any[]) {\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n}\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lView LView for which we want a host element node\n * @returns The host node\n */\nexport function findComponentView(lView: LView): LView {\n  let rootTNode = lView[HOST_NODE];\n\n  while (rootTNode && rootTNode.type === TNodeType.View) {\n    ngDevMode && assertDefined(lView[DECLARATION_VIEW], 'lView[DECLARATION_VIEW]');\n    lView = lView[DECLARATION_VIEW] !;\n    rootTNode = lView[HOST_NODE];\n  }\n\n  return lView;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow\n * for late binding of `@angular/compiler` for JIT purposes.\n *\n * This file has two copies. Please ensure that they are in sync:\n *  - packages/compiler/src/compiler_facade_interface.ts             (master)\n *  - packages/core/src/render3/jit/compiler_facade_interface.ts     (copy)\n *\n * Please ensure that the two files are in sync using this command:\n * ```\n * cp packages/compiler/src/compiler_facade_interface.ts \\\n *    packages/core/src/render3/jit/compiler_facade_interface.ts\n * ```\n */\n\nexport interface ExportedCompilerFacade { ÉµcompilerFacade: CompilerFacade; }\n\nexport interface CompilerFacade {\n  compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3PipeMetadataFacade):\n      any;\n  compileInjectable(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectableMetadataFacade): any;\n  compileInjector(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectorMetadataFacade): any;\n  compileNgModule(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3NgModuleMetadataFacade): any;\n  compileDirective(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadataFacade): any;\n  compileComponent(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3ComponentMetadataFacade): any;\n\n  R3ResolvedDependencyType: typeof R3ResolvedDependencyType;\n}\n\nexport interface CoreEnvironment { [name: string]: Function; }\n\nexport type StringMap = {\n  [key: string]: string;\n};\n\nexport type StringMapWithRename = {\n  [key: string]: string | [string, string];\n};\n\nexport type Provider = any;\n\nexport enum R3ResolvedDependencyType {\n  Token = 0,\n  Attribute = 1,\n}\n\nexport interface R3DependencyMetadataFacade {\n  token: any;\n  resolved: R3ResolvedDependencyType;\n  host: boolean;\n  optional: boolean;\n  self: boolean;\n  skipSelf: boolean;\n}\n\nexport interface R3PipeMetadataFacade {\n  name: string;\n  type: any;\n  pipeName: string;\n  deps: R3DependencyMetadataFacade[]|null;\n  pure: boolean;\n}\n\nexport interface R3InjectableMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  ctorDeps: R3DependencyMetadataFacade[]|null;\n  providedIn: any;\n  useClass?: any;\n  useFactory?: any;\n  useExisting?: any;\n  useValue?: any;\n  userDeps?: R3DependencyMetadataFacade[];\n}\n\nexport interface R3NgModuleMetadataFacade {\n  type: any;\n  bootstrap: Function[];\n  declarations: Function[];\n  imports: Function[];\n  exports: Function[];\n  emitInline: boolean;\n}\n\nexport interface R3InjectorMetadataFacade {\n  name: string;\n  type: any;\n  deps: R3DependencyMetadataFacade[]|null;\n  providers: any[];\n  imports: any[];\n}\n\nexport interface R3DirectiveMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  typeSourceSpan: null;\n  deps: R3DependencyMetadataFacade[]|null;\n  selector: string|null;\n  queries: R3QueryMetadataFacade[];\n  host: {[key: string]: string};\n  propMetadata: {[key: string]: any[]};\n  lifecycle: {usesOnChanges: boolean;};\n  inputs: string[];\n  outputs: string[];\n  usesInheritance: boolean;\n  exportAs: string|null;\n  providers: Provider[]|null;\n}\n\nexport interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {\n  template: string;\n  preserveWhitespaces: boolean;\n  animations: any[]|undefined;\n  viewQueries: R3QueryMetadataFacade[];\n  pipes: Map<string, any>;\n  directives: {selector: string, expression: any}[];\n  styles: string[];\n  encapsulation: ViewEncapsulation;\n  viewProviders: Provider[]|null;\n  interpolation?: [string, string];\n  changeDetection?: ChangeDetectionStrategy;\n}\n\nexport type ViewEncapsulation = number;\n\nexport type ChangeDetectionStrategy = number;\n\nexport interface R3QueryMetadataFacade {\n  propertyName: string;\n  first: boolean;\n  predicate: any|string[];\n  descendants: boolean;\n  read: any|null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, getInjectableDef} from './defs';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n\n\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation: (<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags) => T | null)|\n    undefined;\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined):\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>): T;\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|\n    null;\nexport function injectInjectorOnly<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @publicApi\n */\nexport function inject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  return (_injectImplementation || injectInjectorOnly)(token, flags);\n}\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport function injectRootLimpMode<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T|null {\n  const injectableDef: InjectableDef<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, flags));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {executeHooks} from './hooks';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {TElementNode, TNode, TNodeFlags, TViewNode} from './interfaces/node';\nimport {LQueries} from './interfaces/query';\nimport {BINDING_INDEX, CONTEXT, DECLARATION_VIEW, FLAGS, HOST_NODE, LView, LViewFlags, OpaqueViewState, QUERIES, TVIEW} from './interfaces/view';\nimport {isContentQueryHost} from './util';\n\n\n\n/**\n * Store the element depth count. This is used to identify the root elements of the template\n * so that we can than attach `LView` to only those elements.\n */\nlet elementDepthCount !: number;\n\nexport function getElementDepthCount() {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  elementDepthCount--;\n}\n\nlet currentDirectiveDef: DirectiveDef<any>|ComponentDef<any>|null = null;\n\nexport function getCurrentDirectiveDef(): DirectiveDef<any>|ComponentDef<any>|null {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return currentDirectiveDef;\n}\n\nexport function setCurrentDirectiveDef(def: DirectiveDef<any>| ComponentDef<any>| null): void {\n  currentDirectiveDef = def;\n}\n\n/**\n * Stores whether directives should be matched to elements.\n *\n * When template contains `ngNonBindable` than we need to prevent the runtime form matching\n * directives on children of that element.\n *\n * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n * </div>\n * ```\n */\nlet bindingsEnabled !: boolean;\n\nexport function getBindingsEnabled(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return bindingsEnabled;\n}\n\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function enableBindings(): void {\n  bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function disableBindings(): void {\n  bindingsEnabled = false;\n}\n\nexport function getLView(): LView {\n  return lView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n */\nexport function restoreView(viewToRestore: OpaqueViewState) {\n  contextLView = viewToRestore as any as LView;\n}\n\n/** Used to set the parent property when nodes are created and track query results. */\nlet previousOrParentTNode: TNode;\n\nexport function getPreviousOrParentTNode(): TNode {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return previousOrParentTNode;\n}\n\nexport function setPreviousOrParentTNode(tNode: TNode) {\n  previousOrParentTNode = tNode;\n}\n\nexport function setTNodeAndViewData(tNode: TNode, view: LView) {\n  previousOrParentTNode = tNode;\n  lView = view;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentTNode` points to a parent node.\n *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\nexport function getIsParent(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return isParent;\n}\n\nexport function setIsParent(value: boolean): void {\n  isParent = value;\n}\n\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\n * create content queries).\n */\nexport function getOrCreateCurrentQueries(\n    QueryType: {new (parent: null, shallow: null, deep: null): LQueries}): LQueries {\n  const lView = getLView();\n  let currentQueries = lView[QUERIES];\n  // if this is the first content query on a node, any existing LQueries needs to be cloned\n  // in subsequent template passes, the cloning occurs before directive instantiation.\n  if (previousOrParentTNode && previousOrParentTNode !== lView[HOST_NODE] &&\n      !isContentQueryHost(previousOrParentTNode)) {\n    currentQueries && (currentQueries = lView[QUERIES] = currentQueries.clone());\n    previousOrParentTNode.flags |= TNodeFlags.hasContentQuery;\n  }\n\n  return currentQueries || (lView[QUERIES] = new QueryType(null, null, null));\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView = lView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * State of the current view being processed.\n *\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet lView: LView;\n\n/**\n * The last viewData retrieved by nextContext().\n * Allows building nextContext() and reference() calls.\n *\n * e.g. const inner = x().$implicit; const outer = x().$implicit;\n */\nlet contextLView: LView = null !;\n\nexport function getContextLView(): LView {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return contextLView;\n}\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\nexport function getCheckNoChangesMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return checkNoChangesMode;\n}\n\nexport function setCheckNoChangesMode(mode: boolean): void {\n  checkNoChangesMode = mode;\n}\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\nexport function getFirstTemplatePass(): boolean {\n  return firstTemplatePass;\n}\n\nexport function setFirstTemplatePass(value: boolean): void {\n  firstTemplatePass = value;\n}\n\n/**\n * The root index from which pure function instructions should calculate their binding\n * indices. In component views, this is TView.bindingStartIndex. In a host binding\n * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n */\nlet bindingRootIndex: number = -1;\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  return bindingRootIndex;\n}\n\nexport function setBindingRoot(value: number) {\n  bindingRootIndex = value;\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LView, hostTNode: TElementNode | TViewNode | null): LView {\n  const oldView = lView;\n  if (newView) {\n    const tView = newView[TVIEW];\n    firstTemplatePass = tView.firstTemplatePass;\n    bindingRootIndex = tView.bindingStartIndex;\n  }\n\n  previousOrParentTNode = hostTNode !;\n  isParent = true;\n\n  lView = contextLView = newView;\n  return oldView;\n}\n\nexport function nextContextImpl<T = any>(level: number = 1): T {\n  contextLView = walkUpViews(level, contextLView !);\n  return contextLView[CONTEXT] as T;\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/**\n * Resets the application state.\n */\nexport function resetComponentState() {\n  isParent = false;\n  previousOrParentTNode = null !;\n  elementDepthCount = 0;\n  bindingsEnabled = true;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n */\nexport function leaveView(newView: LView): void {\n  const tView = lView[TVIEW];\n  if (isCreationMode(lView)) {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n  } else {\n    executeHooks(lView, tView.viewHooks, tView.viewCheckHooks, checkNoChangesMode);\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    lView[FLAGS] |= LViewFlags.RunInit;\n    lView[BINDING_INDEX] = tView.bindingStartIndex;\n  }\n  enterView(newView, null);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, StaticClassProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from '../di/provider';\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {Type} from '../type';\nimport {makeDecorator, makeParamDecorator} from '../util/decorators';\nimport {EMPTY_ARRAY} from '../view/util';\n\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n  /**\n   * A constructor parameter decorator that specifies a\n   * custom provider of a dependency.\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * The following example shows a class constructor that specifies a\n   * custom provider of a dependency using the parameter decorator.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Inject'}\n   *\n   * When `@Inject()` is not present, the `Injector` uses the type annotation of the\n   * parameter as the provider.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}\n   */\n  (token: any): any;\n  new (token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n  /**\n   * Injector token that maps to the dependency to be injected.\n   */\n  token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Inject: InjectDecorator = makeParamDecorator('Inject', (token: any) => ({token}));\n\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n  /**\n   * A constructor parameter decorator that marks a dependency as optional.\n   *\n   * The DI framework provides null if the dependency is not found.\n   * For example, the following code allows the possibility of a null result:\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Optional'}\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   */\n  (): any;\n  new (): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Optional: OptionalDecorator = makeParamDecorator('Optional');\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n  /**\n   * A constructor parameter decorator that tells the DI framework\n   * to retrieve a dependency only from the local injector.\n   *\n   * In the following example, the dependency can be resolved\n   * by the local injector when instantiating the class itself, but not\n   * when instantiating a child.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Self'}\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   *\n   */\n  (): any;\n  new (): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Self: SelfDecorator = makeParamDecorator('Self');\n\n\n/**\n * Type of the SkipSelf decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n  /**\n   * A constructor parameter decorator that tells the DI framework\n   * that dependency resolution should start from the parent injector.\n   *\n   * In the following example, the dependency can be resolved when\n   * instantiating a child, but not when instantiating the class itself.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   *\n   */\n  (): any;\n  new (): SkipSelf;\n}\n\n/**\n * Type of the SkipSelf metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {}\n\n/**\n * SkipSelf decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const SkipSelf: SkipSelfDecorator = makeParamDecorator('SkipSelf');\n\n/**\n * Type of the Host decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n  /**\n   * A constructor parameter decorator that tells the DI framework\n   * to retrieve a dependency from any injector until\n   * reaching the host element of the current component.\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Host'}\n   */\n  (): any;\n  new (): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Host: HostDecorator = makeParamDecorator('Host');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode} from './interfaces/node';\nimport {FLAGS, HookData, LView, LViewFlags, TView} from './interfaces/view';\n\n\n\n/**\n * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into\n * TView.initHooks during directiveCreate.\n *\n * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:\n * directive index), then saved in the even indices of the initHooks array. The odd indices\n * hold the hook functions themselves.\n *\n * @param index The index of the directive in LView\n * @param hooks The static hooks map on the directive def\n * @param tView The current TView\n */\nexport function queueInitHooks(\n    index: number, onInit: (() => void) | null, doCheck: (() => void) | null, tView: TView): void {\n  ngDevMode &&\n      assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');\n  if (onInit) {\n    (tView.initHooks || (tView.initHooks = [])).push(index, onInit);\n  }\n\n  if (doCheck) {\n    (tView.initHooks || (tView.initHooks = [])).push(index, doCheck);\n    (tView.checkHooks || (tView.checkHooks = [])).push(index, doCheck);\n  }\n}\n\n/**\n * Loops through the directives on a node and queues all their hooks except ngOnInit\n * and ngDoCheck, which are queued separately in directiveCreate.\n */\nexport function queueLifecycleHooks(tView: TView, tNode: TNode): void {\n  if (tView.firstTemplatePass) {\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n      const def = tView.data[i] as DirectiveDef<any>;\n      queueContentHooks(def, tView, i);\n      queueViewHooks(def, tView, i);\n      queueDestroyHooks(def, tView, i);\n    }\n  }\n}\n\n/** Queues afterContentInit and afterContentChecked hooks on TView */\nfunction queueContentHooks(def: DirectiveDef<any>, tView: TView, i: number): void {\n  if (def.afterContentInit) {\n    (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentInit);\n  }\n\n  if (def.afterContentChecked) {\n    (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentChecked);\n    (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, def.afterContentChecked);\n  }\n}\n\n/** Queues afterViewInit and afterViewChecked hooks on TView */\nfunction queueViewHooks(def: DirectiveDef<any>, tView: TView, i: number): void {\n  if (def.afterViewInit) {\n    (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewInit);\n  }\n\n  if (def.afterViewChecked) {\n    (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewChecked);\n    (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, def.afterViewChecked);\n  }\n}\n\n/** Queues onDestroy hooks on TView */\nfunction queueDestroyHooks(def: DirectiveDef<any>, tView: TView, i: number): void {\n  if (def.onDestroy != null) {\n    (tView.destroyHooks || (tView.destroyHooks = [])).push(i, def.onDestroy);\n  }\n}\n\n/**\n * Calls onInit and doCheck calls if they haven't already been called.\n *\n * @param currentView The current view\n */\nexport function executeInitHooks(\n    currentView: LView, tView: TView, checkNoChangesMode: boolean): void {\n  if (!checkNoChangesMode && currentView[FLAGS] & LViewFlags.RunInit) {\n    executeHooks(currentView, tView.initHooks, tView.checkHooks, checkNoChangesMode);\n    currentView[FLAGS] &= ~LViewFlags.RunInit;\n  }\n}\n\n/**\n * Iterates over afterViewInit and afterViewChecked functions and calls them.\n *\n * @param currentView The current view\n */\nexport function executeHooks(\n    currentView: LView, allHooks: HookData | null, checkHooks: HookData | null,\n    checkNoChangesMode: boolean): void {\n  if (checkNoChangesMode) return;\n\n  const hooksToCall = currentView[FLAGS] & LViewFlags.FirstLViewPass ? allHooks : checkHooks;\n  if (hooksToCall) {\n    callHooks(currentView, hooksToCall);\n  }\n}\n\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass.\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n */\nexport function callHooks(currentView: any[], arr: HookData): void {\n  for (let i = 0; i < arr.length; i += 2) {\n    (arr[i + 1] as() => void).call(currentView[arr[i] as number]);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getInjectableDef, getInjectorDef} from '../di/defs';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectFlags, injectRootLimpMode, setInjectImplementation} from '../di/injector_compatibility';\nimport {Type} from '../type';\n\nimport {assertDefined, assertEqual} from './assert';\nimport {getComponentDef, getDirectiveDef, getPipeDef} from './definition';\nimport {NG_ELEMENT_ID} from './fields';\nimport {DirectiveDef} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, NodeInjectorFactory, PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags, TNODE, isFactory} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType} from './interfaces/node';\nimport {DECLARATION_VIEW, HOST_NODE, INJECTOR, LView, TData, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {getLView, getPreviousOrParentTNode, setTNodeAndViewData} from './state';\nimport {findComponentView, getParentInjectorIndex, getParentInjectorView, hasParentInjector, isComponent, isComponentDef, stringify} from './util';\n\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\n\nfunction setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n    injectorIndex: number, tView: TView, type: Type<any>| InjectionToken<any>| string): void {\n  ngDevMode && assertEqual(tView.firstTemplatePass, true, 'expected firstTemplatePass to be true');\n  let id: number|undefined =\n      typeof type !== 'string' ? (type as any)[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n  const tData = tView.data as number[];\n\n  if (b7) {\n    b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n         (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n  } else {\n    b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n         (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n  }\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LView): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, hostView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = hostView[TVIEW];\n  if (tView.firstTemplatePass) {\n    tNode.injectorIndex = hostView.length;\n    insertBloom(tView.data, tNode);  // foundation for node bloom\n    insertBloom(hostView, null);     // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n\n    ngDevMode && assertEqual(\n                     tNode.flags === 0 || tNode.flags === TNodeFlags.isComponent, true,\n                     'expected tNode.flags to not be initialized');\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, hostView);\n  const parentIndex = getParentInjectorIndex(parentLoc);\n  const parentLView = getParentInjectorView(parentLoc, hostView);\n\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8; i++) {\n      hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode | null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\n\nexport function getInjectorIndex(tNode: TNode, hostView: LView): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\n    return -1;\n  } else {\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\n */\nexport function getParentInjectorLocation(tNode: TNode, view: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex as any;  // ViewOffset is 0\n  }\n\n  // For most cases, the parent injector index can be found on the host node (e.g. for component\n  // or container), so this loop will be skipped, but we must keep the loop here to support\n  // the rarer case of deeply nested <ng-template> tags or inline views.\n  let hostTNode = view[HOST_NODE];\n  let viewOffset = 1;\n  while (hostTNode && hostTNode.injectorIndex === -1) {\n    view = view[DECLARATION_VIEW] !;\n    hostTNode = view ? view[HOST_NODE] : null;\n    viewOffset++;\n  }\n\n  return hostTNode ?\n      hostTNode.injectorIndex | (viewOffset << RelativeInjectorLocationFlags.ViewOffsetShift) :\n      -1 as any;\n}\n\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, view: LView, token: InjectionToken<any>| Type<any>): void {\n  bloomAdd(injectorIndex, view[TVIEW], token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string|null {\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  const attrs = tNode.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      const attrName = attrs[i];\n      if (attrName === AttributeMarker.SelectOnly) break;\n      if (attrName == attrNameToInject) {\n        return attrs[i + 1] as string;\n      }\n    }\n  }\n  return null;\n}\n\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nexport function getOrCreateInjectable<T>(\n    tNode: TElementNode | TContainerNode | TElementContainerNode | null, lView: LView,\n    token: Type<T>| InjectionToken<T>, flags: InjectFlags = InjectFlags.Default,\n    notFoundValue?: any): T|null {\n  if (tNode) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n      const savePreviousOrParentTNode = getPreviousOrParentTNode();\n      const saveLView = getLView();\n      setTNodeAndViewData(tNode, lView);\n      try {\n        const value = bloomHash();\n        if (value == null && !(flags & InjectFlags.Optional)) {\n          throw new Error(`No provider for ${stringify(token)}!`);\n        } else {\n          return value;\n        }\n      } finally {\n        setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\n      }\n    } else if (typeof bloomHash == 'number') {\n      // If the token has a bloom hash, then it is a token which could be in NodeInjector.\n\n      // A reference to the previous injector TView that was found while climbing the element\n      // injector tree. This is used to know if viewProviders can be accessed on the current\n      // injector.\n      let previousTView: TView|null = null;\n      let injectorIndex = getInjectorIndex(tNode, lView);\n      let parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;\n      let hostTElementNode: TNode|null =\n          flags & InjectFlags.Host ? findComponentView(lView)[HOST_NODE] : null;\n\n      // If we should skip this injector, or if there is no injector on this node, start by\n      // searching\n      // the parent injector.\n      if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n        parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                                                lView[injectorIndex + PARENT_INJECTOR];\n\n        if (!shouldSearchParent(flags, false)) {\n          injectorIndex = -1;\n        } else {\n          previousTView = lView[TVIEW];\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        }\n      }\n\n      // Traverse up the injector tree until we find a potential match or until we know there\n      // *isn't* a match.\n      while (injectorIndex !== -1) {\n        parentLocation = lView[injectorIndex + PARENT_INJECTOR];\n\n        // Check the current injector. If it matches, see if it contains token.\n        const tView = lView[TVIEW];\n        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n          // At this point, we have an injector which *may* contain the token, so we step through\n          // the providers and directives associated with the injector's corresponding node to get\n          // the instance.\n          const instance: T|null = searchTokensOnInjector<T>(\n              injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n          if (instance !== NOT_FOUND) {\n            return instance;\n          }\n        }\n        if (shouldSearchParent(\n                flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) &&\n            bloomHasToken(bloomHash, injectorIndex, lView)) {\n          // The def wasn't found anywhere on this node, so it was a false positive.\n          // Traverse up the tree and continue searching.\n          previousTView = tView;\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        } else {\n          // If we should not search parent OR If the ancestor bloom filter value does not have the\n          // bit corresponding to the directive we can give up on traversing up to find the specific\n          // injector.\n          injectorIndex = -1;\n        }\n      }\n    }\n  }\n\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    if (moduleInjector) {\n      return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n    } else {\n      return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n    }\n  }\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throw new Error(`NodeInjector: NOT_FOUND [${stringify(token)}]`);\n  }\n}\n\nconst NOT_FOUND = {};\n\nfunction searchTokensOnInjector<T>(\n    injectorIndex: number, lView: LView, token: Type<T>| InjectionToken<T>,\n    previousTView: TView | null, flags: InjectFlags, hostTElementNode: TNode | null) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + TNODE] as TNode;\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibities\n  const canAccessViewProviders = previousTView == null ?\n      // 1) This is the first invocation `previousTView == null` which means that we are at the\n      // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n      // to look into the ViewProviders is if:\n      // - we are on a component\n      // - AND the injector set `includeViewProviders` to true (implying that the token can see\n      // ViewProviders because it is the Component or a Service which itself was declared in\n      // ViewProviders)\n      (isComponent(tNode) && includeViewProviders) :\n      // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n      // In such a case we are only allowed to look into the ViewProviders if:\n      // - We just crossed from child View to Parent View `previousTView != currentTView`\n      // - AND the parent TNode is an Element.\n      // This means that we just came from the Component's View and therefore are allowed to see\n      // into the ViewProviders.\n      (previousTView != currentTView && (tNode.type === TNodeType.Element));\n\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n\n  const injectableIdx =\n      locateDirectiveOrProvider(tNode, lView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(currentTView.data, lView, injectableIdx, tNode as TElementNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param lView The view we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n    tNode: TNode, lView: LView, token: Type<T>| InjectionToken<T>, canAccessViewProviders: boolean,\n    isHostSpecialCase: boolean | number): number|null {\n  const tView = lView[TVIEW];\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const injectablesStart = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount =\n      nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex =\n      canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i] as InjectionToken<any>| Type<any>| DirectiveDef<any>;\n    if (i < directivesStart && token === providerTokenOrDef ||\n        i >= directivesStart && (providerTokenOrDef as DirectiveDef<any>).type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart] as DirectiveDef<any>;\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n\n/**\n* Retrieve or instantiate the injectable from the `lData` at particular `index`.\n*\n* This function checks to see if the value has already been instantiated and if so returns the\n* cached `injectable`. Otherwise if it detects that the value is still a factory it\n* instantiates the `injectable` and caches the value.\n*/\nexport function getNodeInjectable(\n    tData: TData, lData: LView, index: number, tNode: TElementNode): any {\n  let value = lData[index];\n  if (isFactory(value)) {\n    const factory: NodeInjectorFactory = value;\n    if (factory.resolving) {\n      throw new Error(`Circular dep for ${stringify(tData[index])}`);\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let previousInjectImplementation;\n    if (factory.injectImpl) {\n      previousInjectImplementation = setInjectImplementation(factory.injectImpl);\n    }\n    const savePreviousOrParentTNode = getPreviousOrParentTNode();\n    const saveLView = getLView();\n    setTNodeAndViewData(tNode, lData);\n    try {\n      value = lData[index] = factory.factory(null, tData, lData, tNode);\n    } finally {\n      if (factory.injectImpl) setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n */\nexport function bloomHashBitOrFactory(token: Type<any>| InjectionToken<any>| string): number|\n    Function|undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n  return typeof tokenId === 'number' ? tokenId & BLOOM_MASK : tokenId;\n}\n\nexport function bloomHasToken(\n    bloomHash: number, injectorIndex: number, injectorView: LView | TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags: InjectFlags, isFirstHostTNode: boolean): boolean|number {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\n\nexport function injectInjector() {\n  const tNode = getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode;\n  return new NodeInjector(tNode, getLView());\n}\n\nexport class NodeInjector implements Injector {\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode|null,\n      private _lView: LView) {}\n\n  get(token: any, notFoundValue?: any): any {\n    return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\n  }\n}\n\nexport function getFactoryOf<T>(type: Type<any>): ((type: Type<T>| null) => T)|null {\n  const typeAny = type as any;\n  const def = getComponentDef<T>(typeAny) || getDirectiveDef<T>(typeAny) ||\n      getPipeDef<T>(typeAny) || getInjectableDef<T>(typeAny) || getInjectorDef<T>(typeAny);\n  if (!def || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n\nexport function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = getFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\nimport {assertDomNode} from './assert';\nimport {EMPTY_ARRAY} from './empty';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, HOST, LView, TVIEW} from './interfaces/view';\nimport {getComponentViewByIndex, getNativeByTNode, readElementValue, readPatchedData} from './util';\n\n\n\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport function getLContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lView: LView = mpValue !;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = readElementValue(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lView, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomNode(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lView: LView|null;\n        if (Array.isArray(parentContext)) {\n          lView = parentContext as LView;\n        } else {\n          lView = parentContext.lView;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = readElementValue(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView: LView, nodeIndex: number, native: RElement): LContext {\n  return {\n    lView,\n    nodeIndex,\n    native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LView {\n  let lView = readPatchedData(componentInstance);\n  let view: LView;\n\n  if (Array.isArray(lView)) {\n    const nodeIndex = findViaComponent(lView, componentInstance);\n    view = getComponentViewByIndex(nodeIndex, lView);\n    const context = createLContext(lView, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lView as any as LContext;\n    view = getComponentViewByIndex(context.nodeIndex, context.lView);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LView | LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngComponentDef;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngDirectiveDef;\n}\n\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView: LView, target: RElement): number {\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const native = getNativeByTNode(tNode, lView) !;\n    if (native === target) {\n      return tNode.index;\n    }\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView: LView, componentInstance: {}): number {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView: LView, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function getDirectivesAtNodeIndex(\n    nodeIndex: number, lView: LView, includeComponents: boolean): any[]|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = tNode.directiveEnd;\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponent) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nexport function getComponentAtNodeIndex(nodeIndex: number, lView: LView): {}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  return tNode.flags & TNodeFlags.isComponent ? lView[directiveStartIndex] : null;\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lView: LView, nodeIndex: number): {[key: string]: any}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      const localRefName = tNode.localNames[i];\n      const directiveIndex = tNode.localNames[i + 1] as number;\n      result[localRefName] =\n          directiveIndex === -1 ? getNativeByTNode(tNode, lView) ! : lView[directiveIndex];\n    }\n    return result;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function normalizeDebugBindingName(name: string) {\n  // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n  return `ng-reflect-${name}`;\n}\n\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\n\nfunction camelCaseToDashCase(input: string): string {\n  return input.replace(CAMEL_CASE_REGEXP, (...m: any[]) => '-' + m[1].toLowerCase());\n}\n\nexport function normalizeDebugBindingValue(value: any): string {\n  try {\n    // Limit the size of the value as otherwise the DOM just gets polluted.\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return '[ERROR] Exception while trying to serialize the value';\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getSymbolIterator, looseIdentical} from '../util';\n\nexport function devModeEqual(a: any, b: any): boolean {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return looseIdentical(a, b);\n    }\n  }\n}\n\n/**\n * Indicates that the result of a {@link Pipe} transformation has changed even though the\n * reference has not changed.\n *\n * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\n * is stored.\n *\n * Example:\n *\n * ```\n * if (this._latestValue === this._latestReturnedValue) {\n *    return this._latestReturnedValue;\n *  } else {\n *    this._latestReturnedValue = this._latestValue;\n *    return WrappedValue.wrap(this._latestValue); // this will force update\n *  }\n * ```\n *\n * @publicApi\n */\nexport class WrappedValue {\n  /** @deprecated from 5.3, use `unwrap()` instead - will switch to protected */\n  wrapped: any;\n\n  constructor(value: any) { this.wrapped = value; }\n\n  /** Creates a wrapped value. */\n  static wrap(value: any): WrappedValue { return new WrappedValue(value); }\n\n  /**\n   * Returns the underlying value of a wrapped value.\n   * Returns the given `value` when it is not wrapped.\n   **/\n  static unwrap(value: any): any { return WrappedValue.isWrapped(value) ? value.wrapped : value; }\n\n  /** Returns true if `value` is a wrapped value. */\n  static isWrapped(value: any): value is WrappedValue { return value instanceof WrappedValue; }\n}\n\n/**\n * Represents a basic change from a previous to a new value.\n *\n * @publicApi\n */\nexport class SimpleChange {\n  constructor(public previousValue: any, public currentValue: any, public firstChange: boolean) {}\n\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange(): boolean { return this.firstChange; }\n}\n\nexport function isListLikeIterable(obj: any): boolean {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) ||\n      (!(obj instanceof Map) &&      // JS Map are iterables but return entries as [k, v]\n       getSymbolIterator() in obj);  // JS Iterable have a Symbol.iterator prop\n}\n\nexport function areIterablesEqual(\n    a: any, b: any, comparator: (a: any, b: any) => boolean): boolean {\n  const iterator1 = a[getSymbolIterator()]();\n  const iterator2 = b[getSymbolIterator()]();\n\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\n\nexport function iterateListLike(obj: any, fn: (p: any) => any) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[getSymbolIterator()]();\n    let item: any;\n    while (!((item = iterator.next()).done)) {\n      fn(item.value);\n    }\n  }\n}\n\nexport function isJsObject(o: any): boolean {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and than\n * use that time for rendering.\n *\n * At runtime we can than use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n\nimport {RendererStyleFlags2, RendererType2} from '../../render/api';\n\n\n// TODO: cleanup once the code is merged in angular/angular\nexport enum RendererStyleFlags3 {\n  Important = 1 << 0,\n  DashCase = 1 << 1\n}\n\nexport type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;\n\n/**\n * Object Oriented style of API needed to create elements and text nodes.\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade\n * (reducing payload size).\n * */\nexport interface ObjectOrientedRenderer3 {\n  createComment(data: string): RComment;\n  createElement(tagName: string): RElement;\n  createElementNS(namespace: string, tagName: string): RElement;\n  createTextNode(data: string): RText;\n\n  querySelector(selectors: string): RElement|null;\n}\n\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nexport function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3):\n    renderer is ProceduralRenderer3 {\n  return !!((renderer as any).listen);\n}\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. This also facilitates backwards compatibility\n * with Renderer2.\n */\nexport interface ProceduralRenderer3 {\n  destroy(): void;\n  createComment(value: string): RComment;\n  createElement(name: string, namespace?: string|null): RElement;\n  createText(value: string): RText;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode?: ((node: RNode) => void)|null;\n  appendChild(parent: RElement, newChild: RNode): void;\n  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null): void;\n  removeChild(parent: RElement, oldChild: RNode): void;\n  selectRootElement(selectorOrNode: string|any): RElement;\n\n  parentNode(node: RNode): RElement|null;\n  nextSibling(node: RNode): RNode|null;\n\n  setAttribute(el: RElement, name: string, value: string, namespace?: string|null): void;\n  removeAttribute(el: RElement, name: string, namespace?: string|null): void;\n  addClass(el: RElement, name: string): void;\n  removeClass(el: RElement, name: string): void;\n  setStyle(\n      el: RElement, style: string, value: any,\n      flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  setProperty(el: RElement, name: string, value: any): void;\n  setValue(node: RText|RComment, value: string): void;\n\n  // TODO(misko): Deprecate in favor of addEventListener/removeEventListener\n  listen(target: RNode, eventName: string, callback: (event: any) => boolean | void): () => void;\n}\n\nexport interface RendererFactory3 {\n  createRenderer(hostElement: RElement|null, rendererType: RendererType2|null): Renderer3;\n  begin?(): void;\n  end?(): void;\n}\n\nexport const domRendererFactory3: RendererFactory3 = {\n  createRenderer: (hostElement: RElement | null, rendererType: RendererType2 | null):\n                      Renderer3 => { return document;}\n};\n\n/** Subset of API needed for appending elements and text nodes. */\nexport interface RNode {\n  parentNode: RNode|null;\n\n  nextSibling: RNode|null;\n\n  removeChild(oldChild: RNode): void;\n\n  /**\n   * Insert a child node.\n   *\n   * Used exclusively for adding View root nodes into ViewAnchor location.\n   */\n  insertBefore(newChild: RNode, refChild: RNode|null, isViewRoot: boolean): void;\n\n  /**\n   * Append a child node.\n   *\n   * Used exclusively for building up DOM which are static (ie not View roots)\n   */\n  appendChild(newChild: RNode): RNode;\n}\n\n/**\n * Subset of API needed for writing attributes, properties, and setting up\n * listeners on Element.\n */\nexport interface RElement extends RNode {\n  style: RCssStyleDeclaration;\n  classList: RDomTokenList;\n  className: string;\n  setAttribute(name: string, value: string): void;\n  removeAttribute(name: string): void;\n  setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\n  addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\n  removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\n\n  setProperty?(name: string, value: any): void;\n}\n\nexport interface RCssStyleDeclaration {\n  removeProperty(propertyName: string): string;\n  setProperty(propertyName: string, value: string|null, priority?: string): void;\n}\n\nexport interface RDomTokenList {\n  add(token: string): void;\n  remove(token: string): void;\n}\n\nexport interface RText extends RNode { textContent: string|null; }\n\nexport interface RComment extends RNode { textContent: string|null; }\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {callHooks} from './hooks';\nimport {LContainer, NATIVE, RENDER_PARENT, VIEWS, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeType, TViewNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {CLEANUP, CONTAINER_INDEX, FLAGS, HEADER_OFFSET, HOST_NODE, HookData, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeType} from './node_assert';\nimport {findComponentView, getNativeByTNode, isLContainer, isRootView, readElementValue, stringify} from './util';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\n/** Retrieves the parent element of a given node. */\nexport function getParentNative(tNode: TNode, currentView: LView): RElement|RComment|null {\n  if (tNode.parent == null) {\n    return getHostNative(currentView);\n  } else {\n    const parentTNode = getFirstParentNative(tNode);\n    return getNativeByTNode(parentTNode, currentView);\n  }\n}\n\n/**\n * Get the first parent of a node that isn't an IcuContainer TNode\n */\nfunction getFirstParentNative(tNode: TNode): TNode {\n  let parent = tNode.parent;\n  while (parent && parent.type === TNodeType.IcuContainer) {\n    parent = parent.parent;\n  }\n  return parent !;\n}\n\n/**\n * Gets the host element given a view. Will return null if the current view is an embedded view,\n * which does not have a host element.\n */\nexport function getHostNative(currentView: LView): RElement|null {\n  const hostTNode = currentView[HOST_NODE] as TElementNode;\n  return hostTNode && hostTNode.type !== TNodeType.View ?\n      (getNativeByTNode(hostTNode, currentView[PARENT] !) as RElement) :\n      null;\n}\n\nexport function getLContainer(tNode: TViewNode, embeddedView: LView): LContainer|null {\n  if (tNode.index === -1) {\n    // This is a dynamically created view inside a dynamic container.\n    // If the host index is -1, the view has not yet been inserted, so it has no parent.\n    const containerHostIndex = embeddedView[CONTAINER_INDEX];\n    return containerHostIndex > -1 ? embeddedView[PARENT] ![containerHostIndex] : null;\n  } else {\n    // This is a inline view node (e.g. embeddedViewStart)\n    return embeddedView[PARENT] ![tNode.parent !.index] as LContainer;\n  }\n}\n\n\n/**\n * Retrieves render parent for a given view.\n * Might be null if a view is not yet attached to any container.\n */\nexport function getContainerRenderParent(tViewNode: TViewNode, view: LView): RElement|null {\n  const container = getLContainer(tViewNode, view);\n  return container ? container[RENDER_PARENT] : null;\n}\n\nconst enum WalkTNodeTreeAction {\n  /** node insert in the native environment */\n  Insert = 0,\n\n  /** node detach from the native environment */\n  Detach = 1,\n\n  /** node destruction using the renderer's API */\n  Destroy = 2,\n}\n\n\n/**\n * Stack used to keep track of projection nodes in walkTNodeTree.\n *\n * This is deliberately created outside of walkTNodeTree to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LView | TNode)[] = [];\n\n/**\n * Walks a tree of TNodes, applying a transformation on the element nodes, either only on the first\n * one found, or on all of them.\n *\n * @param viewToWalk the view to walk\n * @param action identifies the action to be performed on the elements\n * @param renderer the current renderer.\n * @param renderParent Optional the render parent node to be set in all LContainers found,\n * required for action modes Insert and Destroy.\n * @param beforeNode Optional the node before which elements should be added, required for action\n * Insert.\n */\nfunction walkTNodeTree(\n    viewToWalk: LView, action: WalkTNodeTreeAction, renderer: Renderer3,\n    renderParent: RElement | null, beforeNode?: RNode | null) {\n  const rootTNode = viewToWalk[TVIEW].node as TViewNode;\n  let projectionNodeIndex = -1;\n  let currentView = viewToWalk;\n  let tNode: TNode|null = rootTNode.child as TNode;\n  while (tNode) {\n    let nextTNode: TNode|null = null;\n    if (tNode.type === TNodeType.Element) {\n      executeNodeAction(\n          action, renderer, renderParent, getNativeByTNode(tNode, currentView), beforeNode);\n      const nodeOrContainer = currentView[tNode.index];\n      if (isLContainer(nodeOrContainer)) {\n        // This element has an LContainer, and its comment needs to be handled\n        executeNodeAction(action, renderer, renderParent, nodeOrContainer[NATIVE], beforeNode);\n      }\n    } else if (tNode.type === TNodeType.Container) {\n      const lContainer = currentView ![tNode.index] as LContainer;\n      executeNodeAction(action, renderer, renderParent, lContainer[NATIVE], beforeNode);\n\n      if (renderParent) lContainer[RENDER_PARENT] = renderParent;\n\n      if (lContainer[VIEWS].length) {\n        currentView = lContainer[VIEWS][0];\n        nextTNode = currentView[TVIEW].node;\n\n        // When the walker enters a container, then the beforeNode has to become the local native\n        // comment node.\n        beforeNode = lContainer[NATIVE];\n      }\n    } else if (tNode.type === TNodeType.Projection) {\n      const componentView = findComponentView(currentView !);\n      const componentHost = componentView[HOST_NODE] as TElementNode;\n      const head: TNode|null =\n          (componentHost.projection as(TNode | null)[])[tNode.projection as number];\n\n      // Must store both the TNode and the view because this projection node could be nested\n      // deeply inside embedded views, and we need to get back down to this particular nested view.\n      projectionNodeStack[++projectionNodeIndex] = tNode;\n      projectionNodeStack[++projectionNodeIndex] = currentView !;\n      if (head) {\n        currentView = componentView[PARENT] !;\n        nextTNode = currentView[TVIEW].data[head.index] as TNode;\n      }\n    } else {\n      // Otherwise, this is a View or an ElementContainer\n      nextTNode = tNode.child;\n    }\n\n    if (nextTNode === null) {\n      // this last node was projected, we need to get back down to its projection node\n      if (tNode.next === null && (tNode.flags & TNodeFlags.isProjected)) {\n        currentView = projectionNodeStack[projectionNodeIndex--] as LView;\n        tNode = projectionNodeStack[projectionNodeIndex--] as TNode;\n      }\n      nextTNode = tNode.next;\n\n      /**\n       * Find the next node in the TNode tree, taking into account the place where a node is\n       * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n       *\n       * If there is no sibling node, then it goes to the next sibling of the parent node...\n       * until it reaches rootNode (at which point null is returned).\n       */\n      while (!nextTNode) {\n        // If parent is null, we're crossing the view boundary, so we should get the host TNode.\n        tNode = tNode.parent || currentView[TVIEW].node;\n\n        if (tNode === null || tNode === rootTNode) return null;\n\n        // When exiting a container, the beforeNode must be restored to the previous value\n        if (tNode.type === TNodeType.Container) {\n          currentView = currentView[PARENT] !;\n          beforeNode = currentView[tNode.index][NATIVE];\n        }\n\n        if (tNode.type === TNodeType.View && currentView[NEXT]) {\n          currentView = currentView[NEXT] as LView;\n          nextTNode = currentView[TVIEW].node;\n        } else {\n          nextTNode = tNode.next;\n        }\n      }\n    }\n    tNode = nextTNode;\n  }\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction executeNodeAction(\n    action: WalkTNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    node: RComment | RElement | RText, beforeNode?: RNode | null) {\n  if (action === WalkTNodeTreeAction.Insert) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).insertBefore(parent !, node, beforeNode as RNode | null) :\n        parent !.insertBefore(node, beforeNode as RNode | null, true);\n  } else if (action === WalkTNodeTreeAction.Detach) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).removeChild(parent !, node) :\n        parent !.removeChild(node);\n  } else if (action === WalkTNodeTreeAction.Destroy) {\n    ngDevMode && ngDevMode.rendererDestroyNode++;\n    (renderer as ProceduralRenderer3).destroyNode !(node);\n  }\n}\n\nexport function createTextNode(value: any, renderer: Renderer3): RText {\n  return isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                          renderer.createTextNode(stringify(value));\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param viewToWalk The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    viewToWalk: LView, insertMode: true, beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(viewToWalk: LView, insertMode: false): void;\nexport function addRemoveViewFromContainer(\n    viewToWalk: LView, insertMode: boolean, beforeNode?: RNode | null): void {\n  const renderParent = getContainerRenderParent(viewToWalk[TVIEW].node as TViewNode, viewToWalk);\n  ngDevMode && assertNodeType(viewToWalk[TVIEW].node as TNode, TNodeType.View);\n  if (renderParent) {\n    const renderer = viewToWalk[RENDERER];\n    walkTNodeTree(\n        viewToWalk, insertMode ? WalkTNodeTreeAction.Insert : WalkTNodeTreeAction.Detach, renderer,\n        renderParent, beforeNode);\n  }\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  if (rootView[TVIEW].childIndex === -1) {\n    return cleanUpView(rootView);\n  }\n  let viewOrContainer: LView|LContainer|null = getLViewChild(rootView);\n\n  while (viewOrContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (viewOrContainer.length >= HEADER_OFFSET) {\n      // If LView, traverse down to child.\n      const view = viewOrContainer as LView;\n      if (view[TVIEW].childIndex > -1) next = getLViewChild(view);\n    } else {\n      // If container, traverse down to its first LView.\n      const container = viewOrContainer as LContainer;\n      if (container[VIEWS].length) next = container[VIEWS][0];\n    }\n\n    if (next == null) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (viewOrContainer && !viewOrContainer ![NEXT] && viewOrContainer !== rootView) {\n        cleanUpView(viewOrContainer);\n        viewOrContainer = getParentState(viewOrContainer, rootView);\n      }\n      cleanUpView(viewOrContainer || rootView);\n      next = viewOrContainer && viewOrContainer ![NEXT];\n    }\n    viewOrContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param parentView The new parent of the inserted view\n * @param index The index at which to insert the view\n * @param containerIndex The index of the container node, if dynamic\n */\nexport function insertView(\n    lView: LView, lContainer: LContainer, parentView: LView, index: number,\n    containerIndex: number) {\n  const views = lContainer[VIEWS];\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    views[index - 1][NEXT] = lView;\n  }\n\n  if (index < views.length) {\n    lView[NEXT] = views[index];\n    views.splice(index, 0, lView);\n  } else {\n    views.push(lView);\n    lView[NEXT] = null;\n  }\n\n  // Dynamically inserted views need a reference to their parent container's host so it's\n  // possible to jump from a view to its container's next when walking the node tree.\n  if (containerIndex > -1) {\n    lView[CONTAINER_INDEX] = containerIndex;\n    lView[PARENT] = parentView;\n  }\n\n  // Notify query that a new view has been added\n  if (lView[QUERIES]) {\n    lView[QUERIES] !.insertView(index);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @param detached Whether or not this view is already detached.\n * @returns Detached LView instance.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number, detached: boolean): LView {\n  const views = lContainer[VIEWS];\n  const viewToDetach = views[removeIndex];\n  if (removeIndex > 0) {\n    views[removeIndex - 1][NEXT] = viewToDetach[NEXT] as LView;\n  }\n  views.splice(removeIndex, 1);\n  if (!detached) {\n    addRemoveViewFromContainer(viewToDetach, false);\n  }\n\n  if (viewToDetach[QUERIES]) {\n    viewToDetach[QUERIES] !.removeView();\n  }\n  viewToDetach[CONTAINER_INDEX] = -1;\n  viewToDetach[PARENT] = null;\n  // Unsets the attached flag\n  viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n  return viewToDetach;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param lContainer The container from which to remove a view\n * @param tContainer The TContainer node associated with the LContainer\n * @param removeIndex The index of the view to remove\n */\nexport function removeView(\n    lContainer: LContainer, containerHost: TElementNode | TContainerNode | TElementContainerNode,\n    removeIndex: number) {\n  const view = lContainer[VIEWS][removeIndex];\n  detachView(lContainer, removeIndex, !!containerHost.detached);\n  destroyLView(view);\n}\n\n/** Gets the child of the given LView */\nexport function getLViewChild(lView: LView): LView|LContainer|null {\n  const childIndex = lView[TVIEW].childIndex;\n  return childIndex === -1 ? null : lView[childIndex];\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param view The view to be destroyed.\n */\nexport function destroyLView(view: LView) {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n    walkTNodeTree(view, WalkTNodeTreeAction.Destroy, renderer, null);\n  }\n  destroyViewTree(view);\n  // Sets the destroyed flag\n  view[FLAGS] |= LViewFlags.Destroyed;\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(state: LView | LContainer, rootView: LView): LView|LContainer|null {\n  let tNode;\n  if (state.length >= HEADER_OFFSET && (tNode = (state as LView) ![HOST_NODE]) &&\n      tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getLContainer(tNode as TViewNode, state as LView) as LContainer;\n  } else {\n    // otherwise, use parent view for containers or component views\n    return state[PARENT] === rootView ? null : state[PARENT];\n  }\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param view The LView to clean up\n */\nfunction cleanUpView(viewOrContainer: LView | LContainer): void {\n  if ((viewOrContainer as LView).length >= HEADER_OFFSET) {\n    const view = viewOrContainer as LView;\n    executeOnDestroys(view);\n    executePipeOnDestroys(view);\n    removeListeners(view);\n    const hostTNode = view[HOST_NODE];\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (hostTNode && hostTNode.type === TNodeType.Element && isProceduralRenderer(view[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (view[RENDERER] as ProceduralRenderer3).destroy();\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(lView: LView): void {\n  const tCleanup = lView[TVIEW].cleanup !;\n  if (tCleanup != null) {\n    const lCleanup = lView[CLEANUP] !;\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a listener with the native renderer\n        const idx = tCleanup[i + 1];\n        const listener = lCleanup[tCleanup[i + 2]];\n        const native = readElementValue(lView[idx]);\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // DOM listener\n          native.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[-useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n        i += 2;\n      } else if (typeof tCleanup[i] === 'number') {\n        // This is a listener with renderer2 (cleanup fn can be found by index)\n        const cleanupFn = lCleanup[tCleanup[i]];\n        cleanupFn();\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LView): void {\n  const tView = view[TVIEW];\n  let destroyHooks: HookData|null;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    callHooks(view, destroyHooks);\n  }\n}\n\n/** Calls pipe destroy hooks for this view */\nfunction executePipeOnDestroys(lView: LView): void {\n  const pipeDestroyHooks = lView[TVIEW] && lView[TVIEW].pipeDestroyHooks;\n  if (pipeDestroyHooks) {\n    callHooks(lView !, pipeDestroyHooks);\n  }\n}\n\nexport function getRenderParent(tNode: TNode, currentView: LView): RElement|null {\n  if (canInsertNativeNode(tNode, currentView)) {\n    // If we are asked for a render parent of the root component we need to do low-level DOM\n    // operation as LTree doesn't exist above the topmost host node. We might need to find a render\n    // parent of the topmost host node if the root component injects ViewContainerRef.\n    if (isRootView(currentView)) {\n      return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));\n    }\n\n    const hostTNode = currentView[HOST_NODE];\n\n    const tNodeParent = tNode.parent;\n    if (tNodeParent != null && tNodeParent.type === TNodeType.ElementContainer) {\n      tNode = getHighestElementContainer(tNodeParent);\n    }\n\n    return tNode.parent == null && hostTNode !.type === TNodeType.View ?\n        getContainerRenderParent(hostTNode as TViewNode, currentView) :\n        getParentNative(tNode, currentView) as RElement;\n  }\n  return null;\n}\n\nfunction canInsertNativeChildOfElement(tNode: TNode): boolean {\n  // If the parent is null, then we are inserting across views. This happens when we\n  // insert a root element of the component view into the component host element and it\n  // should always be eager.\n  if (tNode.parent == null ||\n      // We should also eagerly insert if the parent is a regular, non-component element\n      // since we know that this relationship will never be broken.\n      tNode.parent.type === TNodeType.Element && !(tNode.parent.flags & TNodeFlags.isComponent)) {\n    return true;\n  }\n\n  // Parent is a Component. Component's content nodes are not inserted immediately\n  // because they will be projected, and so doing insert at this point would be wasteful.\n  // Since the projection would than move it to its final destination.\n  return false;\n}\n\n/**\n * We might delay insertion of children for a given view if it is disconnected.\n * This might happen for 2 main reasons:\n * - view is not inserted into any container (view was created but not inserted yet)\n * - view is inserted into a container but the container itself is not inserted into the DOM\n * (container might be part of projection or child of a view that is not inserted yet).\n *\n * In other words we can insert children of a given view if this view was inserted into a container\n * and\n * the container itself has its render parent determined.\n */\nfunction canInsertNativeChildOfView(viewTNode: TViewNode, view: LView): boolean {\n  // Because we are inserting into a `View` the `View` may be disconnected.\n  const container = getLContainer(viewTNode, view) !;\n  if (container == null || container[RENDER_PARENT] == null) {\n    // The `View` is not inserted into a `Container` or the parent `Container`\n    // itself is disconnected. So we have to delay.\n    return false;\n  }\n\n  // The parent `Container` is in inserted state, so we can eagerly insert into\n  // this location.\n  return true;\n}\n\n/**\n * Returns whether a native element can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is mare for projection but has not been inserted\n *   into destination.\n *\n\n *\n * @param tNode The tNode of the node that we want to insert.\n * @param currentView Current LView being processed.\n * @return boolean Whether the node should be inserted now (or delayed until later).\n */\nexport function canInsertNativeNode(tNode: TNode, currentView: LView): boolean {\n  let currentNode = tNode;\n  let parent: TNode|null = tNode.parent;\n\n  if (tNode.parent) {\n    if (tNode.parent.type === TNodeType.ElementContainer) {\n      currentNode = getHighestElementContainer(tNode);\n      parent = currentNode.parent;\n    } else if (tNode.parent.type === TNodeType.IcuContainer) {\n      currentNode = getFirstParentNative(currentNode);\n      parent = currentNode.parent;\n    }\n  }\n  if (parent === null) parent = currentView[HOST_NODE];\n\n  if (parent && parent.type === TNodeType.View) {\n    return canInsertNativeChildOfView(parent as TViewNode, currentView);\n  } else {\n    // Parent is a regular element or a component\n    return canInsertNativeChildOfElement(currentNode);\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nexport function nativeInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null): void {\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode);\n  } else {\n    parent.insertBefore(child, beforeNode, true);\n  }\n}\n\n/**\n * Returns a native parent of a given native node.\n */\nexport function nativeParentNode(renderer: Renderer3, node: RNode): RElement|null {\n  return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode) as RElement;\n}\n\n/**\n * Returns a native sibling of a given native node.\n */\nexport function nativeNextSibling(renderer: Renderer3, node: RNode): RNode|null {\n  return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param childEl The child that should be appended\n * @param childTNode The TNode of the child element\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(\n    childEl: RNode | null = null, childTNode: TNode, currentView: LView): boolean {\n  if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\n    const renderer = currentView[RENDERER];\n    const parentEl = getParentNative(childTNode, currentView);\n    const parentTNode: TNode = childTNode.parent || currentView[HOST_NODE] !;\n\n    if (parentTNode.type === TNodeType.View) {\n      const lContainer = getLContainer(parentTNode as TViewNode, currentView) as LContainer;\n      const views = lContainer[VIEWS];\n      const index = views.indexOf(currentView);\n      nativeInsertBefore(\n          renderer, lContainer[RENDER_PARENT] !, childEl,\n          getBeforeNodeForView(index, views, lContainer[NATIVE]));\n    } else if (parentTNode.type === TNodeType.ElementContainer) {\n      const renderParent = getRenderParent(childTNode, currentView) !;\n      nativeInsertBefore(renderer, renderParent, childEl, parentEl);\n    } else if (parentTNode.type === TNodeType.IcuContainer) {\n      const icuAnchorNode = getNativeByTNode(childTNode.parent !, currentView) !as RElement;\n      nativeInsertBefore(renderer, parentEl as RElement, childEl, icuAnchorNode);\n    } else {\n      isProceduralRenderer(renderer) ? renderer.appendChild(parentEl !as RElement, childEl) :\n                                       parentEl !.appendChild(childEl);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Gets the top-level ng-container if ng-containers are nested.\n *\n * @param ngContainer The TNode of the starting ng-container\n * @returns tNode The TNode of the highest level ng-container\n */\nfunction getHighestElementContainer(ngContainer: TNode): TNode {\n  while (ngContainer.parent != null && ngContainer.parent.type === TNodeType.ElementContainer) {\n    ngContainer = ngContainer.parent;\n  }\n  return ngContainer;\n}\n\nexport function getBeforeNodeForView(index: number, views: LView[], containerNative: RComment) {\n  if (index + 1 < views.length) {\n    const view = views[index + 1] as LView;\n    const viewTNode = view[HOST_NODE] as TViewNode;\n    return viewTNode.child ? getNativeByTNode(viewTNode.child, view) : containerNative;\n  } else {\n    return containerNative;\n  }\n}\n\n/**\n * Removes the `child` element from the DOM if not in view and not projected.\n *\n * @param childTNode The TNode of the child to remove\n * @param childEl The child that should be removed\n * @param currentView The current LView\n * @returns Whether or not the child was removed\n */\nexport function removeChild(childTNode: TNode, childEl: RNode | null, currentView: LView): boolean {\n  // We only remove the element if not in View or not projected.\n  if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\n    const parentNative = getParentNative(childTNode, currentView) !as RElement;\n    const renderer = currentView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.removeChild(parentNative as RElement, childEl) :\n                                     parentNative !.removeChild(childEl);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param projectedTNode The TNode to be projected\n * @param tProjectionNode The projection (ng-content) TNode\n * @param currentView Current LView\n * @param projectionView Projection view (view above current)\n */\nexport function appendProjectedNode(\n    projectedTNode: TNode, tProjectionNode: TNode, currentView: LView,\n    projectionView: LView): void {\n  const native = getNativeByTNode(projectedTNode, projectionView);\n  appendChild(native, tProjectionNode, currentView);\n\n  // the projected contents are processed while in the shadow view (which is the currentView)\n  // therefore we need to extract the view where the host element lives since it's the\n  // logical container of the content projected views\n  attachPatchData(native, projectionView);\n\n  const renderParent = getRenderParent(tProjectionNode, currentView);\n\n  const nodeOrContainer = projectionView[projectedTNode.index];\n  if (projectedTNode.type === TNodeType.Container) {\n    // The node we are adding is a container and we are adding it to an element which\n    // is not a component (no more re-projection).\n    // Alternatively a container is projected at the root of a component's template\n    // and can't be re-projected (as not content of any component).\n    // Assign the final projection location in those cases.\n    nodeOrContainer[RENDER_PARENT] = renderParent;\n    const views = nodeOrContainer[VIEWS];\n    for (let i = 0; i < views.length; i++) {\n      addRemoveViewFromContainer(views[i], true, nodeOrContainer[NATIVE]);\n    }\n  } else {\n    if (projectedTNode.type === TNodeType.ElementContainer) {\n      let ngContainerChildTNode: TNode|null = projectedTNode.child as TNode;\n      while (ngContainerChildTNode) {\n        appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView);\n        ngContainerChildTNode = ngContainerChildTNode.next;\n      }\n    }\n\n    if (isLContainer(nodeOrContainer)) {\n      nodeOrContainer[RENDER_PARENT] = renderParent;\n      appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../ng_dev_mode';\n\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {getLContext} from '../context_discovery';\nimport {LContainer} from '../interfaces/container';\nimport {LContext} from '../interfaces/context';\nimport {AttributeMarker, TAttributes, TNode, TNodeFlags} from '../interfaces/node';\nimport {PlayState, Player, PlayerContext, PlayerIndex} from '../interfaces/player';\nimport {RElement} from '../interfaces/renderer';\nimport {InitialStylingValues, StylingContext, StylingFlags, StylingIndex} from '../interfaces/styling';\nimport {HEADER_OFFSET, HOST, LView, RootContext} from '../interfaces/view';\nimport {getTNode} from '../util';\n\nimport {CorePlayerHandler} from './core_player_handler';\n\nconst ANIMATION_PROP_PREFIX = '@';\n\nexport function createEmptyStylingContext(\n    element?: RElement | null, sanitizer?: StyleSanitizeFn | null,\n    initialStyles?: InitialStylingValues | null,\n    initialClasses?: InitialStylingValues | null): StylingContext {\n  return [\n    0,                                     // MasterFlags\n    [null, -1, false, sanitizer || null],  // DirectiveRefs\n    initialStyles || [null],               // InitialStyles\n    initialClasses || [null],              // InitialClasses\n    [0, 0],                                // SinglePropOffsets\n    element || null,                       // Element\n    null,                                  // PreviousMultiClassValue\n    null,                                  // PreviousMultiStyleValue\n    null,                                  // PlayerContext\n  ];\n}\n\n/**\n * Used clone a copy of a pre-computed template of a styling context.\n *\n * A pre-computed template is designed to be computed once for a given element\n * (instructions.ts has logic for caching this).\n */\nexport function allocStylingContext(\n    element: RElement | null, templateStyleContext: StylingContext): StylingContext {\n  // each instance gets a copy\n  const context = templateStyleContext.slice() as any as StylingContext;\n  context[StylingIndex.ElementPosition] = element;\n\n  // this will prevent any other directives from extending the context\n  context[StylingIndex.MasterFlagPosition] |= StylingFlags.BindingAllocationLocked;\n  return context;\n}\n\n/**\n * Retrieve the `StylingContext` at a given index.\n *\n * This method lazily creates the `StylingContext`. This is because in most cases\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\n * every style declaration such as `<div style=\"color: red\">` would result `StyleContext`\n * which would create unnecessary memory pressure.\n *\n * @param index Index of the style allocation. See: `elementStyling`.\n * @param viewData The view to search for the styling context\n */\nexport function getStylingContext(index: number, viewData: LView): StylingContext {\n  let storageIndex = index;\n  let slotValue: LContainer|LView|StylingContext|RElement = viewData[storageIndex];\n  let wrapper: LContainer|LView|StylingContext = viewData;\n\n  while (Array.isArray(slotValue)) {\n    wrapper = slotValue;\n    slotValue = slotValue[HOST] as LView | StylingContext | RElement;\n  }\n\n  if (isStylingContext(wrapper)) {\n    return wrapper as StylingContext;\n  } else {\n    // This is an LView or an LContainer\n    const stylingTemplate = getTNode(index - HEADER_OFFSET, viewData).stylingTemplate;\n\n    if (wrapper !== viewData) {\n      storageIndex = HOST;\n    }\n\n    return wrapper[storageIndex] = stylingTemplate ?\n        allocStylingContext(slotValue, stylingTemplate) :\n        createEmptyStylingContext(slotValue);\n  }\n}\n\nexport function isStylingContext(value: any): value is StylingContext {\n  // Not an LView or an LContainer\n  return Array.isArray(value) && typeof value[StylingIndex.MasterFlagPosition] === 'number' &&\n      Array.isArray(value[StylingIndex.InitialStyleValuesPosition]);\n}\n\nexport function isAnimationProp(name: string): boolean {\n  return name[0] === ANIMATION_PROP_PREFIX;\n}\n\nexport function addPlayerInternal(\n    playerContext: PlayerContext, rootContext: RootContext, element: HTMLElement,\n    player: Player | null, playerContextIndex: number, ref?: any): boolean {\n  ref = ref || element;\n  if (playerContextIndex) {\n    playerContext[playerContextIndex] = player;\n  } else {\n    playerContext.push(player);\n  }\n\n  if (player) {\n    player.addEventListener(PlayState.Destroyed, () => {\n      const index = playerContext.indexOf(player);\n      const nonFactoryPlayerIndex = playerContext[PlayerIndex.NonBuilderPlayersStart];\n\n      // if the player is being removed from the factory side of the context\n      // (which is where the [style] and [class] bindings do their thing) then\n      // that side of the array cannot be resized since the respective bindings\n      // have pointer index values that point to the associated factory instance\n      if (index) {\n        if (index < nonFactoryPlayerIndex) {\n          playerContext[index] = null;\n        } else {\n          playerContext.splice(index, 1);\n        }\n      }\n      player.destroy();\n    });\n\n    const playerHandler =\n        rootContext.playerHandler || (rootContext.playerHandler = new CorePlayerHandler());\n    playerHandler.queuePlayer(player, ref);\n    return true;\n  }\n\n  return false;\n}\n\nexport function getPlayersInternal(playerContext: PlayerContext): Player[] {\n  const players: Player[] = [];\n  const nonFactoryPlayersStart = playerContext[PlayerIndex.NonBuilderPlayersStart];\n\n  // add all factory-based players (which are apart of [style] and [class] bindings)\n  for (let i = PlayerIndex.PlayerBuildersStartPosition + PlayerIndex.PlayerOffsetPosition;\n       i < nonFactoryPlayersStart; i += PlayerIndex.PlayerAndPlayerBuildersTupleSize) {\n    const player = playerContext[i] as Player | null;\n    if (player) {\n      players.push(player);\n    }\n  }\n\n  // add all custom players (not apart of [style] and [class] bindings)\n  for (let i = nonFactoryPlayersStart; i < playerContext.length; i++) {\n    players.push(playerContext[i] as Player);\n  }\n\n  return players;\n}\n\n\nexport function getOrCreatePlayerContext(target: {}, context?: LContext | null): PlayerContext|\n    null {\n  context = context || getLContext(target) !;\n  if (!context) {\n    ngDevMode && throwInvalidRefError();\n    return null;\n  }\n\n  const {lView, nodeIndex} = context;\n  const stylingContext = getStylingContext(nodeIndex, lView);\n  return getPlayerContext(stylingContext) || allocPlayerContext(stylingContext);\n}\n\nexport function getPlayerContext(stylingContext: StylingContext): PlayerContext|null {\n  return stylingContext[StylingIndex.PlayerContext];\n}\n\nexport function allocPlayerContext(data: StylingContext): PlayerContext {\n  return data[StylingIndex.PlayerContext] =\n             [PlayerIndex.SinglePlayerBuildersStartPosition, null, null, null, null];\n}\n\nexport function throwInvalidRefError() {\n  throw new Error('Only elements that exist in an Angular application can be used for animations');\n}\n\nexport function hasStyling(attrs: TAttributes): boolean {\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    if (attr == AttributeMarker.Classes || attr == AttributeMarker.Styles) return true;\n  }\n  return false;\n}\n\nexport function hasClassInput(tNode: TNode) {\n  return tNode.flags & TNodeFlags.hasClassInput ? true : false;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {resolveForwardRef} from '../di/forward_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectFlags} from '../di/injector_compatibility';\nimport {QueryList} from '../linker';\nimport {Sanitizer} from '../sanitization/security';\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {Type} from '../type';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../util/ng_reflect';\n\nimport {assertDataInRange, assertDefined, assertEqual, assertHasParent, assertLessThan, assertNotEqual, assertPreviousIsParent} from './assert';\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4} from './bindings';\nimport {attachPatchData, getComponentViewByInstance} from './context_discovery';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateInjectable, getOrCreateNodeInjectorForNode, injectAttributeImpl} from './di';\nimport {throwMultipleComponentError} from './errors';\nimport {executeHooks, executeInitHooks, queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {ACTIVE_INDEX, LContainer, VIEWS} from './interfaces/container';\nimport {ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {INJECTOR_BLOOM_PARENT_SIZE, NodeInjectorFactory} from './interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode, TViewNode} from './interfaces/node';\nimport {PlayerFactory} from './interfaces/player';\nimport {CssSelectorList, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {ProceduralRenderer3, RComment, RElement, RText, Renderer3, RendererFactory3, isProceduralRenderer} from './interfaces/renderer';\nimport {SanitizerFn} from './interfaces/sanitization';\nimport {BINDING_INDEX, CLEANUP, CONTAINER_INDEX, CONTENT_QUERIES, CONTEXT, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, INJECTOR, LView, LViewFlags, NEXT, OpaqueViewState, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, TAIL, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {appendChild, appendProjectedNode, createTextNode, getLViewChild, getRenderParent, insertView, removeView} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {decreaseElementDepthCount, enterView, getBindingsEnabled, getCheckNoChangesMode, getContextLView, getCurrentDirectiveDef, getElementDepthCount, getFirstTemplatePass, getIsParent, getLView, getPreviousOrParentTNode, increaseElementDepthCount, isCreationMode, leaveView, nextContextImpl, resetComponentState, setBindingRoot, setCheckNoChangesMode, setCurrentDirectiveDef, setFirstTemplatePass, setIsParent, setPreviousOrParentTNode} from './state';\nimport {getInitialClassNameValue, initializeStaticContext as initializeStaticStylingContext, patchContextWithStaticAttrs, renderInitialStylesAndClasses, renderStyling, updateClassProp as updateElementClassProp, updateContextWithBindings, updateStyleProp as updateElementStyleProp, updateStylingMap} from './styling/class_and_style_bindings';\nimport {BoundPlayerFactory} from './styling/player_factory';\nimport {createEmptyStylingContext, getStylingContext, hasClassInput, hasStyling, isAnimationProp} from './styling/util';\nimport {NO_CHANGE} from './tokens';\nimport {findComponentView, getComponentViewByIndex, getNativeByIndex, getNativeByTNode, getRootContext, getRootView, getTNode, isComponent, isComponentDef, loadInternal, readElementValue, readPatchedLView, stringify} from './util';\n\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings, refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nexport function refreshDescendantViews(lView: LView) {\n  const tView = lView[TVIEW];\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = false;\n  setFirstTemplatePass(false);\n\n  // If this is a creation pass, we should not call lifecycle hooks or evaluate bindings.\n  // This will be done in the update pass.\n  if (!isCreationMode(lView)) {\n    const checkNoChangesMode = getCheckNoChangesMode();\n\n    executeInitHooks(lView, tView, checkNoChangesMode);\n\n    refreshDynamicEmbeddedViews(lView);\n\n    // Content query results must be refreshed before content hooks are called.\n    refreshContentQueries(tView);\n\n    executeHooks(lView, tView.contentHooks, tView.contentCheckHooks, checkNoChangesMode);\n\n    setHostBindings(tView, lView);\n  }\n\n  refreshChildComponents(tView.components);\n}\n\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(tView: TView, viewData: LView): void {\n  if (tView.expandoInstructions) {\n    let bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;\n    setBindingRoot(bindingRootIndex);\n    let currentDirectiveIndex = -1;\n    let currentElementIndex = -1;\n    for (let i = 0; i < tView.expandoInstructions.length; i++) {\n      const instruction = tView.expandoInstructions[i];\n      if (typeof instruction === 'number') {\n        if (instruction <= 0) {\n          // Negative numbers mean that we are starting new EXPANDO block and need to update\n          // the current element and directive index.\n          currentElementIndex = -instruction;\n          // Injector block and providers are taken into account.\n          const providerCount = (tView.expandoInstructions[++i] as number);\n          bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;\n\n          currentDirectiveIndex = bindingRootIndex;\n        } else {\n          // This is either the injector size (so the binding root can skip over directives\n          // and get to the first set of host bindings on this node) or the host var count\n          // (to get to the next set of host bindings on this node).\n          bindingRootIndex += instruction;\n        }\n        setBindingRoot(bindingRootIndex);\n      } else {\n        // If it's not a number, it's a host binding function that needs to be executed.\n        if (instruction !== null) {\n          viewData[BINDING_INDEX] = bindingRootIndex;\n          instruction(\n              RenderFlags.Update, readElementValue(viewData[currentDirectiveIndex]),\n              currentElementIndex);\n        }\n        currentDirectiveIndex++;\n      }\n    }\n  }\n}\n\n/** Refreshes content queries for all directives in the given view. */\nfunction refreshContentQueries(tView: TView): void {\n  if (tView.contentQueries != null) {\n    for (let i = 0; i < tView.contentQueries.length; i += 2) {\n      const directiveDefIdx = tView.contentQueries[i];\n      const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n\n      directiveDef.contentQueriesRefresh !(\n          directiveDefIdx - HEADER_OFFSET, tView.contentQueries[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(components: number[] | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i++) {\n      componentRefresh(components[i]);\n    }\n  }\n}\n\nexport function createLView<T>(\n    parentLView: LView | null, tView: TView, context: T | null, flags: LViewFlags,\n    rendererFactory?: RendererFactory3 | null, renderer?: Renderer3 | null,\n    sanitizer?: Sanitizer | null, injector?: Injector | null): LView {\n  const lView = tView.blueprint.slice() as LView;\n  lView[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.RunInit |\n      LViewFlags.FirstLViewPass;\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]) !;\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]) !;\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null !;\n  lView[INJECTOR as any] = injector || parentLView && parentLView[INJECTOR] || null;\n  return lView;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null,\n    attrs: TAttributes | null): TElementNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Container, native: RComment, name: string | null,\n    attrs: TAttributes | null): TContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Projection, native: null, name: null,\n    attrs: TAttributes | null): TProjectionNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.ElementContainer, native: RComment, name: string | null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.IcuContainer, native: RComment, name: null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType, native: RText | RElement | RComment | null, name: string | null,\n    attrs: TAttributes | null): TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&\n    TIcuContainerNode {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode &&\n      assertLessThan(adjustedIndex, lView.length, `Slot should have been initialized with null`);\n  lView[adjustedIndex] = native;\n\n  let tNode = tView.data[adjustedIndex] as TNode;\n  if (tNode == null) {\n    // TODO(misko): Refactor createTNode so that it does not depend on LView.\n    tNode = tView.data[adjustedIndex] = createTNode(lView, type, adjustedIndex, name, attrs, null);\n  }\n\n  // Now link ourselves into the tree.\n  // We need this even if tNode exists, otherwise we might end up pointing to unexisting tNodes when\n  // we use i18n (especially with ICU expressions that update the DOM during the update phase).\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  const isParent = getIsParent();\n  if (previousOrParentTNode) {\n    if (isParent && previousOrParentTNode.child == null &&\n        (tNode.parent !== null || previousOrParentTNode.type === TNodeType.View)) {\n      // We are in the same view, which means we are adding content node to the parent view.\n      previousOrParentTNode.child = tNode;\n    } else if (!isParent) {\n      previousOrParentTNode.next = tNode;\n    }\n  }\n\n  if (tView.firstChild == null) {\n    tView.firstChild = tNode;\n  }\n\n  setPreviousOrParentTNode(tNode);\n  setIsParent(true);\n  return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n      TProjectionNode & TIcuContainerNode;\n}\n\nexport function createViewNode(index: number, view: LView) {\n  // View nodes are not stored in data because they can be added / removed at runtime (which\n  // would cause indices to change). Their TNodes are instead stored in tView.node.\n  if (view[TVIEW].node == null) {\n    view[TVIEW].node = createTNode(view, TNodeType.View, index, null, null, null) as TViewNode;\n  }\n\n  return view[HOST_NODE] = view[TVIEW].node as TViewNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n */\nexport function allocExpando(view: LView) {\n  const tView = view[TVIEW];\n  if (tView.firstTemplatePass) {\n    tView.expandoStartIndex++;\n    tView.blueprint.push(null);\n    tView.data.push(null);\n    view.push(null);\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param templateFn Template function with the instructions.\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T,\n    providedRendererFactory: RendererFactory3, hostView: LView | null,\n    directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null,\n    sanitizer?: Sanitizer | null): LView {\n  if (hostView == null) {\n    resetComponentState();\n    const renderer = providedRendererFactory.createRenderer(null, null);\n\n    // We need to create a root view so it's possible to look up the host element through its index\n    const hostLView = createLView(\n        null, createTView(-1, null, 1, 0, null, null, null), {},\n        LViewFlags.CheckAlways | LViewFlags.IsRoot, providedRendererFactory, renderer);\n    enterView(hostLView, null);  // SUSPECT! why do we need to enter the View?\n\n    const componentTView =\n        getOrCreateTView(templateFn, consts, vars, directives || null, pipes || null, null);\n    hostView = createLView(\n        hostLView, componentTView, context, LViewFlags.CheckAlways, providedRendererFactory,\n        renderer, sanitizer);\n    hostView[HOST_NODE] = createNodeAtIndex(0, TNodeType.Element, hostNode, null, null);\n  }\n  renderComponentOrTemplate(hostView, context, templateFn);\n  return hostView;\n}\n\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport function createEmbeddedViewAndNode<T>(\n    tView: TView, context: T, declarationView: LView, renderer: Renderer3, queries: LQueries | null,\n    injectorIndex: number): LView {\n  const _isParent = getIsParent();\n  const _previousOrParentTNode = getPreviousOrParentTNode();\n  setIsParent(true);\n  setPreviousOrParentTNode(null !);\n\n  const lView = createLView(declarationView, tView, context, LViewFlags.CheckAlways);\n  lView[DECLARATION_VIEW] = declarationView;\n\n  if (queries) {\n    lView[QUERIES] = queries.createView();\n  }\n  createViewNode(-1, lView);\n\n  if (tView.firstTemplatePass) {\n    tView.node !.injectorIndex = injectorIndex;\n  }\n\n  setIsParent(_isParent);\n  setPreviousOrParentTNode(_previousOrParentTNode);\n  return lView;\n}\n\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport function renderEmbeddedTemplate<T>(viewToRender: LView, tView: TView, context: T) {\n  const _isParent = getIsParent();\n  const _previousOrParentTNode = getPreviousOrParentTNode();\n  setIsParent(true);\n  setPreviousOrParentTNode(null !);\n  let oldView: LView;\n  if (viewToRender[FLAGS] & LViewFlags.IsRoot) {\n    // This is a root view inside the view tree\n    tickRootContext(getRootContext(viewToRender));\n  } else {\n    try {\n      setIsParent(true);\n      setPreviousOrParentTNode(null !);\n\n      oldView = enterView(viewToRender, viewToRender[HOST_NODE]);\n      namespaceHTML();\n      tView.template !(getRenderFlags(viewToRender), context);\n      // This must be set to false immediately after the first creation run because in an\n      // ngFor loop, all the views will be created together before update mode runs and turns\n      // off firstTemplatePass. If we don't set it here, instances will perform directive\n      // matching, etc again and again.\n      viewToRender[TVIEW].firstTemplatePass = false;\n      setFirstTemplatePass(false);\n\n      refreshDescendantViews(viewToRender);\n    } finally {\n      leaveView(oldView !);\n      setIsParent(_isParent);\n      setPreviousOrParentTNode(_previousOrParentTNode);\n    }\n  }\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n */\nexport function nextContext<T = any>(level: number = 1): T {\n  return nextContextImpl(level);\n}\n\nfunction renderComponentOrTemplate<T>(\n    hostView: LView, context: T, templateFn?: ComponentTemplate<T>) {\n  const rendererFactory = hostView[RENDERER_FACTORY];\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  const normalExecutionPath = !getCheckNoChangesMode();\n  try {\n    if (normalExecutionPath && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n\n    if (isCreationMode(hostView)) {\n      // creation mode pass\n      if (templateFn) {\n        namespaceHTML();\n        templateFn(RenderFlags.Create, context !);\n      }\n\n      refreshDescendantViews(hostView);\n      hostView[FLAGS] &= ~LViewFlags.CreationMode;\n    }\n\n    // update mode pass\n    templateFn && templateFn(RenderFlags.Update, context !);\n    refreshDescendantViews(hostView);\n  } finally {\n    if (normalExecutionPath && rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. Update block and create block are\n * always run separately.\n */\nfunction getRenderFlags(view: LView): RenderFlags {\n  return isCreationMode(view) ? RenderFlags.Create : RenderFlags.Update;\n}\n\n//////////////////////////\n//// Namespace\n//////////////////////////\n\nlet _currentNamespace: string|null = null;\n\nexport function namespaceSVG() {\n  _currentNamespace = 'http://www.w3.org/2000/svg';\n}\n\nexport function namespaceMathML() {\n  _currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\nexport function namespaceHTML() {\n  _currentNamespace = null;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes, classes, and styles to be written into the DOM\n *              element on creation. Use [AttributeMarker] to denote the meaning of this array.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function element(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  elementStart(index, name, attrs, localRefs);\n  elementEnd();\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrs Set of attributes to be used when matching directives.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n */\nexport function elementContainerStart(\n    index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const renderer = lView[RENDERER];\n  const tagName = 'ng-container';\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], tView.bindingStartIndex,\n                   'element containers should be created before any bindings');\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = renderer.createComment(ngDevMode ? tagName : '');\n\n  ngDevMode && assertDataInRange(lView, index - 1);\n  const tNode =\n      createNodeAtIndex(index, TNodeType.ElementContainer, native, tagName, attrs || null);\n\n  appendChild(native, tNode, lView);\n  createDirectivesAndLocals(tView, lView, localRefs);\n  attachPatchData(native, lView);\n}\n\n/** Mark the end of the <ng-container>. */\nexport function elementContainerEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertHasParent(getPreviousOrParentTNode());\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.ElementContainer);\n  const currentQueries = lView[QUERIES];\n  if (currentQueries) {\n    lView[QUERIES] = currentQueries.addNode(previousOrParentTNode as TElementContainerNode);\n  }\n\n  queueLifecycleHooks(tView, previousOrParentTNode);\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes, classes, and styles to be written into the DOM\n *              element on creation. Use [AttributeMarker] to denote the meaning of this array.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], tView.bindingStartIndex,\n                   'elements should be created before any bindings ');\n\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  const native = elementCreate(name);\n\n  ngDevMode && assertDataInRange(lView, index - 1);\n\n  const tNode = createNodeAtIndex(index, TNodeType.Element, native !, name, attrs || null);\n\n  if (attrs) {\n    // it's important to only prepare styling-related datastructures once for a given\n    // tNode and not each time an element is created. Also, the styling code is designed\n    // to be patched and constructed at various points, but only up until the first element\n    // is created. Then the styling context is locked and can only be instantiated for each\n    // successive element that is created.\n    if (tView.firstTemplatePass && !tNode.stylingTemplate && hasStyling(attrs)) {\n      tNode.stylingTemplate = initializeStaticStylingContext(attrs);\n    }\n    setUpAttributes(native, attrs);\n  }\n\n  appendChild(native, tNode, lView);\n  createDirectivesAndLocals(tView, lView, localRefs);\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n\n  // if a directive contains a host binding for \"class\" then all class-based data will\n  // flow through that (except for `[class.prop]` bindings). This also includes initial\n  // static class values as well. (Note that this will be fixed once map-based `[style]`\n  // and `[class]` bindings work for multiple directives.)\n  if (tView.firstTemplatePass) {\n    const inputData = initializeTNodeInputs(tNode);\n    if (inputData && inputData.hasOwnProperty('class')) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n  }\n\n  // There is no point in rendering styles when a class directive is present since\n  // it will take that over for us (this will be removed once #FW-882 is in).\n  if (tNode.stylingTemplate && (tNode.flags & TNodeFlags.hasClassInput) === 0) {\n    renderInitialStylesAndClasses(native, tNode.stylingTemplate, lView[RENDERER]);\n  }\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement {\n  let native: RElement;\n  const rendererToUse = overriddenRenderer || getLView()[RENDERER];\n\n  if (isProceduralRenderer(rendererToUse)) {\n    native = rendererToUse.createElement(name, _currentNamespace);\n  } else {\n    if (_currentNamespace === null) {\n      native = rendererToUse.createElement(name);\n    } else {\n      native = rendererToUse.createElementNS(_currentNamespace, name);\n    }\n  }\n  return native;\n}\n\n/**\n * Creates directive instances and populates local refs.\n *\n * @param localRefs Local refs of the node in question\n * @param localRefExtractor mapping function that extracts local ref value from TNode\n */\nfunction createDirectivesAndLocals(\n    tView: TView, viewData: LView, localRefs: string[] | null | undefined,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode) {\n  if (!getBindingsEnabled()) return;\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  if (getFirstTemplatePass()) {\n    ngDevMode && ngDevMode.firstTemplatePass++;\n\n    resolveDirectives(\n        tView, viewData, findDirectiveMatches(tView, viewData, previousOrParentTNode),\n        previousOrParentTNode, localRefs || null);\n  }\n  instantiateAllDirectives(tView, viewData, previousOrParentTNode);\n  invokeDirectivesHostBindings(tView, viewData, previousOrParentTNode);\n  saveResolvedLocalsInData(viewData, previousOrParentTNode, localRefExtractor);\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(\n    viewData: LView, tNode: TNode, localRefExtractor: LocalRefExtractor): void {\n  const localNames = tNode.localNames;\n  if (localNames) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param templateFn The template from which to get static data\n * @param consts The number of nodes, local refs, and pipes in this view\n * @param vars The number of bindings and pure function bindings in this view\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nexport function getOrCreateTView(\n    templateFn: ComponentTemplate<any>, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\n  // 1. It is a megamorphic call on each invocation.\n  // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\n  //    outer template invocation, which means that no such property will exist\n  // Correct solution is to only put `ngPrivateData` on the Component template\n  // and not on embedded templates.\n\n  return templateFn.ngPrivateData ||\n      (templateFn.ngPrivateData =\n           createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery) as never);\n}\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport function createTView(\n    viewIndex: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + consts;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW as any] = {\n    id: viewIndex,\n    blueprint: blueprint,\n    template: templateFn,\n    viewQuery: viewQuery,\n    node: null !,\n    data: blueprint.slice(),  // Fill in to match HEADER_OFFSET in LView\n    childIndex: -1,           // Children set in addToViewTree(), if any\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    expandoInstructions: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    firstChild: null,\n  };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LView {\n  const blueprint = new Array(initialViewLength)\n                        .fill(null, 0, bindingStartIndex)\n                        .fill(NO_CHANGE, bindingStartIndex) as LView;\n  blueprint[CONTAINER_INDEX] = -1;\n  blueprint[BINDING_INDEX] = bindingStartIndex;\n  return blueprint;\n}\n\nfunction setUpAttributes(native: RElement, attrs: TAttributes): void {\n  const renderer = getLView()[RENDERER];\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i++];\n    if (typeof attrName == 'number') {\n      if (attrName === AttributeMarker.NamespaceURI) {\n        // Namespaced attributes\n        const namespaceURI = attrs[i++] as string;\n        const attrName = attrs[i++] as string;\n        const attrVal = attrs[i++] as string;\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName, attrVal, namespaceURI) :\n            native.setAttributeNS(namespaceURI, attrName, attrVal);\n      } else {\n        // All other `AttributeMarker`s are ignored here.\n        break;\n      }\n    } else {\n      /// attrName is string;\n      const attrVal = attrs[i++];\n      if (attrName !== NG_PROJECT_AS_ATTR_NAME) {\n        // Standard attributes\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        if (isAnimationProp(attrName)) {\n          if (isProc) {\n            (renderer as ProceduralRenderer3).setProperty(native, attrName, attrVal);\n          }\n        } else {\n          isProc ?\n              (renderer as ProceduralRenderer3)\n                  .setAttribute(native, attrName as string, attrVal as string) :\n              native.setAttribute(attrName as string, attrVal as string);\n        }\n      }\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  const lView = getLView();\n  const tNode = getPreviousOrParentTNode();\n  const tView = lView[TVIEW];\n  const firstTemplatePass = tView.firstTemplatePass;\n  const tCleanup: false|any[] = firstTemplatePass && (tView.cleanup || (tView.cleanup = []));\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer);\n\n  // add native event listener - applicable to elements only\n  if (tNode.type === TNodeType.Element) {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    ngDevMode && ngDevMode.rendererAddEventListener++;\n    const renderer = lView[RENDERER];\n    const lCleanup = getCleanup(lView);\n    const lCleanupIndex = lCleanup.length;\n    let useCaptureOrSubIdx: boolean|number = useCapture;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      const cleanupFn = renderer.listen(native, eventName, listenerFn);\n      lCleanup.push(listenerFn, cleanupFn);\n      useCaptureOrSubIdx = lCleanupIndex + 1;\n    } else {\n      const wrappedListener = wrapListenerWithPreventDefault(listenerFn);\n      native.addEventListener(eventName, wrappedListener, useCapture);\n      lCleanup.push(wrappedListener);\n    }\n    tCleanup && tCleanup.push(eventName, tNode.index, lCleanupIndex, useCaptureOrSubIdx);\n  }\n\n  // subscribe to directive outputs\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(tNode, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let props: PropertyAliasValue|undefined;\n  if (outputs && (props = outputs[eventName])) {\n    const propsLength = props.length;\n    if (propsLength) {\n      const lCleanup = getCleanup(lView);\n      for (let i = 0; i < propsLength; i += 2) {\n        ngDevMode && assertDataInRange(lView, props[i] as number);\n        const subscription = lView[props[i] as number][props[i + 1]].subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(lView: LView, context: any, cleanupFn: Function): void {\n  const lCleanup = getCleanup(lView);\n  lCleanup.push(context);\n\n  if (lView[TVIEW].firstTemplatePass) {\n    getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LView, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertHasParent(getPreviousOrParentTNode());\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Element);\n  const lView = getLView();\n  const currentQueries = lView[QUERIES];\n  if (currentQueries) {\n    lView[QUERIES] = currentQueries.addNode(previousOrParentTNode as TElementNode);\n  }\n\n  queueLifecycleHooks(getLView()[TVIEW], previousOrParentTNode);\n  decreaseElementDepthCount();\n\n  // this is fired at the end of elementEnd because ALL of the stylingBindings code\n  // (for directives and the template) have now executed which means the styling\n  // context can be instantiated properly.\n  if (hasClassInput(previousOrParentTNode)) {\n    const stylingContext = getStylingContext(previousOrParentTNode.index, lView);\n    setInputsForProperty(\n        lView, previousOrParentTNode.inputs !['class'] !, getInitialClassNameValue(stylingContext));\n  }\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: SanitizerFn | null): void {\n  if (value !== NO_CHANGE) {\n    const lView = getLView();\n    const renderer = lView[RENDERER];\n    const element = getNativeByIndex(index, lView);\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveAttribute++;\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name) :\n                                       element.removeAttribute(name);\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element, name, strValue) :\n                                       element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @param nativeOnly Whether or not we should only set native properties and skip input check\n * (this is necessary for host property bindings)\n */\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean): void {\n  elementPropertyInternal(index, propName, value, sanitizer, nativeOnly);\n}\n\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub components renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @param nativeOnly Whether or not we should only set native properties and skip input check\n * (this is necessary for host property bindings)\n */\nexport function componentHostSyntheticProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean) {\n  elementPropertyInternal(index, propName, value, sanitizer, nativeOnly, loadComponentRenderer);\n}\n\nfunction loadComponentRenderer(tNode: TNode, lView: LView): Renderer3 {\n  const componentLView = lView[tNode.index] as LView;\n  return componentLView[RENDERER];\n}\n\nfunction elementPropertyInternal<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean,\n    loadRendererFn?: ((tNode: TNode, lView: LView) => Renderer3) | null): void {\n  if (value === NO_CHANGE) return;\n  const lView = getLView();\n  const element = getNativeByIndex(index, lView) as RElement | RComment;\n  const tNode = getTNode(index, lView);\n  let inputData: PropertyAliases|null|undefined;\n  let dataValue: PropertyAliasValue|undefined;\n  if (!nativeOnly && (inputData = initializeTNodeInputs(tNode)) &&\n      (dataValue = inputData[propName])) {\n    setInputsForProperty(lView, dataValue, value);\n    if (isComponent(tNode)) markDirtyIfOnPush(lView, index + HEADER_OFFSET);\n    if (ngDevMode) {\n      if (tNode.type === TNodeType.Element || tNode.type === TNodeType.Container) {\n        setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n      }\n    }\n  } else if (tNode.type === TNodeType.Element) {\n    const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    ngDevMode && ngDevMode.rendererSetProperty++;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(element as RElement, propName, value);\n    } else if (!isAnimationProp(propName)) {\n      (element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                          (element as any)[propName] = value;\n    }\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    lView: LView, type: TNodeType, adjustedIndex: number, tagName: string | null,\n    attrs: TAttributes | null, tViews: TView[] | null): TNode {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  ngDevMode && ngDevMode.tNode++;\n  const parent =\n      getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const parentInSameView = parent && lView && parent !== lView[HOST_NODE];\n  const tParent = parentInSameView ? parent as TElementNode | TContainerNode : null;\n\n  return {\n    type: type,\n    index: adjustedIndex,\n    injectorIndex: tParent ? tParent.injectorIndex : -1,\n    directiveStart: -1,\n    directiveEnd: -1,\n    flags: 0,\n    providerIndexes: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    tViews: tViews,\n    next: null,\n    child: null,\n    parent: tParent,\n    detached: null,\n    stylingTemplate: null,\n    projection: null\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(lView: LView, inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(lView, inputs[i] as number);\n    lView[inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\nfunction setNgReflectProperties(\n    lView: LView, element: RElement | RComment, type: TNodeType, inputs: PropertyAliasValue,\n    value: any) {\n  for (let i = 0; i < inputs.length; i += 2) {\n    const renderer = lView[RENDERER];\n    const attrName = normalizeDebugBindingName(inputs[i + 1] as string);\n    const debugValue = normalizeDebugBindingValue(value);\n    if (type === TNodeType.Element) {\n      isProceduralRenderer(renderer) ?\n          renderer.setAttribute((element as RElement), attrName, debugValue) :\n          (element as RElement).setAttribute(attrName, debugValue);\n    } else if (value !== undefined) {\n      const value = `bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`;\n      if (isProceduralRenderer(renderer)) {\n        renderer.setValue((element as RComment), value);\n      } else {\n        (element as RComment).textContent = value;\n      }\n    }\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param tNodeFlags node flags\n * @param direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(tNode: TNode, direction: BindingDirection): PropertyAliases|null {\n  const tView = getLView()[TVIEW];\n  let propStore: PropertyAliases|null = null;\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n\n  if (end > start) {\n    const isInput = direction === BindingDirection.Input;\n    const defs = tView.data;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDef<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to register all\n * dynamic style and class bindings on the element. Note for static values (no binding)\n * see `elementStart` and `elementHostAttrs`.\n *\n * @param classBindingNames An array containing bindable class names.\n *        The `elementClassProp` refers to the class name by index in this array.\n *        (i.e. `['foo', 'bar']` means `foo=0` and `bar=1`).\n * @param styleBindingNames An array containing bindable style properties.\n *        The `elementStyleProp` refers to the class name by index in this array.\n *        (i.e. `['width', 'height']` means `width=0` and `height=1`).\n * @param styleSanitizer An optional sanitizer function that will be used to sanitize any CSS\n *        property values that are applied to the element (during rendering).\n *        Note that the sanitizer instance itself is tied to the `directive` (if  provided).\n * @param directive A directive instance the styling is associated with. If not provided\n *        current view's controller instance is assumed.\n *\n * @publicApi\n */\nexport function elementStyling(\n    classBindingNames?: string[] | null, styleBindingNames?: string[] | null,\n    styleSanitizer?: StyleSanitizeFn | null, directive?: {}): void {\n  const tNode = getPreviousOrParentTNode();\n  if (!tNode.stylingTemplate) {\n    tNode.stylingTemplate = createEmptyStylingContext();\n  }\n  updateContextWithBindings(\n      tNode.stylingTemplate !, directive || null, classBindingNames, styleBindingNames,\n      styleSanitizer, hasClassInput(tNode));\n}\n\n/**\n * Assign static styling values to a host element.\n *\n * NOTE: This instruction is meant to used from `hostBindings` function only.\n *\n * @param directive A directive instance the styling is associated with.\n * @param attrs An array containing class and styling information. The values must be marked with\n *              `AttributeMarker`.\n *\n *        ```\n *        var attrs = [AttributeMarker.Classes, 'foo', 'bar',\n *                     AttributeMarker.Styles, 'width', '100px', 'height, '200px']\n *        elementHostAttrs(directive, attrs);\n *        ```\n *\n * @publicApi\n */\nexport function elementHostAttrs(directive: any, attrs: TAttributes) {\n  const tNode = getPreviousOrParentTNode();\n  if (!tNode.stylingTemplate) {\n    tNode.stylingTemplate = initializeStaticStylingContext(attrs);\n  }\n  patchContextWithStaticAttrs(tNode.stylingTemplate, attrs, directive);\n}\n\n/**\n * Apply styling binding to the element.\n *\n * This instruction is meant to be run after `elementStyle` and/or `elementStyleProp`.\n * if any styling bindings have changed then the changes are flushed to the element.\n *\n *\n * @param index Index of the element's with which styling is associated.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\ncomponents\n *\n * @publicApi\n */\nexport function elementStylingApply(index: number, directive?: any): void {\n  const lView = getLView();\n  const isFirstRender = (lView[FLAGS] & LViewFlags.FirstLViewPass) !== 0;\n  const totalPlayersQueued = renderStyling(\n      getStylingContext(index + HEADER_OFFSET, lView), lView[RENDERER], lView, isFirstRender, null,\n      null, directive);\n  if (totalPlayersQueued > 0) {\n    const rootContext = getRootContext(lView);\n    scheduleTick(rootContext, RootContextFlags.FlushPlayers);\n  }\n}\n\n/**\n * Update a style bindings value on an element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling element is updated as part of `elementStylingApply`.)\n *\n * @param index Index of the element's with which styling is associated.\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `elementStlyingBindings`.\n * @param value New value to write (null to remove). Note that if a directive also\n *        attempts to write to the same binding value then it will only be able to\n *        do so if the template binding value is `null` (or doesn't exist at all).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\ncomponents\n *\n * @publicApi\n */\nexport function elementStyleProp(\n    index: number, styleIndex: number, value: string | number | String | PlayerFactory | null,\n    suffix?: string | null, directive?: {}): void {\n  let valueToAdd: string|null = null;\n  if (value !== null) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      valueToAdd = stringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a String value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      valueToAdd = value as any as string;\n    }\n  }\n  updateElementStyleProp(\n      getStylingContext(index + HEADER_OFFSET, getLView()), styleIndex, valueToAdd, directive);\n}\n\n/**\n * Add or remove a class via a class binding on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case and, therefore,\n * the class itself must already be applied using `elementStyling` within\n * the creation block.\n *\n * @param index Index of the element's with which styling is associated.\n * @param classIndex Index of class to toggle. This index value refers to the\n *        index of the class in the class bindings array that was passed into\n *        `elementStlyingBindings` (which is meant to be called before this\n *        function is).\n * @param value A true/false value which will turn the class on or off.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\ncomponents\n *\n * @publicApi\n */\nexport function elementClassProp(\n    index: number, classIndex: number, value: boolean | PlayerFactory, directive?: {}): void {\n  const onOrOffClassValue =\n      (value instanceof BoundPlayerFactory) ? (value as BoundPlayerFactory<boolean>) : (!!value);\n  updateElementClassProp(\n      getStylingContext(index + HEADER_OFFSET, getLView()), classIndex, onOrOffClassValue,\n      directive);\n}\n\n/**\n * Update style and/or class bindings using object literal.\n *\n * This instruction is meant apply styling via the `[style]=\"exp\"` and `[class]=\"exp\"` template\n * bindings. When styles are applied to the Element they will then be placed with respect to\n * any styles set with `elementStyleProp`. If any styles are set to `null` then they will be\n * removed from the element.\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's with which styling is associated.\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n * @param directive Directive instance that is attempting to change styling. (Defaults to the\n *        component of the current view).\n *\n * @publicApi\n */\nexport function elementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | NO_CHANGE | null,\n    styles?: {[styleName: string]: any} | NO_CHANGE | null, directive?: {}): void {\n  if (directive != undefined)\n    return hackImplementationOfElementStylingMap(\n        index, classes, styles, directive);  // supported in next PR\n  const lView = getLView();\n  const tNode = getTNode(index, lView);\n  const stylingContext = getStylingContext(index + HEADER_OFFSET, lView);\n  if (hasClassInput(tNode) && classes !== NO_CHANGE) {\n    const initialClasses = getInitialClassNameValue(stylingContext);\n    const classInputVal =\n        (initialClasses.length ? (initialClasses + ' ') : '') + (classes as string);\n    setInputsForProperty(lView, tNode.inputs !['class'] !, classInputVal);\n  } else {\n    updateStylingMap(stylingContext, classes, styles);\n  }\n}\n\n/* START OF HACK BLOCK */\nfunction hackImplementationOfElementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | NO_CHANGE | null,\n    styles?: {[styleName: string]: any} | NO_CHANGE | null, directive?: {}): void {\n  throw new Error('unimplemented. Should not be needed by ViewEngine compatibility');\n}\n/* END OF HACK BLOCK */\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  const lView = getLView();\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex,\n                   'text nodes should be created before any bindings');\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  const textNative = createTextNode(value, lView[RENDERER]);\n  const tNode = createNodeAtIndex(index, TNodeType.Element, textNative, null, null);\n\n  // Text nodes are self closing.\n  setIsParent(false);\n  appendChild(textNative, tNode, lView);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    const lView = getLView();\n    ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n    const element = getNativeByIndex(index, lView) as any as RText;\n    ngDevMode && assertDefined(element, 'native element should exist');\n    ngDevMode && ngDevMode.rendererSetText++;\n    const renderer = lView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.setValue(element, stringify(value)) :\n                                     element.textContent = stringify(value);\n  }\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(\n    tView: TView, viewData: LView, def: ComponentDef<T>): T {\n  const rootTNode = getPreviousOrParentTNode();\n  if (tView.firstTemplatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    generateExpandoInstructionBlock(tView, rootTNode, 1);\n    baseResolveDirective(tView, viewData, def, def.factory);\n  }\n  const directive =\n      getNodeInjectable(tView.data, viewData, viewData.length - 1, rootTNode as TElementNode);\n  postProcessBaseDirective(viewData, rootTNode, directive, def as DirectiveDef<T>);\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(\n    tView: TView, viewData: LView, directives: DirectiveDef<any>[] | null, tNode: TNode,\n    localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'should run on first template pass only');\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  if (directives) {\n    initNodeFlags(tNode, tView.data.length, directives.length);\n    // When the same token is provided by several directives on the same node, some rules apply in\n    // the viewEngine:\n    // - viewProviders have priority over providers\n    // - the last directive in NgModule.declarations has priority over the previous one\n    // So to match these rules, the order in which providers are added in the arrays is very\n    // important.\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n      if (def.providersResolver) def.providersResolver(def);\n    }\n    generateExpandoInstructionBlock(tView, tNode, directives.length);\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n\n      const directiveDefIdx = tView.data.length;\n      baseResolveDirective(tView, viewData, def, def.factory);\n\n      saveNameToExportMap(tView.data !.length - 1, def, exportsMap);\n\n      // Init hooks are queued now so ngOnInit is called in host components before\n      // any projected components.\n      queueInitHooks(directiveDefIdx, def.onInit, def.doCheck, tView);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n}\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView: TView, lView: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (!getFirstTemplatePass() && start < end) {\n    getOrCreateNodeInjectorForNode(\n        tNode as TElementNode | TContainerNode | TElementContainerNode, lView);\n  }\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    if (isComponentDef(def)) {\n      addComponentLogic(lView, tNode, def as ComponentDef<any>);\n    }\n    const directive = getNodeInjectable(tView.data, lView !, i, tNode as TElementNode);\n    postProcessDirective(lView, directive, def, i);\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView: TView, viewData: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const expando = tView.expandoInstructions !;\n  const firstTemplatePass = getFirstTemplatePass();\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const directive = viewData[i];\n    if (def.hostBindings) {\n      const previousExpandoLength = expando.length;\n      setCurrentDirectiveDef(def);\n      def.hostBindings !(RenderFlags.Create, directive, tNode.index - HEADER_OFFSET);\n      setCurrentDirectiveDef(null);\n      // `hostBindings` function may or may not contain `allocHostVars` call\n      // (e.g. it may not if it only contains host listeners), so we need to check whether\n      // `expandoInstructions` has changed and if not - we still push `hostBindings` to\n      // expando block, to make sure we execute it for DI cycle\n      if (previousExpandoLength === expando.length && firstTemplatePass) {\n        expando.push(def.hostBindings);\n      }\n    } else if (firstTemplatePass) {\n      expando.push(null);\n    }\n  }\n}\n\n/**\n* Generates a new block in TView.expandoInstructions for this node.\n*\n* Each expando block starts with the element index (turned negative so we can distinguish\n* it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n*/\nexport function generateExpandoInstructionBlock(\n    tView: TView, tNode: TNode, directiveCount: number): void {\n  ngDevMode && assertEqual(\n                   tView.firstTemplatePass, true,\n                   'Expando block should only be generated on first template pass.');\n\n  const elementIndex = -(tNode.index - HEADER_OFFSET);\n  const providerStartIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const providerCount = tView.data.length - providerStartIndex;\n  (tView.expandoInstructions || (tView.expandoInstructions = [\n   ])).push(elementIndex, providerCount, directiveCount);\n}\n\n/**\n* On the first template pass, we need to reserve space for host binding values\n* after directives are matched (so all directives are saved, then bindings).\n* Because we are updating the blueprint, we only need to do this once.\n*/\nfunction prefillHostVars(tView: TView, lView: LView, totalHostVars: number): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  for (let i = 0; i < totalHostVars; i++) {\n    lView.push(NO_CHANGE);\n    tView.blueprint.push(NO_CHANGE);\n    tView.data.push(null);\n  }\n}\n\n/**\n * Process a directive on the current node after its creation.\n */\nfunction postProcessDirective<T>(\n    viewData: LView, directive: T, def: DirectiveDef<T>, directiveDefIdx: number): void {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  postProcessBaseDirective(viewData, previousOrParentTNode, directive, def);\n  ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');\n  if (previousOrParentTNode && previousOrParentTNode.attrs) {\n    setInputsFromAttrs(directiveDefIdx, directive, def.inputs, previousOrParentTNode);\n  }\n\n  if (def.contentQueries) {\n    def.contentQueries(directiveDefIdx);\n  }\n\n  if (isComponentDef(def)) {\n    const componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);\n    componentView[CONTEXT] = directive;\n  }\n}\n\n/**\n * A lighter version of postProcessDirective() that is used for the root component.\n */\nfunction postProcessBaseDirective<T>(\n    lView: LView, previousOrParentTNode: TNode, directive: T, def: DirectiveDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, lView);\n\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex,\n                   'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent(getIsParent());\n\n  attachPatchData(directive, lView);\n  if (native) {\n    attachPatchData(native, lView);\n  }\n\n  // TODO(misko): setUpAttributes should be a feature for better treeshakability.\n  if (def.attributes != null && previousOrParentTNode.type == TNodeType.Element) {\n    setUpAttributes(native as RElement, def.attributes as string[]);\n  }\n}\n\n\n\n/**\n* Matches the current node against all available selectors.\n* If a component is matched (at most one), it is returned in first position in the array.\n*/\nfunction findDirectiveMatches(tView: TView, viewData: LView, tNode: TNode): DirectiveDef<any>[]|\n    null {\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'should run on first template pass only');\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors !, /* isProjectionMode */ false)) {\n        matches || (matches = []);\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode,\n                viewData),\n            viewData, def.type);\n\n        if (isComponentDef(def)) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          tNode.flags = TNodeFlags.isComponent;\n\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nexport function queueComponentIndexForCheck(previousOrParentTNode: TNode): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  const tView = getLView()[TVIEW];\n  (tView.components || (tView.components = [])).push(previousOrParentTNode.index);\n}\n\n/**\n * Stores host binding fn and number of host vars so it will be queued for binding refresh during\n * CD.\n*/\nfunction queueHostBindingForCheck(\n    tView: TView, def: DirectiveDef<any>| ComponentDef<any>, hostVars: number): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  const expando = tView.expandoInstructions !;\n  const length = expando.length;\n  // Check whether a given `hostBindings` function already exists in expandoInstructions,\n  // which can happen in case directive definition was extended from base definition (as a part of\n  // the `InheritDefinitionFeature` logic). If we found the same `hostBindings` function in the\n  // list, we just increase the number of host vars associated with that function, but do not add it\n  // into the list again.\n  if (length >= 2 && expando[length - 2] === def.hostBindings) {\n    expando[length - 1] = (expando[length - 1] as number) + hostVars;\n  } else {\n    expando.push(def.hostBindings !, hostVars);\n  }\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n* Builds up an export map as directives are created, so local refs can be quickly mapped\n* to their directive instances.\n*/\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDef<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'expected firstTemplatePass to be true');\n  const flags = tNode.flags;\n  ngDevMode && assertEqual(\n                   flags === 0 || flags === TNodeFlags.isComponent, true,\n                   'expected node flags to not be initialized');\n\n  ngDevMode && assertNotEqual(\n                   numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,\n                   'Reached the max number of directives');\n  // When the first directive is created on a node, save the index\n  tNode.flags = flags & TNodeFlags.isComponent;\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\nfunction baseResolveDirective<T>(\n    tView: TView, viewData: LView, def: DirectiveDef<T>,\n    directiveFactory: (t: Type<T>| null) => any) {\n  tView.data.push(def);\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\n  tView.blueprint.push(nodeInjectorFactory);\n  viewData.push(nodeInjectorFactory);\n}\n\nfunction addComponentLogic<T>(\n    lView: LView, previousOrParentTNode: TNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, lView);\n\n  const tView = getOrCreateTView(\n      def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(\n      lView, previousOrParentTNode.index as number,\n      createLView(\n          lView, tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways,\n          rendererFactory, lView[RENDERER_FACTORY].createRenderer(native as RElement, def)));\n\n  componentView[HOST_NODE] = previousOrParentTNode as TElementNode;\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  componentView[HOST] = lView[previousOrParentTNode.index];\n  lView[previousOrParentTNode.index] = componentView;\n\n  if (getFirstTemplatePass()) {\n    queueComponentIndexForCheck(previousOrParentTNode);\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[P in keyof T]: string;}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    }\n    const minifiedInputName = inputs[attrName];\n    const attrValue = attrs[i + 1];\n\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrValue as string);\n    }\n\n    i += 2;\n  }\n  return initialInputData;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement | RComment,\n    hostTNode: TElementNode | TContainerNode | TElementContainerNode, currentView: LView,\n    native: RComment, isForViewContainerRef?: boolean): LContainer {\n  return [\n    isForViewContainerRef ? -1 : 0,          // active index\n    [],                                      // views\n    currentView,                             // parent\n    null,                                    // next\n    null,                                    // queries\n    hostNative,                              // host native\n    native,                                  // native\n    getRenderParent(hostTNode, currentView)  // renderParent\n  ];\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param consts The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n */\nexport function template(\n    index: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null,\n    localRefExtractor?: LocalRefExtractor) {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  // TODO: consider a separate node type for templates\n  const tNode = containerInternal(index, tagName || null, attrs || null);\n\n  if (getFirstTemplatePass()) {\n    tNode.tViews = createTView(\n        -1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n\n  createDirectivesAndLocals(tView, lView, localRefs, localRefExtractor);\n  const currentQueries = lView[QUERIES];\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  const native = getNativeByTNode(previousOrParentTNode, lView);\n  attachPatchData(native, lView);\n  if (currentQueries) {\n    lView[QUERIES] = currentQueries.addNode(previousOrParentTNode as TContainerNode);\n  }\n  queueLifecycleHooks(tView, tNode);\n  setIsParent(false);\n}\n\n/**\n * Creates an LContainer for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n */\nexport function container(index: number): void {\n  const tNode = containerInternal(index, null, null);\n  getFirstTemplatePass() && (tNode.tViews = []);\n  setIsParent(false);\n}\n\nfunction containerInternal(\n    index: number, tagName: string | null, attrs: TAttributes | null): TNode {\n  const lView = getLView();\n  ngDevMode && assertEqual(\n                   lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex,\n                   'container nodes should be created before any bindings');\n\n  const adjustedIndex = index + HEADER_OFFSET;\n  const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const tNode = createNodeAtIndex(index, TNodeType.Container, comment, tagName, attrs);\n  const lContainer = lView[adjustedIndex] =\n      createLContainer(lView[adjustedIndex], tNode, lView, comment);\n\n  appendChild(comment, tNode, lView);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(lView, index + HEADER_OFFSET, lContainer);\n\n  const currentQueries = lView[QUERIES];\n  if (currentQueries) {\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer[QUERIES] = currentQueries.container();\n  }\n\n  ngDevMode && assertNodeType(getPreviousOrParentTNode(), TNodeType.Container);\n  return tNode;\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  let previousOrParentTNode = loadInternal(tView.data, index) as TNode;\n  setPreviousOrParentTNode(previousOrParentTNode);\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n  setIsParent(true);\n\n  lView[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\n\n  // We need to execute init hooks here so ngOnInit hooks are called in top level views\n  // before they are called in embedded views (for backwards compatibility).\n  executeInitHooks(lView, tView, getCheckNoChangesMode());\n}\n\n/**\n * Marks the end of the LContainer.\n *\n * Marking the end of LContainer is the time when to child views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.View);\n    ngDevMode && assertHasParent(previousOrParentTNode);\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n\n  const lContainer = getLView()[previousOrParentTNode.index];\n  const nextIndex = lContainer[ACTIVE_INDEX];\n\n  // remove extra views at the end of the container\n  while (nextIndex < lContainer[VIEWS].length) {\n    removeView(lContainer, previousOrParentTNode as TContainerNode, nextIndex);\n  }\n}\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\n * by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lView: LView) {\n  for (let current = getLViewChild(lView); current !== null; current = current[NEXT]) {\n    // Note: current can be an LView or an LContainer instance, but here we are only interested\n    // in LContainer. We can tell it's an LContainer because its length is less than the LView\n    // header.\n    if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {\n      const container = current as LContainer;\n      for (let i = 0; i < container[VIEWS].length; i++) {\n        const dynamicViewData = container[VIEWS][i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\n        renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT] !);\n      }\n    }\n  }\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param lContainer to search for views\n * @param tContainerNode to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    lContainer: LContainer, tContainerNode: TContainerNode, startIdx: number,\n    viewBlockId: number): LView|null {\n  const views = lContainer[VIEWS];\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i][TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(lContainer, tContainerNode, i);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the searchdef.cont here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags {\n  const lView = getLView();\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  // The previous node can be a view node if we are processing an inline for loop\n  const containerTNode = previousOrParentTNode.type === TNodeType.View ?\n      previousOrParentTNode.parent ! :\n      previousOrParentTNode;\n  const lContainer = lView[containerTNode.index] as LContainer;\n\n  ngDevMode && assertNodeType(containerTNode, TNodeType.Container);\n  let viewToRender = scanForView(\n      lContainer, containerTNode as TContainerNode, lContainer[ACTIVE_INDEX] !, viewBlockId);\n\n  if (viewToRender) {\n    setIsParent(true);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    viewToRender = createLView(\n        lView,\n        getOrCreateEmbeddedTView(viewBlockId, consts, vars, containerTNode as TContainerNode), null,\n        LViewFlags.CheckAlways);\n\n    if (lContainer[QUERIES]) {\n      viewToRender[QUERIES] = lContainer[QUERIES] !.createView();\n    }\n\n    createViewNode(viewBlockId, viewToRender);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  }\n  if (lContainer) {\n    if (isCreationMode(viewToRender)) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(viewToRender, lContainer, lView, lContainer[ACTIVE_INDEX] !, -1);\n    }\n    lContainer[ACTIVE_INDEX] !++;\n  }\n  return isCreationMode(viewToRender) ? RenderFlags.Create | RenderFlags.Update :\n                                        RenderFlags.Update;\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param vars The number of bindings and pure function bindings in this template\n * @param container The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(\n    viewIndex: number, consts: number, vars: number, parent: TContainerNode): TView {\n  const tView = getLView()[TVIEW];\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = parent.tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] = createTView(\n        viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n  return containerTViews[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  const lView = getLView();\n  const viewHost = lView[HOST_NODE];\n\n  if (isCreationMode(lView)) {\n    refreshDescendantViews(lView);  // creation mode pass\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n  }\n  refreshDescendantViews(lView);  // update mode pass\n  leaveView(lView[PARENT] !);\n  setPreviousOrParentTNode(viewHost !);\n  setIsParent(false);\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param adjustedElementIndex  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nexport function componentRefresh<T>(adjustedElementIndex: number): void {\n  const lView = getLView();\n  ngDevMode && assertDataInRange(lView, adjustedElementIndex);\n  const hostView = getComponentViewByIndex(adjustedElementIndex, lView);\n  ngDevMode && assertNodeType(lView[TVIEW].data[adjustedElementIndex] as TNode, TNodeType.Element);\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    syncViewWithBlueprint(hostView);\n    checkView(hostView, hostView[CONTEXT]);\n  }\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param componentView The view to sync\n */\nfunction syncViewWithBlueprint(componentView: LView) {\n  const componentTView = componentView[TVIEW];\n  for (let i = componentView.length; i < componentTView.blueprint.length; i++) {\n    componentView[i] = componentTView.blueprint[i];\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nexport function viewAttached(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const componentNode = findComponentView(getLView())[HOST_NODE] as TElementNode;\n\n  if (!componentNode.projection) {\n    const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n    const pData: (TNode | null)[] = componentNode.projection =\n        new Array(noOfNodeBuckets).fill(null);\n    const tails: (TNode | null)[] = pData.slice();\n\n    let componentChild: TNode|null = componentNode.child;\n\n    while (componentChild !== null) {\n      const bucketIndex =\n          selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors !) : 0;\n      const nextNode = componentChild.next;\n\n      if (tails[bucketIndex]) {\n        tails[bucketIndex] !.next = componentChild;\n      } else {\n        pData[bucketIndex] = componentChild;\n        componentChild.next = null;\n      }\n      tails[bucketIndex] = componentChild;\n\n      componentChild = nextNode;\n    }\n  }\n}\n\n/**\n * Stack used to keep track of projection nodes in projection() instruction.\n *\n * This is deliberately created outside of projection() to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LView | TNode)[] = [];\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(nodeIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const lView = getLView();\n  const tProjectionNode =\n      createNodeAtIndex(nodeIndex, TNodeType.Projection, null, null, attrs || null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  setIsParent(false);\n\n  // re-distribution of projectable nodes is stored on a component's view level\n  const componentView = findComponentView(lView);\n  const componentNode = componentView[HOST_NODE] as TElementNode;\n  let nodeToProject = (componentNode.projection as(TNode | null)[])[selectorIndex];\n  let projectedView = componentView[PARENT] !;\n  let projectionNodeIndex = -1;\n\n  while (nodeToProject) {\n    if (nodeToProject.type === TNodeType.Projection) {\n      // This node is re-projected, so we must go up the tree to get its projected nodes.\n      const currentComponentView = findComponentView(projectedView);\n      const currentComponentHost = currentComponentView[HOST_NODE] as TElementNode;\n      const firstProjectedNode =\n          (currentComponentHost.projection as(TNode | null)[])[nodeToProject.projection as number];\n\n      if (firstProjectedNode) {\n        projectionNodeStack[++projectionNodeIndex] = nodeToProject;\n        projectionNodeStack[++projectionNodeIndex] = projectedView;\n\n        nodeToProject = firstProjectedNode;\n        projectedView = currentComponentView[PARENT] !;\n        continue;\n      }\n    } else {\n      // This flag must be set now or we won't know that this node is projected\n      // if the nodes are inserted into a container later.\n      nodeToProject.flags |= TNodeFlags.isProjected;\n      appendProjectedNode(nodeToProject, tProjectionNode, lView, projectedView);\n    }\n\n    // If we are finished with a list of re-projected nodes, we need to get\n    // back to the root projection node that was re-projected.\n    if (nodeToProject.next === null && projectedView !== componentView[PARENT] !) {\n      projectedView = projectionNodeStack[projectionNodeIndex--] as LView;\n      nodeToProject = projectionNodeStack[projectionNodeIndex--] as TNode;\n    }\n    nodeToProject = nodeToProject.next;\n  }\n}\n\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param state The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(\n    lView: LView, adjustedHostIndex: number, state: T): T {\n  const tView = lView[TVIEW];\n  const firstTemplatePass = getFirstTemplatePass();\n  if (lView[TAIL]) {\n    lView[TAIL] ![NEXT] = state;\n  } else if (firstTemplatePass) {\n    tView.childIndex = adjustedHostIndex;\n  }\n  lView[TAIL] = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  const childComponentLView = getComponentViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\n/** Wraps an event listener with preventDefault behavior. */\nfunction wrapListenerWithPreventDefault(listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_preventDefault(e: Event) {\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(lView: LView): void {\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView[FLAGS] |= LViewFlags.Dirty;\n    lView = lView[PARENT] !;\n  }\n  lView[FLAGS] |= LViewFlags.Dirty;\n  ngDevMode && assertDefined(lView[CONTEXT], 'rootContext should be defined');\n\n  const rootContext = lView[CONTEXT] as RootContext;\n  scheduleTick(rootContext, RootContextFlags.DetectChanges);\n}\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  rootContext.flags |= flags;\n\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res !(null);\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n\nfunction tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    renderComponentOrTemplate(readPatchedLView(rootComponent) !, rootComponent);\n  }\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const view = getComponentViewByInstance(component) !;\n  detectChangesInternal<T>(view, component);\n}\n\nexport function detectChangesInternal<T>(view: LView, context: T) {\n  const rendererFactory = view[RENDERER_FACTORY];\n\n  if (rendererFactory.begin) rendererFactory.begin();\n\n  if (isCreationMode(view)) {\n    checkView(view, context);  // creation mode pass\n  }\n  checkView(view, context);  // update mode pass\n\n  if (rendererFactory.end) rendererFactory.end();\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lView: LView): void {\n  tickRootContext(lView[CONTEXT] as RootContext);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChanges(component);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lView: LView): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nexport function checkView<T>(hostView: LView, component: T) {\n  const hostTView = hostView[TVIEW];\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  const templateFn = hostTView.template !;\n  const viewQuery = hostTView.viewQuery;\n\n  try {\n    namespaceHTML();\n    createViewQuery(viewQuery, hostView, component);\n    templateFn(getRenderFlags(hostView), component);\n    refreshDescendantViews(hostView);\n    updateViewQuery(viewQuery, hostView, component);\n  } finally {\n    leaveView(oldView);\n  }\n}\n\nfunction createViewQuery<T>(viewQuery: ComponentQuery<{}>| null, view: LView, component: T): void {\n  if (viewQuery && isCreationMode(view)) {\n    viewQuery(RenderFlags.Create, component);\n  }\n}\n\nfunction updateViewQuery<T>(viewQuery: ComponentQuery<{}>| null, view: LView, component: T): void {\n  if (viewQuery && !isCreationMode(view)) {\n    viewQuery(RenderFlags.Update, component);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n *\n * @publicApi\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  markViewDirty(getComponentViewByInstance(component));\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T): T|NO_CHANGE {\n  const lView = getLView();\n  return bindingUpdated(lView, lView[BINDING_INDEX]++, value) ? value : NO_CHANGE;\n}\n\n/**\n * Allocates the necessary amount of slots for host vars.\n *\n * @param count Amount of vars to be allocated\n */\nexport function allocHostVars(count: number): void {\n  if (!getFirstTemplatePass()) return;\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  queueHostBindingForCheck(tView, getCurrentDirectiveDef() !, count);\n  prefillHostVars(tView, lView, count);\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let different = false;\n  const lView = getLView();\n\n  let bindingIndex = lView[BINDING_INDEX];\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(lView, bindingIndex++, values[i]) && (different = true);\n  }\n  lView[BINDING_INDEX] = bindingIndex;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated(lView, lView[BINDING_INDEX], v0);\n  lView[BINDING_INDEX] += 1;\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated2(lView, lView[BINDING_INDEX], v0, v1);\n  lView[BINDING_INDEX] += 2;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated3(lView, lView[BINDING_INDEX], v0, v1, v2);\n  lView[BINDING_INDEX] += 3;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const different = bindingUpdated4(lView, lView[BINDING_INDEX], v0, v1, v2, v3);\n  lView[BINDING_INDEX] += 4;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  lView[BINDING_INDEX] += 5;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  lView[BINDING_INDEX] += 6;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  lView[BINDING_INDEX] += 7;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  const lView = getLView();\n  const bindingIndex = lView[BINDING_INDEX];\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  lView[BINDING_INDEX] += 8;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n  }\n  lView[adjustedIndex] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n */\nexport function reference<T>(index: number) {\n  const contextLView = getContextLView();\n  return loadInternal<T>(contextLView, index);\n}\n\nexport function loadQueryList<T>(queryListIdx: number): QueryList<T> {\n  const lView = getLView();\n  ngDevMode &&\n      assertDefined(\n          lView[CONTENT_QUERIES], 'Content QueryList array should be defined if reading a query.');\n  ngDevMode && assertDataInRange(lView[CONTENT_QUERIES] !, queryListIdx);\n\n  return lView[CONTENT_QUERIES] ![queryListIdx];\n}\n\n/** Retrieves a value from current `viewData`. */\nexport function load<T>(index: number): T {\n  return loadInternal<T>(getLView(), index);\n}\n\n\n\n///////////////////////////////\n//// DI\n///////////////////////////////\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags): T;\nexport function directiveInject<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  token = resolveForwardRef(token);\n  return getOrCreateInjectable<T>(\n      getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode,\n      getLView(), token, flags);\n}\n\n/**\n * Facade for the attribute injection from DI.\n */\nexport function injectAttribute(attrNameToInject: string): string|null {\n  return injectAttributeImpl(getPreviousOrParentTNode(), attrNameToInject);\n}\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport function registerContentQuery<Q>(\n    queryList: QueryList<Q>, currentDirectiveIndex: number): void {\n  const viewData = getLView();\n  const tView = viewData[TVIEW];\n  const savedContentQueriesLength =\n      (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\n  if (getFirstTemplatePass()) {\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex =\n        tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\n    if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\n      tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nfunction initializeTNodeInputs(tNode: TNode | null) {\n  // If tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked.\n  if (tNode) {\n    if (tNode.inputs === undefined) {\n      // mark inputs as checked\n      tNode.inputs = generatePropertyAliases(tNode, BindingDirection.Input);\n    }\n    return tNode.inputs;\n  }\n  return null;\n}\n\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n */\nexport function getCurrentView(): OpaqueViewState {\n  return getLView() as any as OpaqueViewState;\n}\n\nfunction getCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\n\nfunction getTViewCleanup(view: LView): any[] {\n  return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\nimport {Type} from '../core';\nimport {Injector} from '../di/injector';\nimport {Sanitizer} from '../sanitization/security';\n\nimport {assertComponentType, assertDefined} from './assert';\nimport {getComponentDef} from './definition';\nimport {diPublicInInjector, getOrCreateNodeInjectorForNode} from './di';\nimport {publishDefaultGlobalUtils} from './global_utils';\nimport {queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {CLEAN_PROMISE, createLView, createNodeAtIndex, createTNode, createTView, getOrCreateTView, initNodeFlags, instantiateRootComponent, locateHostElement, queueComponentIndexForCheck, refreshDescendantViews} from './instructions';\nimport {ComponentDef, ComponentType, RenderFlags} from './interfaces/definition';\nimport {TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {PlayerHandler} from './interfaces/player';\nimport {RElement, Renderer3, RendererFactory3, domRendererFactory3} from './interfaces/renderer';\nimport {CONTEXT, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, LView, LViewFlags, RootContext, RootContextFlags, TVIEW} from './interfaces/view';\nimport {enterView, getPreviousOrParentTNode, leaveView, resetComponentState, setCurrentDirectiveDef} from './state';\nimport {defaultScheduler, getRootView, readPatchedLView, stringify} from './util';\n\n\n\n/** Options that control how the component should be bootstrapped. */\nexport interface CreateComponentOptions {\n  /** Which renderer factory to use. */\n  rendererFactory?: RendererFactory3;\n\n  /** A custom sanitizer instance */\n  sanitizer?: Sanitizer;\n\n  /** A custom animation player handler */\n  playerHandler?: PlayerHandler;\n\n  /**\n   * Host element on which the component will be bootstrapped. If not specified,\n   * the component definition's `tag` is used to query the existing DOM for the\n   * element to bootstrap.\n   */\n  host?: RElement|string;\n\n  /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n  injector?: Injector;\n\n  /**\n   * List of features to be applied to the created component. Features are simply\n   * functions that decorate a component with a certain behavior.\n   *\n   * Typically, the features in this list are features that cannot be added to the\n   * other features list in the component definition because they rely on other factors.\n   *\n   * Example: `RootLifecycleHooks` is a function that adds lifecycle hook capabilities\n   * to root components in a tree-shakable way. It cannot be added to the component\n   * features list because there's no way of knowing when the component will be used as\n   * a root component.\n   */\n  hostFeatures?: HostFeature[];\n\n  /**\n   * A function which is used to schedule change detection work in the future.\n   *\n   * When marking components as dirty, it is necessary to schedule the work of\n   * change detection in the future. This is done to coalesce multiple\n   * {@link markDirty} calls into a single changed detection processing.\n   *\n   * The default value of the scheduler is the `requestAnimationFrame` function.\n   *\n   * It is also useful to override this function for testing purposes.\n   */\n  scheduler?: (work: () => void) => void;\n}\n\n/** See CreateComponentOptions.hostFeatures */\ntype HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\n\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nexport const NULL_INJECTOR: Injector = {\n  get: (token: any, notFoundValue?: any) => {\n    throw new Error('NullInjector: Not found: ' + stringify(token));\n  }\n};\n\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\nexport function renderComponent<T>(\n    componentType: ComponentType<T>|\n        Type<T>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */\n    ,\n    opts: CreateComponentOptions = {}): T {\n  ngDevMode && publishDefaultGlobalUtils();\n  ngDevMode && assertComponentType(componentType);\n  const rendererFactory = opts.rendererFactory || domRendererFactory3;\n  const sanitizer = opts.sanitizer || null;\n  const componentDef = getComponentDef<T>(componentType) !;\n  if (componentDef.type != componentType) componentDef.type = componentType;\n\n  // The first index of the first selector is the tag name.\n  const componentTag = componentDef.selectors ![0] ![0] as string;\n  const hostRNode = locateHostElement(rendererFactory, opts.host || componentTag);\n  const rootFlags = componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                          LViewFlags.CheckAlways | LViewFlags.IsRoot;\n  const rootContext = createRootContext(opts.scheduler, opts.playerHandler);\n\n  const renderer = rendererFactory.createRenderer(hostRNode, componentDef);\n  const rootView: LView = createLView(\n      null, createTView(-1, null, 1, 0, null, null, null), rootContext, rootFlags, rendererFactory,\n      renderer, undefined, opts.injector || null);\n\n  const oldView = enterView(rootView, null);\n  let component: T;\n  try {\n    if (rendererFactory.begin) rendererFactory.begin();\n    const componentView = createRootComponentView(\n        hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\n    component = createRootComponent(\n        componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\n\n    refreshDescendantViews(rootView);  // creation mode pass\n    rootView[FLAGS] &= ~LViewFlags.CreationMode;\n    refreshDescendantViews(rootView);  // update mode pass\n  } finally {\n    leaveView(oldView);\n    if (rendererFactory.end) rendererFactory.end();\n  }\n\n  return component;\n}\n\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param renderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport function createRootComponentView(\n    rNode: RElement | null, def: ComponentDef<any>, rootView: LView,\n    rendererFactory: RendererFactory3, renderer: Renderer3, sanitizer?: Sanitizer | null): LView {\n  resetComponentState();\n  const tView = rootView[TVIEW];\n  const componentView = createLView(\n      rootView,\n      getOrCreateTView(\n          def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery),\n      null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, rendererFactory, renderer,\n      sanitizer);\n  const tNode = createNodeAtIndex(0, TNodeType.Element, rNode, null, null);\n\n  if (tView.firstTemplatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), rootView, def.type);\n    tNode.flags = TNodeFlags.isComponent;\n    initNodeFlags(tNode, rootView.length, 1);\n    queueComponentIndexForCheck(tNode);\n  }\n\n  // Store component view at node index, with node as the HOST\n  componentView[HOST] = rootView[HEADER_OFFSET];\n  componentView[HOST_NODE] = tNode as TElementNode;\n  return rootView[HEADER_OFFSET] = componentView;\n}\n\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport function createRootComponent<T>(\n    componentView: LView, componentDef: ComponentDef<T>, rootView: LView, rootContext: RootContext,\n    hostFeatures: HostFeature[] | null): any {\n  const tView = rootView[TVIEW];\n  // Create directive instance with factory() and store at next index in viewData\n  const component = instantiateRootComponent(tView, rootView, componentDef);\n\n  rootContext.components.push(component);\n  componentView[CONTEXT] = component;\n\n  hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));\n\n  if (tView.firstTemplatePass && componentDef.hostBindings) {\n    const rootTNode = getPreviousOrParentTNode();\n    setCurrentDirectiveDef(componentDef);\n    componentDef.hostBindings(RenderFlags.Create, component, rootTNode.index - HEADER_OFFSET);\n    setCurrentDirectiveDef(null);\n  }\n\n  return component;\n}\n\n\nexport function createRootContext(\n    scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler|null): RootContext {\n  return {\n    components: [],\n    scheduler: scheduler || defaultScheduler,\n    clean: CLEAN_PROMISE,\n    playerHandler: playerHandler || null,\n    flags: RootContextFlags.Empty\n  };\n}\n\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {features: [RootLifecycleHooks]});\n * ```\n */\nexport function LifecycleHooksFeature(component: any, def: ComponentDef<any>): void {\n  const rootTView = readPatchedLView(component) ![TVIEW];\n  const dirIndex = rootTView.data.length - 1;\n\n  queueInitHooks(dirIndex, def.onInit, def.doCheck, rootTView);\n  // TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on\n  // LNode).\n  queueLifecycleHooks(rootTView, { directiveStart: dirIndex, directiveEnd: dirIndex + 1 } as TNode);\n}\n\n/**\n * Retrieve the root context for any component by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param component any component\n */\nfunction getRootContext(component: any): RootContext {\n  const rootContext = getRootView(component)[CONTEXT] as RootContext;\n  ngDevMode && assertDefined(rootContext, 'rootContext');\n  return rootContext;\n}\n\n\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nexport function whenRendered(component: any): Promise<null> {\n  return getRootContext(component).clean;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function noop(...args: any[]): any {\n  // Do nothing.\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectInjector} from '../render3/di';\nimport {Type} from '../type';\nimport {stringify} from '../util';\nimport {noop} from '../util/noop';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {InjectFlags, inject} from './injector_compatibility';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if(ngDevMode) debugger;\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  /** @nocollapse */\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => Injector = () => SWITCH_INJECTOR_FACTORY();\n}\n\nexport const SWITCH_INJECTOR_FACTORY__POST_R3__ = function() {\n  return injectInjector();\n};\nconst SWITCH_INJECTOR_FACTORY__PRE_R3__ = noop;\nconst SWITCH_INJECTOR_FACTORY: typeof injectInjector = SWITCH_INJECTOR_FACTORY__PRE_R3__;\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'Éµ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {InjectionToken} from './injection_token';\n\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport const APP_ROOT = new InjectionToken<boolean>(\n    'The presence of this token marks an injector as being the root injector.');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef} from '../change_detection/change_detection';\nimport {Injector} from '../di/injector';\nimport {Type} from '../type';\n\nimport {ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {ViewRef} from './view_ref';\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nexport abstract class ComponentRef<C> {\n  /**\n   * The host or anchor [element](guide/glossary#element) for this component instance.\n   */\n  abstract get location(): ElementRef;\n\n  /**\n   * The [dependency injector](guide/glossary#injector) for this component instance.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * This component instance.\n   */\n  abstract get instance(): C;\n\n  /**\n   * The [host view](guide/glossary#view-tree) defined by the template\n   * for this component instance.\n   */\n  abstract get hostView(): ViewRef;\n\n  /**\n   * The change detector for this component instance.\n   */\n  abstract get changeDetectorRef(): ChangeDetectorRef;\n\n  /**\n   * The component type.\n   */\n  abstract get componentType(): Type<any>;\n\n  /**\n   * Destroys the component instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * A lifecycle hook that provides additional developer-defined cleanup\n   * functionality for the component.\n   * @param callback A handler function that cleans up developer-defined data\n   * associated with this component. Called when the `destroy()` method is invoked.\n   */\n  abstract onDestroy(callback: Function): void;\n}\n\n/**\n * @publicApi\n */\nexport abstract class ComponentFactory<C> {\n  /**\n   * The component's HTML selector.\n   */\n  abstract get selector(): string;\n  /**\n   * The component's type\n   */\n  abstract get componentType(): Type<any>;\n  /**\n   * Selector for all <ng-content> elements in the component.\n   */\n  abstract get ngContentSelectors(): string[];\n  /**\n   * The inputs of the component.\n   */\n  abstract get inputs(): {propName: string, templateName: string}[];\n  /**\n   * The outputs of the component.\n   */\n  abstract get outputs(): {propName: string, templateName: string}[];\n  /**\n   * Creates a new component.\n   */\n  abstract create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {NgModuleRef} from './ng_module_factory';\n\nexport function noComponentFactoryError(component: Function) {\n  const error = Error(\n      `No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n  (error as any)[ERROR_COMPONENT] = component;\n  return error;\n}\n\nconst ERROR_COMPONENT = 'ngComponent';\n\nexport function getComponent(error: Error): Type<any> {\n  return (error as any)[ERROR_COMPONENT];\n}\n\n\nclass _NullComponentFactoryResolver implements ComponentFactoryResolver {\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    throw noComponentFactoryError(component);\n  }\n}\n\n/**\n * @publicApi\n */\nexport abstract class ComponentFactoryResolver {\n  static NULL: ComponentFactoryResolver = new _NullComponentFactoryResolver();\n  abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\n\nexport class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\n  private _factories = new Map<any, ComponentFactory<any>>();\n\n  constructor(\n      factories: ComponentFactory<any>[], private _parent: ComponentFactoryResolver,\n      private _ngModule: NgModuleRef<any>) {\n    for (let i = 0; i < factories.length; i++) {\n      const factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    let factory = this._factories.get(component);\n    if (!factory && this._parent) {\n      factory = this._parent.resolveComponentFactory(component);\n    }\n    if (!factory) {\n      throw noComponentFactoryError(component);\n    }\n    return new ComponentFactoryBoundToModule(factory, this._ngModule);\n  }\n}\n\nexport class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {\n  readonly selector: string;\n  readonly componentType: Type<any>;\n  readonly ngContentSelectors: string[];\n  readonly inputs: {propName: string, templateName: string}[];\n  readonly outputs: {propName: string, templateName: string}[];\n\n  constructor(private factory: ComponentFactory<C>, private ngModule: NgModuleRef<any>) {\n    super();\n    this.selector = factory.selector;\n    this.componentType = factory.componentType;\n    this.ngContentSelectors = factory.ngContentSelectors;\n    this.inputs = factory.inputs;\n    this.outputs = factory.outputs;\n  }\n\n  create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C> {\n    return this.factory.create(\n        injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {Injector, NullInjector} from '../di/injector';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ElementRef as ViewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {TemplateRef as ViewEngine_TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef as ViewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, ViewRef as viewEngine_ViewRef} from '../linker/view_ref';\nimport {Renderer2} from '../render/api';\nimport {assertDefined, assertGreaterThan, assertLessThan} from './assert';\nimport {NodeInjector, getParentInjectorLocation} from './di';\nimport {addToViewTree, createEmbeddedViewAndNode, createLContainer, renderEmbeddedTemplate} from './instructions';\nimport {ACTIVE_INDEX, LContainer, NATIVE, VIEWS} from './interfaces/container';\nimport {RenderFlags} from './interfaces/definition';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeType, TViewNode} from './interfaces/node';\nimport {LQueries} from './interfaces/query';\nimport {RComment, RElement, Renderer3, isProceduralRenderer} from './interfaces/renderer';\nimport {CONTAINER_INDEX, CONTEXT, HOST_NODE, LView, QUERIES, RENDERER, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {addRemoveViewFromContainer, appendChild, detachView, getBeforeNodeForView, insertView, nativeInsertBefore, nativeNextSibling, nativeParentNode, removeView} from './node_manipulation';\nimport {getLView, getPreviousOrParentTNode} from './state';\nimport {findComponentView, getComponentViewByIndex, getNativeByTNode, getParentInjectorTNode, getParentInjectorView, hasParentInjector, isComponent, isLContainer, isRootView} from './util';\nimport {ViewRef} from './view_ref';\n\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(ElementRefToken: typeof ViewEngine_ElementRef):\n    ViewEngine_ElementRef {\n  return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());\n}\n\nlet R3ElementRef: {new (native: RElement | RComment): ViewEngine_ElementRef};\n\n/**\n * Creates an ElementRef given a node.\n *\n * @param ElementRefToken The ElementRef type\n * @param tNode The node for which you'd like an ElementRef\n * @param view The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nexport function createElementRef(\n    ElementRefToken: typeof ViewEngine_ElementRef, tNode: TNode,\n    view: LView): ViewEngine_ElementRef {\n  if (!R3ElementRef) {\n    // TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug\n    R3ElementRef = class ElementRef_ extends ElementRefToken {};\n  }\n  return new R3ElementRef(getNativeByTNode(tNode, view));\n}\n\nlet R3TemplateRef: {\n  new (\n      _declarationParentView: LView, elementRef: ViewEngine_ElementRef, _tView: TView,\n      _renderer: Renderer3, _queries: LQueries | null, _injectorIndex: number):\n      ViewEngine_TemplateRef<any>\n};\n\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(\n    TemplateRefToken: typeof ViewEngine_TemplateRef,\n    ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_TemplateRef<T>|null {\n  return createTemplateRef<T>(\n      TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param TemplateRefToken The TemplateRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a TemplateRef\n * @param hostView The view to which the node belongs\n * @returns The TemplateRef instance to use\n */\nexport function createTemplateRef<T>(\n    TemplateRefToken: typeof ViewEngine_TemplateRef, ElementRefToken: typeof ViewEngine_ElementRef,\n    hostTNode: TNode, hostView: LView): ViewEngine_TemplateRef<T>|null {\n  if (!R3TemplateRef) {\n    // TODO: Fix class name, should be TemplateRef, but there appears to be a rollup bug\n    R3TemplateRef = class TemplateRef_<T> extends TemplateRefToken<T> {\n      constructor(\n          private _declarationParentView: LView, readonly elementRef: ViewEngine_ElementRef,\n          private _tView: TView, private _renderer: Renderer3, private _queries: LQueries|null,\n          private _injectorIndex: number) {\n        super();\n      }\n\n      createEmbeddedView(\n          context: T, container?: LContainer,\n          hostTNode?: TElementNode|TContainerNode|TElementContainerNode, hostView?: LView,\n          index?: number): viewEngine_EmbeddedViewRef<T> {\n        const lView = createEmbeddedViewAndNode(\n            this._tView, context, this._declarationParentView, this._renderer, this._queries,\n            this._injectorIndex);\n        if (container) {\n          insertView(lView, container, hostView !, index !, hostTNode !.index);\n        }\n        renderEmbeddedTemplate(lView, this._tView, context);\n        const viewRef = new ViewRef(lView, context, -1);\n        viewRef._tViewNode = lView[HOST_NODE] as TViewNode;\n        return viewRef;\n      }\n    };\n  }\n\n  if (hostTNode.type === TNodeType.Container) {\n    const hostContainer: LContainer = hostView[hostTNode.index];\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    return new R3TemplateRef(\n        hostView, createElementRef(ElementRefToken, hostTNode, hostView), hostTNode.tViews as TView,\n        getLView()[RENDERER], hostContainer[QUERIES], hostTNode.injectorIndex);\n  } else {\n    return null;\n  }\n}\n\nlet R3ViewContainerRef: {\n  new (\n      lContainer: LContainer, hostTNode: TElementNode | TContainerNode | TElementContainerNode,\n      hostView: LView): ViewEngine_ViewContainerRef\n};\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(\n    ViewContainerRefToken: typeof ViewEngine_ViewContainerRef,\n    ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_ViewContainerRef {\n  const previousTNode =\n      getPreviousOrParentTNode() as TElementNode | TElementContainerNode | TContainerNode;\n  return createContainerRef(ViewContainerRefToken, ElementRefToken, previousTNode, getLView());\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nexport function createContainerRef(\n    ViewContainerRefToken: typeof ViewEngine_ViewContainerRef,\n    ElementRefToken: typeof ViewEngine_ElementRef,\n    hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n    hostView: LView): ViewEngine_ViewContainerRef {\n  if (!R3ViewContainerRef) {\n    // TODO: Fix class name, should be ViewContainerRef, but there appears to be a rollup bug\n    R3ViewContainerRef = class ViewContainerRef_ extends ViewContainerRefToken {\n      private _viewRefs: viewEngine_ViewRef[] = [];\n\n      constructor(\n          private _lContainer: LContainer,\n          private _hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n          private _hostView: LView) {\n        super();\n      }\n\n      get element(): ViewEngine_ElementRef {\n        return createElementRef(ElementRefToken, this._hostTNode, this._hostView);\n      }\n\n      get injector(): Injector { return new NodeInjector(this._hostTNode, this._hostView); }\n\n      /** @deprecated No replacement */\n      get parentInjector(): Injector {\n        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView);\n        const parentView = getParentInjectorView(parentLocation, this._hostView);\n        const parentTNode = getParentInjectorTNode(parentLocation, this._hostView, this._hostTNode);\n\n        return !hasParentInjector(parentLocation) || parentTNode == null ?\n            new NodeInjector(null, this._hostView) :\n            new NodeInjector(parentTNode, parentView);\n      }\n\n      clear(): void {\n        while (this._lContainer[VIEWS].length) {\n          this.remove(0);\n        }\n      }\n\n      get(index: number): viewEngine_ViewRef|null { return this._viewRefs[index] || null; }\n\n      get length(): number { return this._lContainer[VIEWS].length; }\n\n      createEmbeddedView<C>(templateRef: ViewEngine_TemplateRef<C>, context?: C, index?: number):\n          viewEngine_EmbeddedViewRef<C> {\n        const adjustedIdx = this._adjustIndex(index);\n        const viewRef = (templateRef as any)\n                            .createEmbeddedView(\n                                context || <any>{}, this._lContainer, this._hostTNode,\n                                this._hostView, adjustedIdx);\n        (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n        this._viewRefs.splice(adjustedIdx, 0, viewRef);\n        return viewRef;\n      }\n\n      createComponent<C>(\n          componentFactory: viewEngine_ComponentFactory<C>, index?: number|undefined,\n          injector?: Injector|undefined, projectableNodes?: any[][]|undefined,\n          ngModuleRef?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<C> {\n        const contextInjector = injector || this.parentInjector;\n        if (!ngModuleRef && (componentFactory as any).ngModule == null && contextInjector) {\n          ngModuleRef = contextInjector.get(viewEngine_NgModuleRef, null);\n        }\n\n        const componentRef =\n            componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\n        this.insert(componentRef.hostView, index);\n        return componentRef;\n      }\n\n      insert(viewRef: viewEngine_ViewRef, index?: number): viewEngine_ViewRef {\n        if (viewRef.destroyed) {\n          throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n        }\n        const lView = (viewRef as ViewRef<any>)._lView !;\n        const adjustedIdx = this._adjustIndex(index);\n\n        insertView(lView, this._lContainer, this._hostView, adjustedIdx, this._hostTNode.index);\n\n        const beforeNode =\n            getBeforeNodeForView(adjustedIdx, this._lContainer[VIEWS], this._lContainer[NATIVE]);\n        addRemoveViewFromContainer(lView, true, beforeNode);\n\n        (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n        this._viewRefs.splice(adjustedIdx, 0, viewRef);\n\n        return viewRef;\n      }\n\n      move(viewRef: viewEngine_ViewRef, newIndex: number): viewEngine_ViewRef {\n        if (viewRef.destroyed) {\n          throw new Error('Cannot move a destroyed View in a ViewContainer!');\n        }\n        const index = this.indexOf(viewRef);\n        this.detach(index);\n        this.insert(viewRef, this._adjustIndex(newIndex));\n        return viewRef;\n      }\n\n      indexOf(viewRef: viewEngine_ViewRef): number { return this._viewRefs.indexOf(viewRef); }\n\n      remove(index?: number): void {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        removeView(this._lContainer, this._hostTNode, adjustedIdx);\n        this._viewRefs.splice(adjustedIdx, 1);\n      }\n\n      detach(index?: number): viewEngine_ViewRef|null {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const view = detachView(this._lContainer, adjustedIdx, !!this._hostTNode.detached);\n        const wasDetached = this._viewRefs.splice(adjustedIdx, 1)[0] != null;\n        return wasDetached ? new ViewRef(view, view[CONTEXT], view[CONTAINER_INDEX]) : null;\n      }\n\n      private _adjustIndex(index?: number, shift: number = 0) {\n        if (index == null) {\n          return this._lContainer[VIEWS].length + shift;\n        }\n        if (ngDevMode) {\n          assertGreaterThan(index, -1, 'index must be positive');\n          // +1 because it's legal to insert at the end.\n          assertLessThan(index, this._lContainer[VIEWS].length + 1 + shift, 'index');\n        }\n        return index;\n      }\n    };\n  }\n\n  ngDevMode && assertNodeOfPossibleTypes(\n                   hostTNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n\n  let lContainer: LContainer;\n  const slotValue = hostView[hostTNode.index];\n  if (isLContainer(slotValue)) {\n    // If the host is a container, we don't need to create a new LContainer\n    lContainer = slotValue;\n    lContainer[ACTIVE_INDEX] = -1;\n  } else {\n    const commentNode = hostView[RENDERER].createComment(ngDevMode ? 'container' : '');\n    ngDevMode && ngDevMode.rendererCreateComment++;\n\n    // A container can be created on the root (topmost / bootstrapped) component and in this case we\n    // can't use LTree to insert container's marker node (both parent of a comment node and the\n    // commend node itself is located outside of elements hold by LTree). In this specific case we\n    // use low-level DOM manipulation to insert container's marker (comment) node.\n    if (isRootView(hostView)) {\n      const renderer = hostView[RENDERER];\n      const hostNative = getNativeByTNode(hostTNode, hostView) !;\n      const parentOfHostNative = nativeParentNode(renderer, hostNative);\n      nativeInsertBefore(\n          renderer, parentOfHostNative !, commentNode, nativeNextSibling(renderer, hostNative));\n    } else {\n      appendChild(commentNode, hostTNode, hostView);\n    }\n\n    hostView[hostTNode.index] = lContainer =\n        createLContainer(slotValue, hostTNode, hostView, commentNode, true);\n\n    addToViewTree(hostView, hostTNode.index as number, lContainer);\n  }\n\n  return new R3ViewContainerRef(lContainer, hostTNode, hostView);\n}\n\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport function injectChangeDetectorRef(): ViewEngine_ChangeDetectorRef {\n  return createViewRef(getPreviousOrParentTNode(), getLView(), null);\n}\n\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n *\n * @param hostTNode The node that is requesting a ChangeDetectorRef\n * @param hostView The view to which the node belongs\n * @param context The context for this change detector ref\n * @returns The ChangeDetectorRef to use\n */\nexport function createViewRef(\n    hostTNode: TNode, hostView: LView, context: any): ViewEngine_ChangeDetectorRef {\n  if (isComponent(hostTNode)) {\n    const componentIndex = hostTNode.directiveStart;\n    const componentView = getComponentViewByIndex(hostTNode.index, hostView);\n    return new ViewRef(componentView, context, componentIndex);\n  } else if (hostTNode.type === TNodeType.Element) {\n    const hostComponentView = findComponentView(hostView);\n    return new ViewRef(hostComponentView, hostComponentView[CONTEXT], -1);\n  }\n  return null !;\n}\n\nfunction getOrCreateRenderer2(view: LView): Renderer2 {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer)) {\n    return renderer as Renderer2;\n  } else {\n    throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\n  }\n}\n\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\nexport function injectRenderer2(): Renderer2 {\n  return getOrCreateRenderer2(getLView());\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    this.major = full.split('.')[0];\n    this.minor = full.split('.')[1];\n    this.patch = full.split('.').slice(2).join('.');\n  }\n}\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('0.0.0-PLACEHOLDER');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../type';\n\nimport {ComponentFactoryResolver} from './component_factory_resolver';\n\n\n/**\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n *\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n * NgModule Instance.\n *\n * @publicApi\n */\nexport abstract class NgModuleRef<T> {\n  /**\n   * The injector that contains all of the providers of the NgModule.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * The ComponentFactoryResolver to get hold of the ComponentFactories\n   * declared in the `entryComponents` property of the module.\n   */\n  abstract get componentFactoryResolver(): ComponentFactoryResolver;\n\n  /**\n   * The NgModule instance.\n   */\n  abstract get instance(): T;\n\n  /**\n   * Destroys the module instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Allows to register a callback that will be called when the module is destroyed.\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _bootstrapComponents: Type<any>[];\n}\n\n/**\n * @publicApi\n */\nexport abstract class NgModuleFactory<T> {\n  abstract get moduleType(): Type<T>;\n  abstract create(parentInjector: Injector|null): NgModuleRef<T>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef} from '../linker/view_ref';\n\nimport {checkNoChanges, checkNoChangesInRootView, checkView, detectChangesInRootView, detectChangesInternal, markViewDirty, storeCleanupFn, viewAttached} from './instructions';\nimport {TNode, TNodeType, TViewNode} from './interfaces/node';\nimport {FLAGS, HOST, HOST_NODE, LView, LViewFlags, PARENT, RENDERER_FACTORY} from './interfaces/view';\nimport {destroyLView} from './node_manipulation';\nimport {getNativeByTNode} from './util';\n\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n    viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ApplicationRef|null = null;\n  private _viewContainerRef: viewEngine_ViewContainerRef|null = null;\n\n  /**\n   * @internal\n   */\n  public _tViewNode: TViewNode|null = null;\n\n  /**\n   * @internal\n   */\n  public _lView: LView;\n\n  get rootNodes(): any[] {\n    if (this._lView[HOST] == null) {\n      const tView = this._lView[HOST_NODE] as TViewNode;\n      return collectNativeNodes(this._lView, tView, []);\n    }\n    return [];\n  }\n\n  constructor(_lView: LView, private _context: T|null, private _componentIndex: number) {\n    this._lView = _lView;\n  }\n\n  get context(): T { return this._context ? this._context : this._lookUpContext(); }\n\n  get destroyed(): boolean {\n    return (this._lView[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef) {\n      const index = this._viewContainerRef.indexOf(this);\n\n      if (index > -1) {\n        this._viewContainerRef.detach(index);\n      }\n\n      this._viewContainerRef = null;\n    }\n    destroyLView(this._lView);\n  }\n\n  onDestroy(callback: Function) { storeCleanupFn(this._lView, callback); }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void { markViewDirty(this._lView); }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void { this._lView[FLAGS] &= ~LViewFlags.Attached; }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void { this._lView[FLAGS] |= LViewFlags.Attached; }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void { detectChangesInternal(this._lView, this.context); }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void { checkNoChanges(this.context); }\n\n  attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef) {\n    if (this._appRef) {\n      throw new Error('This view is already attached directly to the ApplicationRef!');\n    }\n    this._viewContainerRef = vcRef;\n  }\n\n  detachFromAppRef() { this._appRef = null; }\n\n  attachToAppRef(appRef: ApplicationRef) {\n    if (this._viewContainerRef) {\n      throw new Error('This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n\n  private _lookUpContext(): T {\n    return this._context = this._lView[PARENT] ![this._componentIndex] as T;\n  }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(public _view: LView) { super(_view, null, -1); }\n\n  detectChanges(): void { detectChangesInRootView(this._view); }\n\n  checkNoChanges(): void { checkNoChangesInRootView(this._view); }\n\n  get context(): T { return null !; }\n}\n\nfunction collectNativeNodes(lView: LView, parentTNode: TNode, result: any[]): any[] {\n  let tNodeChild = parentTNode.child;\n\n  while (tNodeChild) {\n    result.push(getNativeByTNode(tNodeChild, lView));\n    if (tNodeChild.type === TNodeType.ElementContainer) {\n      collectNativeNodes(lView, tNodeChild, result);\n    }\n    tNodeChild = tNodeChild.next;\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectElementRef as render3InjectElementRef} from '../render3/view_engine_compatibility';\nimport {noop} from '../util/noop';\n\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](http://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef<T = any> {\n  /**\n   * The underlying native element or `null` if direct access to native elements is not supported\n   * (e.g. when the application runs in a web worker).\n   *\n   * <div class=\"callout is-critical\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\n   * Renderer2}\n   *    which provides API that can safely be used even when direct access to native elements is not\n   *    supported.\n   *   </p>\n   *   <p>\n   *    Relying on direct DOM access creates tight coupling between your application and rendering\n   *    layers which will make it impossible to separate the two and deploy your application into a\n   *    web worker.\n   *   </p>\n   * </div>\n   *\n   */\n  public nativeElement: T;\n\n  constructor(nativeElement: T) { this.nativeElement = nativeElement; }\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => ElementRef = () => SWITCH_ELEMENT_REF_FACTORY(ElementRef);\n}\n\nexport const SWITCH_ELEMENT_REF_FACTORY__POST_R3__ = render3InjectElementRef;\nconst SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop;\nconst SWITCH_ELEMENT_REF_FACTORY: typeof render3InjectElementRef =\n    SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {injectRenderer2 as render3InjectRenderer2} from '../render3/view_engine_compatibility';\nimport {noop} from '../util/noop';\n\n\n/**\n * @deprecated Use `RendererType2` (and `Renderer2`) instead.\n * @publicApi\n */\nexport class RenderComponentType {\n  constructor(\n      public id: string, public templateUrl: string, public slotCount: number,\n      public encapsulation: ViewEncapsulation, public styles: Array<string|any[]>,\n      public animations: any) {}\n}\n\n/**\n * @deprecated Debug info is handled internally in the view engine now.\n */\nexport abstract class RenderDebugInfo {\n  abstract get injector(): Injector;\n  abstract get component(): any;\n  abstract get providerTokens(): any[];\n  abstract get references(): {[key: string]: any};\n  abstract get context(): any;\n  abstract get source(): string;\n}\n\n/**\n * @deprecated Use the `Renderer2` instead.\n */\nexport interface DirectRenderer {\n  remove(node: any): void;\n  appendChild(node: any, parent: any): void;\n  insertBefore(node: any, refNode: any): void;\n  nextSibling(node: any): any;\n  parentElement(node: any): any;\n}\n\n/**\n * @deprecated Use the `Renderer2` instead.\n * @publicApi\n */\nexport abstract class Renderer {\n  abstract selectRootElement(selectorOrNode: string|any, debugInfo?: RenderDebugInfo): any;\n\n  abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;\n\n  abstract createViewRoot(hostElement: any): any;\n\n  abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;\n\n  abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;\n\n  abstract projectNodes(parentElement: any, nodes: any[]): void;\n\n  abstract attachViewAfter(node: any, viewRootNodes: any[]): void;\n\n  abstract detachView(viewRootNodes: any[]): void;\n\n  abstract destroyView(hostElement: any, viewAllNodes: any[]): void;\n\n  abstract listen(renderElement: any, name: string, callback: Function): Function;\n\n  abstract listenGlobal(target: string, name: string, callback: Function): Function;\n\n  abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;\n\n  abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue?: string):\n      void;\n\n  /**\n   * Used only in debug mode to serialize property changes to dom nodes as attributes.\n   */\n  abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string):\n      void;\n\n  abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;\n\n  abstract setElementStyle(renderElement: any, styleName: string, styleValue?: string): void;\n\n  abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;\n\n  abstract setText(renderNode: any, text: string): void;\n\n  abstract animate(\n      element: any, startingStyles: any, keyframes: any[], duration: number, delay: number,\n      easing: string, previousPlayers?: any[]): any;\n}\n\nexport const Renderer2Interceptor = new InjectionToken<Renderer2[]>('Renderer2Interceptor');\n\n/**\n * Injectable service that provides a low-level interface for modifying the UI.\n *\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\n * not statically known, use {@link Renderer#setElementProperty setElementProperty} or\n * {@link Renderer#setElementAttribute setElementAttribute} respectively.\n *\n * If you are implementing a custom renderer, you must implement this interface.\n *\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\n *\n * @deprecated Use `RendererFactory2` instead.\n * @publicApi\n */\nexport abstract class RootRenderer {\n  abstract renderComponent(componentType: RenderComponentType): Renderer;\n}\n\n/**\n * Used by `RendererFactory2` to associate custom rendering data and styles\n * with a rendering implementation.\n *  @publicApi\n */\nexport interface RendererType2 {\n  /**\n   * A unique identifying string for the new renderer, used when creating\n   * unique styles for encapsulation.\n   */\n  id: string;\n  /**\n   * The view encapsulation type, which determines how styles are applied to\n   * DOM elements. One of\n   * - `Emulated` (default): Emulate native scoping of styles.\n   * - `Native`: Use the native encapsulation mechanism of the renderer.\n   * - `ShadowDom`: Use modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * create a ShadowRoot for component's host element.\n   * - `None`: Do not provide any template or style encapsulation.\n   */\n  encapsulation: ViewEncapsulation;\n  /**\n   * Defines CSS styles to be stored on a renderer instance.\n   */\n  styles: (string|any[])[];\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  data: {[kind: string]: any};\n}\n\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nexport abstract class RendererFactory2 {\n  /**\n   * Creates and initializes a custom renderer for a host DOM element.\n   * @param hostElement The element to render.\n   * @param type The base class to implement.\n   * @returns The new custom renderer instance.\n   */\n  abstract createRenderer(hostElement: any, type: RendererType2|null): Renderer2;\n  /**\n   * A callback invoked when rendering has begun.\n   */\n  abstract begin?(): void;\n  /**\n   * A callback invoked when rendering has completed.\n   */\n  abstract end?(): void;\n  /**\n   * Use with animations test-only mode. Notifies the test when rendering has completed.\n   * @returns The asynchronous result of the developer-defined function.\n   */\n  abstract whenRenderingDone?(): Promise<any>;\n}\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nexport enum RendererStyleFlags2 {\n  /**\n   * Marks a style as important.\n   */\n  Important = 1 << 0,\n  /**\n   * Marks a style as using dash case naming (this-is-dash-case).\n   */\n  DashCase = 1 << 1\n}\n\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nexport abstract class Renderer2 {\n  /**\n   * Use to store arbitrary developer-defined data on a renderer instance,\n   * as an object containing key-value pairs.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  abstract get data(): {[key: string]: any};\n\n  /**\n   * Implement this callback to destroy the renderer or the host element.\n   */\n  abstract destroy(): void;\n  /**\n   * Implement this callback to create an instance of the host element.\n   * @param name An identifying name for the new element, unique within the namespace.\n   * @param namespace The namespace for the new element.\n   * @returns The new element.\n   */\n  abstract createElement(name: string, namespace?: string|null): any;\n  /**\n   * Implement this callback to add a comment to the DOM of the host element.\n   * @param value The comment text.\n   * @returns The modified element.\n   */\n  abstract createComment(value: string): any;\n\n  /**\n   * Implement this callback to add text to the DOM of the host element.\n   * @param value The text string.\n   * @returns The modified element.\n   */\n  abstract createText(value: string): any;\n  /**\n   * If null or undefined, the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  // TODO(issue/24571): remove '!'.\n  destroyNode !: ((node: any) => void) | null;\n  /**\n   * Appends a child to a given parent node in the host element DOM.\n   * @param parent The parent node.\n   * @param newChild The new child node.\n   */\n  abstract appendChild(parent: any, newChild: any): void;\n  /**\n   * Implement this callback to insert a child node at a given position in a parent node\n   * in the host element DOM.\n   * @param parent The parent node.\n   * @param newChild The new child nodes.\n   * @param refChild The existing child node that should precede the new node.\n   */\n  abstract insertBefore(parent: any, newChild: any, refChild: any): void;\n  /**\n   * Implement this callback to remove a child node from the host element's DOM.\n   * @param parent The parent node.\n   * @param oldChild The child node to remove.\n   */\n  abstract removeChild(parent: any, oldChild: any): void;\n  /**\n   * Implement this callback to prepare an element to be bootstrapped\n   * as a root element, and return the element instance.\n   * @param selectorOrNode The DOM element.\n   * @param preserveContent Whether the contents of the root element\n   * should be preserved, or cleared upon bootstrap (default behavior).\n   * Use with `ViewEncapsulation.ShadowDom` to allow simple native\n   * content projection via `<slot>` elements.\n   * @returns The root element.\n   */\n  abstract selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): any;\n  /**\n   * Implement this callback to get the parent of a given node\n   * in the host element's DOM.\n   * @param node The child node to query.\n   * @returns The parent node, or null if there is no parent.\n   * For WebWorkers, always returns true.\n   * This is because the check is synchronous,\n   * and the caller can't rely on checking for null.\n   */\n  abstract parentNode(node: any): any;\n  /**\n   * Implement this callback to get the next sibling node of a given node\n   * in the host element's DOM.\n   * @returns The sibling node, or null if there is no sibling.\n   * For WebWorkers, always returns a value.\n   * This is because the check is synchronous,\n   * and the caller can't rely on checking for null.\n   */\n  abstract nextSibling(node: any): any;\n  /**\n   * Implement this callback to set an attribute value for an element in the DOM.\n   * @param el The element.\n   * @param name The attribute name.\n   * @param value The new value.\n   * @param namespace The namespace.\n   */\n  abstract setAttribute(el: any, name: string, value: string, namespace?: string|null): void;\n\n  /**\n   * Implement this callback to remove an attribute from an element in the DOM.\n   * @param el The element.\n   * @param name The attribute name.\n   * @param namespace The namespace.\n   */\n  abstract removeAttribute(el: any, name: string, namespace?: string|null): void;\n  /**\n   * Implement this callback to add a class to an element in the DOM.\n   * @param el The element.\n   * @param name The class name.\n   */\n  abstract addClass(el: any, name: string): void;\n\n  /**\n   * Implement this callback to remove a class from an element in the DOM.\n   * @param el The element.\n   * @param name The class name.\n   */\n  abstract removeClass(el: any, name: string): void;\n\n  /**\n   * Implement this callback to set a CSS style for an element in the DOM.\n   * @param el The element.\n   * @param style The name of the style.\n   * @param value The new value.\n   * @param flags Flags for style variations. No flags are set by default.\n   */\n  abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;\n\n  /**\n   * Implement this callback to remove the value from a CSS style for an element in the DOM.\n   * @param el The element.\n   * @param style The name of the style.\n   * @param flags Flags for style variations to remove, if set. ???\n   */\n  abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\n\n  /**\n   * Implement this callback to set the value of a property of an element in the DOM.\n   * @param el The element.\n   * @param name The property name.\n   * @param value The new value.\n   */\n  abstract setProperty(el: any, name: string, value: any): void;\n\n  /**\n   * Implement this callback to set the value of a node in the host element.\n   * @param node The node.\n   * @param value The new value.\n   */\n  abstract setValue(node: any, value: string): void;\n\n  /**\n   * Implement this callback to start an event listener.\n   * @param target The context in which to listen for events. Can be\n   * the entire window or document, the body of the document, or a specific\n   * DOM element.\n   * @param eventName The event to listen for.\n   * @param callback A handler function to invoke when the event occurs.\n   * @returns An \"unlisten\" function for disposing of this handler.\n   */\n  abstract listen(\n      target: 'window'|'document'|'body'|any, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => Renderer2 = () => SWITCH_RENDERER2_FACTORY();\n}\n\n\nexport const SWITCH_RENDERER2_FACTORY__POST_R3__ = render3InjectRenderer2;\nconst SWITCH_RENDERER2_FACTORY__PRE_R3__ = noop;\nconst SWITCH_RENDERER2_FACTORY: typeof render3InjectRenderer2 = SWITCH_RENDERER2_FACTORY__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nexport abstract class Sanitizer {\n  abstract sanitize(context: SecurityContext, value: {}|string|null): string|null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {inject} from '../di/injector_compatibility';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {RendererFactory2} from '../render/api';\nimport {Sanitizer} from '../sanitization/security';\nimport {Type} from '../type';\nimport {VERSION} from '../version';\nimport {assertComponentType, assertDefined} from './assert';\nimport {LifecycleHooksFeature, createRootComponent, createRootComponentView, createRootContext} from './component';\nimport {getComponentDef} from './definition';\nimport {NodeInjector} from './di';\nimport {addToViewTree, createLView, createNodeAtIndex, createTView, createViewNode, elementCreate, locateHostElement, refreshDescendantViews} from './instructions';\nimport {ComponentDef, RenderFlags} from './interfaces/definition';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeType} from './interfaces/node';\nimport {RElement, RendererFactory3, domRendererFactory3, isProceduralRenderer} from './interfaces/renderer';\nimport {HEADER_OFFSET, LView, LViewFlags, RootContext, TVIEW} from './interfaces/view';\nimport {enterView, leaveView} from './state';\nimport {defaultScheduler, getTNode} from './util';\nimport {createElementRef} from './view_engine_compatibility';\nimport {RootViewRef, ViewRef} from './view_ref';\n\nexport class ComponentFactoryResolver extends viewEngine_ComponentFactoryResolver {\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(private ngModule?: viewEngine_NgModuleRef<any>) { super(); }\n\n  resolveComponentFactory<T>(component: Type<T>): viewEngine_ComponentFactory<T> {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef(component) !;\n    return new ComponentFactory(componentDef, this.ngModule);\n  }\n}\n\nfunction toRefArray(map: {[key: string]: string}): {propName: string; templateName: string;}[] {\n  const array: {propName: string; templateName: string;}[] = [];\n  for (let nonMinified in map) {\n    if (map.hasOwnProperty(nonMinified)) {\n      const minified = map[nonMinified];\n      array.push({propName: minified, templateName: nonMinified});\n    }\n  }\n  return array;\n}\n\n/**\n * Default {@link RootContext} for all components rendered with {@link renderComponent}.\n */\nexport const ROOT_CONTEXT = new InjectionToken<RootContext>(\n    'ROOT_CONTEXT_TOKEN',\n    {providedIn: 'root', factory: () => createRootContext(inject(SCHEDULER))});\n\n/**\n * A change detection scheduler token for {@link RootContext}. This token is the default value used\n * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.\n */\nexport const SCHEDULER = new InjectionToken<((fn: () => void) => void)>('SCHEDULER_TOKEN', {\n  providedIn: 'root',\n  factory: () => defaultScheduler,\n});\n\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\nfunction createChainedInjector(rootViewInjector: Injector, moduleInjector: Injector): Injector {\n  return {\n    get: <T>(token: Type<T>| InjectionToken<T>, notFoundValue?: T): T => {\n      const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);\n\n      if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n          notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n        // Return the value from the root element injector when\n        // - it provides it\n        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n        // - the module injector should not be checked\n        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n        return value;\n      }\n\n      return moduleInjector.get(token, notFoundValue);\n    }\n  };\n}\n\n/**\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\n */\nexport class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\n  selector: string;\n  componentType: Type<any>;\n  ngContentSelectors: string[];\n\n  get inputs(): {propName: string; templateName: string;}[] {\n    return toRefArray(this.componentDef.inputs);\n  }\n\n  get outputs(): {propName: string; templateName: string;}[] {\n    return toRefArray(this.componentDef.outputs);\n  }\n\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(\n      private componentDef: ComponentDef<any>, private ngModule?: viewEngine_NgModuleRef<any>) {\n    super();\n    this.componentType = componentDef.type;\n    this.selector = componentDef.selectors[0][0] as string;\n    this.ngContentSelectors = [];\n  }\n\n  create(\n      injector: Injector, projectableNodes?: any[][]|undefined, rootSelectorOrNode?: any,\n      ngModule?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<T> {\n    const isInternalRootView = rootSelectorOrNode === undefined;\n    ngModule = ngModule || this.ngModule;\n\n    const rootViewInjector =\n        ngModule ? createChainedInjector(injector, ngModule.injector) : injector;\n\n    const rendererFactory =\n        rootViewInjector.get(RendererFactory2, domRendererFactory3) as RendererFactory3;\n    const sanitizer = rootViewInjector.get(Sanitizer, null);\n\n    const hostRNode = isInternalRootView ?\n        elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef)) :\n        locateHostElement(rendererFactory, rootSelectorOrNode);\n\n    const rootFlags = this.componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                                 LViewFlags.CheckAlways | LViewFlags.IsRoot;\n    const rootContext: RootContext =\n        !isInternalRootView ? rootViewInjector.get(ROOT_CONTEXT) : createRootContext();\n\n    const renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);\n\n    if (rootSelectorOrNode && hostRNode) {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      isProceduralRenderer(renderer) ?\n          renderer.setAttribute(hostRNode, 'ng-version', VERSION.full) :\n          hostRNode.setAttribute('ng-version', VERSION.full);\n    }\n\n    // Create the root view. Uses empty TView and ContentTemplate.\n    const rootLView = createLView(\n        null, createTView(-1, null, 1, 0, null, null, null), rootContext, rootFlags,\n        rendererFactory, renderer, sanitizer, rootViewInjector);\n\n    // rootView is the parent when bootstrapping\n    const oldLView = enterView(rootLView, null);\n\n    let component: T;\n    let tElementNode: TElementNode;\n    try {\n      if (rendererFactory.begin) rendererFactory.begin();\n\n      const componentView = createRootComponentView(\n          hostRNode, this.componentDef, rootLView, rendererFactory, renderer);\n\n      tElementNode = getTNode(0, rootLView) as TElementNode;\n\n      // Transform the arrays of native nodes into a structure that can be consumed by the\n      // projection instruction. This is needed to support the reprojection of these nodes.\n      if (projectableNodes) {\n        let index = 0;\n        const tView = rootLView[TVIEW];\n        const projection: TNode[] = tElementNode.projection = [];\n        for (let i = 0; i < projectableNodes.length; i++) {\n          const nodeList = projectableNodes[i];\n          let firstTNode: TNode|null = null;\n          let previousTNode: TNode|null = null;\n          for (let j = 0; j < nodeList.length; j++) {\n            if (tView.firstTemplatePass) {\n              // For dynamically created components such as ComponentRef, we create a new TView for\n              // each insert. This is not ideal since we should be sharing the TViews.\n              // Also the logic here should be shared with `component.ts`'s `renderComponent`\n              // method.\n              tView.expandoStartIndex++;\n              tView.blueprint.splice(++index + HEADER_OFFSET, 0, null);\n              tView.data.splice(index + HEADER_OFFSET, 0, null);\n              rootLView.splice(index + HEADER_OFFSET, 0, null);\n            }\n            const tNode =\n                createNodeAtIndex(index, TNodeType.Element, nodeList[j] as RElement, null, null);\n            previousTNode ? (previousTNode.next = tNode) : (firstTNode = tNode);\n            previousTNode = tNode;\n          }\n          projection.push(firstTNode !);\n        }\n      }\n\n      // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n      // executed here?\n      // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n      component = createRootComponent(\n          componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);\n\n      addToViewTree(rootLView, HEADER_OFFSET, componentView);\n      refreshDescendantViews(rootLView);\n    } finally {\n      leaveView(oldLView);\n      if (rendererFactory.end) rendererFactory.end();\n    }\n\n    const componentRef = new ComponentRef(\n        this.componentType, component,\n        createElementRef(viewEngine_ElementRef, tElementNode, rootLView), rootLView, tElementNode);\n\n    if (isInternalRootView) {\n      // The host element of the internal root view is attached to the component's host view node\n      componentRef.hostView._tViewNode !.child = tElementNode;\n    }\n    return componentRef;\n  }\n}\n\nconst componentFactoryResolver: ComponentFactoryResolver = new ComponentFactoryResolver();\n\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nexport function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver {\n  return componentFactoryResolver;\n}\n\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nexport class ComponentRef<T> extends viewEngine_ComponentRef<T> {\n  destroyCbs: (() => void)[]|null = [];\n  instance: T;\n  hostView: ViewRef<T>;\n  changeDetectorRef: ViewEngine_ChangeDetectorRef;\n  componentType: Type<T>;\n\n  constructor(\n      componentType: Type<T>, instance: T, public location: viewEngine_ElementRef,\n      private _rootLView: LView,\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode) {\n    super();\n    this.instance = instance;\n    this.hostView = this.changeDetectorRef = new RootViewRef<T>(_rootLView);\n    this.hostView._tViewNode = createViewNode(-1, _rootLView);\n    this.componentType = componentType;\n  }\n\n  get injector(): Injector { return new NodeInjector(this._tNode, this._rootLView); }\n\n  destroy(): void {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    this.destroyCbs !.forEach(fn => fn());\n    this.destroyCbs = null;\n    this.hostView.destroy();\n  }\n  onDestroy(callback: () => void): void {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    this.destroyCbs !.push(callback);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {NgModuleDef} from '../metadata/ng_module';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {Mutable, Type} from '../type';\nimport {noSideEffects, stringify} from '../util';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from './empty';\nimport {NG_COMPONENT_DEF, NG_DIRECTIVE_DEF, NG_MODULE_DEF, NG_PIPE_DEF} from './fields';\nimport {BaseDef, ComponentDef, ComponentDefFeature, ComponentQuery, ComponentTemplate, ComponentType, DirectiveDef, DirectiveDefFeature, DirectiveType, DirectiveTypesOrFactory, HostBindingsFunction, PipeDef, PipeType, PipeTypesOrFactory} from './interfaces/definition';\nimport {CssSelectorList} from './interfaces/projection';\n\nlet _renderCompCount = 0;\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ngComponentDef = defineComponent({\n *     ...\n *   });\n * }\n * ```\n */\nexport function defineComponent<T>(componentDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this component. */\n  selectors: CssSelectorList;\n\n  /**\n   * Factory method used to create an instance of directive.\n   */\n  factory: (t: Type<T>| null) => T;\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  consts: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  vars: number;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  attributes?: string[];\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['public', 'declared']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ((dirIndex: number) => void);\n\n  /** Refreshes content queries associated with directives in a given view */\n  contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string;\n\n  /**\n   * Template function use for rendering DOM.\n   *\n   * This function has following structure.\n   *\n   * ```\n   * function Template<T>(ctx:T, creationMode: boolean) {\n   *   if (creationMode) {\n   *     // Contains creation mode instructions.\n   *   }\n   *   // Contains binding update instructions\n   * }\n   * ```\n   *\n   * Common instructions are:\n   * Creation mode instructions:\n   *  - `elementStart`, `elementEnd`\n   *  - `text`\n   *  - `container`\n   *  - `listener`\n   *\n   * Binding update instructions:\n   * - `bind`\n   * - `elementAttribute`\n   * - `elementProperty`\n   * - `elementClass`\n   * - `elementStyle`\n   *\n   */\n  template: ComponentTemplate<T>;\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instruction to be inserted into the template function.\n   *\n   * Query-related instructions need to be pulled out to a specific function as a timing of\n   * execution is different as compared to all other instructions (after change detection hooks but\n   * before view hooks).\n   */\n  viewQuery?: ComponentQuery<T>| null;\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n   */\n  features?: ComponentDefFeature[];\n\n  /**\n   * Defines template and style encapsulation options available for Component's {@link Component}.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   *\n   * see: animation\n   */\n  data?: {[kind: string]: any};\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  styles?: string[];\n\n  /**\n   * The strategy that the default change detector uses to detect changes.\n   * When set, takes effect the next time change detection is triggered.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Registry of directives and components that may be found in this component's view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directives?: DirectiveTypesOrFactory | null;\n\n  /**\n   * Registry of pipes that may be found in this component's view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipes?: PipeTypesOrFactory | null;\n}): never {\n  const type = componentDefinition.type;\n  const typePrototype = type.prototype;\n  const declaredInputs: {[key: string]: string} = {} as any;\n  const def: Mutable<ComponentDef<any>, keyof ComponentDef<any>> = {\n    type: type,\n    providersResolver: null,\n    consts: componentDefinition.consts,\n    vars: componentDefinition.vars,\n    factory: componentDefinition.factory,\n    template: componentDefinition.template || null !,\n    hostBindings: componentDefinition.hostBindings || null,\n    contentQueries: componentDefinition.contentQueries || null,\n    contentQueriesRefresh: componentDefinition.contentQueriesRefresh || null,\n    attributes: componentDefinition.attributes || null,\n    declaredInputs: declaredInputs,\n    inputs: null !,   // assigned in noSideEffects\n    outputs: null !,  // assigned in noSideEffects\n    exportAs: componentDefinition.exportAs || null,\n    onInit: typePrototype.ngOnInit || null,\n    doCheck: typePrototype.ngDoCheck || null,\n    afterContentInit: typePrototype.ngAfterContentInit || null,\n    afterContentChecked: typePrototype.ngAfterContentChecked || null,\n    afterViewInit: typePrototype.ngAfterViewInit || null,\n    afterViewChecked: typePrototype.ngAfterViewChecked || null,\n    onDestroy: typePrototype.ngOnDestroy || null,\n    onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n    directiveDefs: null !,  // assigned in noSideEffects\n    pipeDefs: null !,       // assigned in noSideEffects\n    selectors: componentDefinition.selectors,\n    viewQuery: componentDefinition.viewQuery || null,\n    features: componentDefinition.features || null,\n    data: componentDefinition.data || {},\n    // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the\n    // next line. Also `None` should be 0 not 2.\n    encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n    id: 'c',\n    styles: componentDefinition.styles || EMPTY_ARRAY,\n    _: null as never,\n  };\n  def._ = noSideEffects(() => {\n    const directiveTypes = componentDefinition.directives !;\n    const feature = componentDefinition.features;\n    const pipeTypes = componentDefinition.pipes !;\n    def.id += _renderCompCount++;\n    def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n    def.outputs = invertObject(componentDefinition.outputs),\n    feature && feature.forEach((fn) => fn(def));\n    def.directiveDefs = directiveTypes ?\n        () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\n                  .map(extractDirectiveDef) :\n        null;\n    def.pipeDefs = pipeTypes ?\n        () => (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) :\n        null;\n  }) as never;\n  return def as never;\n}\n\nexport function extractDirectiveDef(type: DirectiveType<any>& ComponentType<any>):\n    DirectiveDef<any>|ComponentDef<any> {\n  const def = getComponentDef(type) || getDirectiveDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);\n  }\n  return def !;\n}\n\nexport function extractPipeDef(type: PipeType<any>): PipeDef<any> {\n  const def = getPipeDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is not a 'PipeType'.`);\n  }\n  return def !;\n}\n\nexport function defineNgModule<T>(def: {type: T} & Partial<NgModuleDef<T>>): never {\n  const res: NgModuleDef<T> = {\n    type: def.type,\n    bootstrap: def.bootstrap || EMPTY_ARRAY,\n    declarations: def.declarations || EMPTY_ARRAY,\n    imports: def.imports || EMPTY_ARRAY,\n    exports: def.exports || EMPTY_ARRAY,\n    transitiveCompileScopes: null,\n  };\n  return res as never;\n}\n\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj: any, secondary?: any): any {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup: any = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName: string = obj[minifiedKey];\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        (secondary[publicName] = declaredName);\n      }\n    }\n  }\n  return newLookup;\n}\n\n/**\n * Create a base definition\n *\n * # Example\n * ```\n * class ShouldBeInherited {\n *   static ngBaseDef = defineBase({\n *      ...\n *   })\n * }\n * @param baseDefinition The base definition parameters\n */\nexport function defineBase<T>(baseDefinition: {\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: [ 'declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['declared', 'public']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `outputs`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n}): BaseDef<T> {\n  const declaredInputs: {[P in keyof T]: P} = {} as any;\n  return {\n    inputs: invertObject(baseDefinition.inputs, declaredInputs),\n    declaredInputs: declaredInputs,\n    outputs: invertObject(baseDefinition.outputs),\n  };\n}\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ngDirectiveDef = defineDirective({\n *     ...\n *   });\n * }\n * ```\n */\nexport const defineDirective = defineComponent as any as<T>(directiveDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  selectors: CssSelectorList;\n\n  /**\n   * Factory method used to create an instance of directive.\n   */\n  factory: (t: Type<T>| null) => T;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  attributes?: string[];\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['declared', 'public']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n   */\n  features?: DirectiveDefFeature[];\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ((directiveIndex: number) => void);\n\n  /** Refreshes content queries associated with directives in a given view */\n  contentQueriesRefresh?: ((directiveIndex: number, queryIndex: number) => void);\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string;\n}) => never;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ngPipeDef = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n */\nexport function definePipe<T>(pipeDef: {\n  /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n  name: string,\n\n  /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n  type: Type<T>,\n\n  /** A factory for creating a pipe instance. */\n  factory: (t: Type<T>| null) => T,\n\n  /** Whether the pipe is pure. */\n  pure?: boolean\n}): never {\n  return (<PipeDef<T>>{\n    name: pipeDef.name,\n    factory: pipeDef.factory,\n    pure: pipeDef.pure !== false,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  }) as never;\n}\n\n/**\n * The following getter methods retrieve the definition form the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T>|null {\n  return (type as any)[NG_COMPONENT_DEF] || null;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T>|null {\n  return (type as any)[NG_DIRECTIVE_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T>|null {\n  return (type as any)[NG_PIPE_DEF] || null;\n}\n\nexport function getNgModuleDef<T>(type: any, throwNotFound: true): NgModuleDef<T>;\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T>|null;\nexport function getNgModuleDef<T>(type: any, throwNotFound?: boolean): NgModuleDef<T>|null {\n  const ngModuleDef = (type as any)[NG_MODULE_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ngModuleDef' property.`);\n  }\n  return ngModuleDef;\n}\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\nexport type CssSelector = (string | SelectorFlags)[];\n\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport type CssSelectorList = CssSelector[];\n\n/** Flags used to build up CssSelectors */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\nexport const NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\n *\n * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\n * please see [BAZEL.md](./docs/BAZEL.md).\n */\n\nlet _devMode: boolean = true;\nlet _runModeLocked: boolean = false;\n\n\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @publicApi\n */\nexport function isDevMode(): boolean {\n  _runModeLocked = true;\n  return _devMode;\n}\n\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * @publicApi\n */\nexport function enableProdMode(): void {\n  if (_runModeLocked) {\n    throw new Error('Cannot enable prod mode after platform setup.');\n  }\n  _devMode = false;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../is_dev_mode';\nimport {InertBodyHelper} from './inert_body';\nimport {_sanitizeUrl, sanitizeSrcset} from './url_sanitizer';\n\nfunction tagSet(tags: string): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\n\nfunction merge(...sets: {[k: string]: boolean}[]): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS =\n    merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(\n    OPTIONAL_END_TAG_BLOCK_ELEMENTS,\n    tagSet(\n        'address,article,' +\n        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(\n    OPTIONAL_END_TAG_INLINE_ELEMENTS,\n    tagSet(\n        'a,abbr,acronym,audio,b,' +\n        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\n\nexport const VALID_ELEMENTS =\n    merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n\n// Attributes that have href and hence need to be sanitized\nexport const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n\n// Attributes that have special href set hence need to be sanitized\nexport const SRCSET_ATTRS = tagSet('srcset');\n\nconst HTML_ATTRS = tagSet(\n    'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width');\n\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\n\nexport const VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);\n\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n  // because characters were re-encoded.\n  public sanitizedSomething = false;\n  private buf: string[] = [];\n\n  sanitizeChildren(el: Element): string {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current: Node = el.firstChild !;\n    let elementValid = true;\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        elementValid = this.startElement(current as Element);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue !);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (elementValid && current.firstChild) {\n        current = current.firstChild !;\n        continue;\n      }\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current as Element);\n        }\n\n        let next = this.checkClobberedElement(current, current.nextSibling !);\n\n        if (next) {\n          current = next;\n          break;\n        }\n\n        current = this.checkClobberedElement(current, current.parentNode !);\n      }\n    }\n    return this.buf.join('');\n  }\n\n  /**\n   * Outputs only valid Elements.\n   *\n   * Invalid elements are skipped.\n   *\n   * @param element element to sanitize\n   * Returns true if the element is valid.\n   */\n  private startElement(element: Element): boolean {\n    const tagName = element.nodeName.toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return false;\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr !.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr !.value;\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push('>');\n    return true;\n  }\n\n  private endElement(current: Element) {\n    const tagName = current.nodeName.toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n\n  private chars(chars: string) { this.buf.push(encodeEntities(chars)); }\n\n  checkClobberedElement(node: Node, nextNode: Node): Node {\n    if (nextNode &&\n        (node.compareDocumentPosition(nextNode) &\n         Node.DOCUMENT_POSITION_CONTAINED_BY) ===Â Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      throw new Error(\n          `Failed to sanitize html because the element is clobbered: ${(node as Element).outerHTML}`);\n    }\n    return nextNode;\n  }\n}\n\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value: string) {\n  return value.replace(/&/g, '&amp;')\n      .replace(\n          SURROGATE_PAIR_REGEXP,\n          function(match: string) {\n            const hi = match.charCodeAt(0);\n            const low = match.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n          })\n      .replace(\n          NON_ALPHANUMERIC_REGEXP,\n          function(match: string) { return '&#' + match.charCodeAt(0) + ';'; })\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n}\n\nlet inertBodyHelper: InertBodyHelper;\n\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nexport function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string {\n  let inertBodyElement: HTMLElement|null = null;\n  try {\n    inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement !.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(\n        getTemplateContent(inertBodyElement !) as Element || inertBodyElement);\n    if (isDevMode() && sanitizer.sanitizedSomething) {\n      console.warn(\n          'WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');\n    }\n\n    return safeHtml;\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n      }\n    }\n  }\n}\n\nexport function getTemplateContent(el: Node): Node|null {\n  return 'content' in (el as any /** Microsoft/TypeScript#21517 */) && isTemplateElement(el) ?\n      el.content :\n      null;\n}\nfunction isTemplateElement(el: Node): el is HTMLTemplateElement {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","/** @deprecated do not use, this is no longer checked by RxJS internals */\nexport const rxSubscriber =\n  typeof Symbol === 'function'\n    ? Symbol('rxSubscriber')\n    : '@@rxSubscriber_' + Math.random();\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver, TeardownLogic } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any> | Subscriber<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  private _parentSubscription: Subscription | null = null;\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = destinationOrNext;\n            destinationOrNext.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    this._parentSubscription = null;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { root } from '../util/root';\n\n/** Symbol.observable addition */\n/* Note: This will add Symbol.observable globally for all TypeScript users,\n  however, we are no longer polyfilling Symbol.observable */\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\n/** Symbol.observable or a string \"@@observable\". Used for interop */\nexport const observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n\n/**\n * Determines whether the ErrorObserver is closed or stopped or has a\n * destination that is closed or stopped - in which case errors will\n * need to be reported via a different mechanism.\n * @param observer the observer\n */\nexport function canReportError(observer: Subscriber<any> | Subject<any>): boolean {\n  while (observer) {\n    const { closed, destination, isStopped } = observer as any;\n    if (closed || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n  return true;\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;\n/* tslint:enable:max-line-length */\n\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nfunction ObjectUnsubscribedErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'object unsubscribed';\n  this.name = 'ObjectUnsubscribedError';\n  return this;\n}\n\nObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observables. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n *\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create customize Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  if (!subscriber.closed) {\n    subscriber.complete();\n  }\n};\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToArray } from '../util/subscribeToArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n        subscriber.next(input[i++]);\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n","export function identity<T>(x: T): T {\n  return x;\n}\n","export interface EmptyError extends Error {\n}\n\nexport interface EmptyErrorCtor {\n  new(): EmptyError;\n}\n\nfunction EmptyErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'no elements in sequence';\n  this.name = 'EmptyError';\n  return this;\n}\n\nEmptyErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = EmptyErrorImpl as any;","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { hostReportError } from './hostReportError';\n\nexport const subscribeToPromise = <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => {\n  promise.then(\n    (value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    },\n    (err: any) => subscriber.error(err)\n  )\n  .then(null, hostReportError);\n  return subscriber;\n};\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n\n/**\n * @deprecated use {@link iterator} instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => {\n  const iterator = iterable[Symbol_iterator]();\n  do {\n    const item = iterator.next();\n    if (item.done) {\n      subscriber.complete();\n      break;\n    }\n    subscriber.next(item.value);\n    if (subscriber.closed) {\n      break;\n    }\n  } while (true);\n\n  // Finalize the iterator if it happens to be a Generator\n  if (typeof iterator.return === 'function') {\n    subscriber.add(() => {\n      if (iterator.return) {\n        iterator.return();\n      }\n    });\n  }\n\n  return subscriber;\n};\n","import { Subscriber } from '../Subscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => {\n  const obs = obj[Symbol_observable]();\n  if (typeof obs.subscribe !== 'function') {\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  } else {\n    return obs.subscribe(subscriber);\n  }\n};\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');","export function isPromise(value: any): value is PromiseLike<any> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { Subscriber } from '../Subscriber';\n\nexport const subscribeTo = <T>(result: ObservableInput<T>) => {\n  if (result instanceof Observable) {\n    return (subscriber: Subscriber<T>) => {\n        if (result._isScalar) {\n        subscriber.next((result as any).value);\n        subscriber.complete();\n        return undefined;\n      } else {\n        return result.subscribe(subscriber);\n      }\n    };\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    return subscribeToObservable(result as any);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result as Promise<any>);\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    return subscribeToIterable(result as any);\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n * Map and flatten each letter to an Observable ticking every 1 second\n * ```javascript\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x+i))),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and merging the results of the Observables\n * obtained from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, I|R> {\n  if (typeof resultSelector === 'function') {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      mergeMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii)),\n      ), concurrent)\n    );\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return (source: Observable<T>) => source.lift(new MergeMapOperator(project, concurrent));\n}\n\nexport class MergeMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<R>, value: T, index: number): void {\n    const innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    subscribeToResult<T, R>(this, ish, value, index, innerSubscriber);\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Subscriber } from '../Subscriber';\nimport { subscribeTo } from './subscribeTo';\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue?: T,\n  outerIndex?: number,\n  destination?: Subscriber<any>\n): Subscription;\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue?: T,\n  outerIndex?: number,\n  destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)\n): Subscription | void {\n  if (destination.closed) {\n    return;\n  }\n  return subscribeTo(result)(destination);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Subject, Subscription} from 'rxjs';\n\n/**\n * Use in directives and components to emit custom events synchronously\n * or asynchronously, and register handlers for those events by subscribing\n * to an instance.\n *\n * @usageNotes\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * ### Notes\n *\n * Uses Rx.Observable but provides an adapter to make it work as specified here:\n * https://github.com/jhusain/observable-spec\n *\n * Once a reference implementation of the spec is available, switch to it.\n *\n * @publicApi\n */\nexport class EventEmitter<T> extends Subject<T> {\n  // TODO: mark this as internal once all the facades are gone\n  // we can't mark it as internal now because EventEmitter exported via @angular/core would not\n  // contain this property making it incompatible with all the code that uses EventEmitter via\n  // facades, which are local to the code and do not have this property stripped.\n  /**\n   * Internal\n   */\n  __isAsync: boolean;  // tslint:disable-line\n\n  /**\n   * Creates an instance of this class that can\n   * deliver events synchronously or asynchronously.\n   *\n   * @param isAsync When true, deliver events asynchronously.\n   *\n   */\n  constructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n\n  /**\n   * Emits an event containing a given value.\n   * @param value The value to emit.\n   */\n  emit(value?: T) { super.next(value); }\n\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param generatorOrNext When supplied, a custom handler for emitted events.\n   * @param error When supplied, a custom handler for an error notification\n   * from this emitter.\n   * @param complete When supplied, a custom handler for a completion\n   * notification from this emitter.\n   */\n  subscribe(generatorOrNext?: any, error?: any, complete?: any): any {\n    let schedulerFn: (t: any) => any;\n    let errorFn = (err: any): any => null;\n    let completeFn = (): any => null;\n\n    if (generatorOrNext && typeof generatorOrNext === 'object') {\n      schedulerFn = this.__isAsync ? (value: any) => {\n        setTimeout(() => generatorOrNext.next(value));\n      } : (value: any) => { generatorOrNext.next(value); };\n\n      if (generatorOrNext.error) {\n        errorFn = this.__isAsync ? (err) => { setTimeout(() => generatorOrNext.error(err)); } :\n                                   (err) => { generatorOrNext.error(err); };\n      }\n\n      if (generatorOrNext.complete) {\n        completeFn = this.__isAsync ? () => { setTimeout(() => generatorOrNext.complete()); } :\n                                      () => { generatorOrNext.complete(); };\n      }\n    } else {\n      schedulerFn = this.__isAsync ? (value: any) => { setTimeout(() => generatorOrNext(value)); } :\n                                     (value: any) => { generatorOrNext(value); };\n\n      if (error) {\n        errorFn =\n            this.__isAsync ? (err) => { setTimeout(() => error(err)); } : (err) => { error(err); };\n      }\n\n      if (complete) {\n        completeFn =\n            this.__isAsync ? () => { setTimeout(() => complete()); } : () => { complete(); };\n      }\n    }\n\n    const sink = super.subscribe(schedulerFn, errorFn, completeFn);\n\n    if (generatorOrNext instanceof Subscription) {\n      generatorOrNext.add(sink);\n    }\n\n    return sink;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectTemplateRef as render3InjectTemplateRef} from '../render3/view_engine_compatibility';\nimport {noop} from '../util/noop';\n\nimport {ElementRef} from './element_ref';\nimport {EmbeddedViewRef} from './view_ref';\n\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nexport abstract class TemplateRef<C> {\n  /**\n   * The anchor element in the parent view for this embedded view.\n   *\n   * The data-binding and injection contexts of embedded views created from this `TemplateRef`\n   * inherit from the contexts of this location.\n   *\n   * Typically new embedded views are attached to the view container of this location, but in\n   * advanced use-cases, the view can be attached to a different container while keeping the\n   * data-binding and injection context from the original location.\n   *\n   */\n  // TODO(i): rename to anchor or location\n  abstract get elementRef(): ElementRef;\n\n  /**\n   * Creates a view object and attaches it to the view container of the parent view.\n   * @param context The context for the new view, inherited from the anchor element.\n   * @returns The new view object.\n   */\n  abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\n\n  /** @internal */\n  static __NG_ELEMENT_ID__:\n      () => TemplateRef<any>| null = () => SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef)\n}\n\nexport const SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ = render3InjectTemplateRef;\nconst SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__ = noop;\nconst SWITCH_TEMPLATE_REF_FACTORY: typeof render3InjectTemplateRef =\n    SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nexport const Type = Function;\n\nexport function isType(v: any): v is Type<any> {\n  return typeof v === 'function';\n}\n\nexport interface Type<T> extends Function { new (...args: any[]): T; }\n\nexport type Mutable<T extends{[x: string]: any}, K extends string> = {\n  [P in K]: T[P];\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../is_dev_mode';\nimport {_sanitizeUrl} from './url_sanitizer';\n\n\n/**\n * Regular expression for safe style values.\n *\n * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\n *\n * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\n * font-family) and hence could allow multiple values to get injected, but that should pose no risk\n * of XSS.\n *\n * The function expression checks only for XSS safety, not for CSS validity.\n *\n * This regular expression was taken from the Closure sanitization library, and augmented for\n * transformation values.\n */\nconst VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\nconst TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';\nconst COLOR_FNS = '(?:rgb|hsl)a?';\nconst GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';\nconst CSS3_FNS = '(?:calc|attr)';\nconst FN_ARGS = '\\\\([-0-9.%, #a-zA-Z]+\\\\)';\nconst SAFE_STYLE_VALUE = new RegExp(\n    `^(${VALUES}|` +\n        `(?:${TRANSFORMATION_FNS}|${COLOR_FNS}|${GRADIENTS}|${CSS3_FNS})` +\n        `${FN_ARGS})$`,\n    'g');\n\n/**\n * Matches a `url(...)` value with an arbitrary argument as long as it does\n * not contain parentheses.\n *\n * The URL value still needs to be sanitized separately.\n *\n * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\n * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\n * by observing whether scroll bars are displayed, or character ranges used by a font face\n * definition.\n *\n * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\n * binding a URL value without further cooperation from the page will cause an information leak, and\n * if so, it is just a leak, not a full blown XSS vulnerability.\n *\n * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\n * code is permissive and allows URLs that sanitize otherwise.\n */\nconst URL_RE = /^url\\(([^)]+)\\)$/;\n\n/**\n * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\n * that neither escape (\\) nor any other character that could result in\n * breaking out of a string parsing context are allowed;\n * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\n *\n * This code was taken from the Closure sanitization library.\n */\nfunction hasBalancedQuotes(value: string) {\n  let outsideSingle = true;\n  let outsideDouble = true;\n  for (let i = 0; i < value.length; i++) {\n    const c = value.charAt(i);\n    if (c === '\\'' && outsideDouble) {\n      outsideSingle = !outsideSingle;\n    } else if (c === '\"' && outsideSingle) {\n      outsideDouble = !outsideDouble;\n    }\n  }\n  return outsideSingle && outsideDouble;\n}\n\n/**\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n * value) and returns a value that is safe to use in a browser environment.\n */\nexport function _sanitizeStyle(value: string): string {\n  value = String(value).trim();  // Make sure it's actually a string.\n  if (!value) return '';\n\n  // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\n  // reasoning behind this.\n  const urlMatch = value.match(URL_RE);\n  if ((urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\n      value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\n    return value;  // Safe style values.\n  }\n\n  if (isDevMode()) {\n    console.warn(\n        `WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`);\n  }\n\n  return 'unsafe';\n}\n\n\n/**\n * Used to intercept and sanitize style values before they are written to the renderer.\n *\n * This function is designed to be called in two modes. When a value is not provided\n * then the function will return a boolean whether a property will be sanitized later.\n * If a value is provided then the sanitized version of that will be returned.\n */\nexport interface StyleSanitizeFn {\n  /** This mode is designed to instruct whether the property will be used for sanitization\n   * at a later point */\n  (prop: string): boolean;\n  /** This mode is designed to sanitize the provided value */\n  (prop: string, value: string): string;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type, isType} from '../type';\nimport {global, stringify} from '../util';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\n\n/**\n * Attention: These regex has to hold even if the code is minified!\n */\nexport const DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*arguments\\)/;\nexport const INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\nexport const INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) { this._reflect = reflect || global['Reflect']; }\n\n  isReflectionEnabled(): boolean { return true; }\n\n  factory<T>(t: Type<T>): (args: any[]) => T { return (...args: any[]) => new t(...args); }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = new Array(paramAnnotations.length);\n    } else {\n      result = new Array(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (DELEGATE_CTOR.exec(typeStr) ||\n        (INHERITED_CLASS.exec(typeStr) && !INHERITED_CLASS_WITH_CTOR.exec(typeStr))) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return new Array((<any>type.length)).fill(undefined);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n\n  guards(type: any): {[key: string]: any} { return {}; }\n\n  getter(name: string): GetterFn { return <GetterFn>new Function('o', 'return o.' + name + ';'); }\n\n  setter(name: string): SetterFn {\n    return <SetterFn>new Function('o', 'v', 'return o.' + name + ' = v;');\n  }\n\n  method(name: string): MethodFn {\n    const functionBody = `if (!o.${name}) throw new Error('\"${name}\" is undefined');\n        return o.${name}.apply(o, args);`;\n    return <MethodFn>new Function('o', 'args', functionBody);\n  }\n\n  // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\n  importUri(type: any): string {\n    // StaticSymbol\n    if (typeof type === 'object' && type['filePath']) {\n      return type['filePath'];\n    }\n    // Runtime type\n    return `./${stringify(type)}`;\n  }\n\n  resourceUri(type: any): string { return `./${stringify(type)}`; }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return runtime;\n  }\n  resolveEnum(enumIdentifier: any, name: string): any { return enumIdentifier[name]; }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Provider} from '../di';\nimport {NG_BASE_DEF} from '../render3/fields';\nimport {compileComponent as render3CompileComponent, compileDirective as render3CompileDirective} from '../render3/jit/directive';\nimport {compilePipe as render3CompilePipe} from '../render3/jit/pipe';\nimport {Type} from '../type';\nimport {TypeDecorator, makeDecorator, makePropDecorator} from '../util/decorators';\nimport {noop} from '../util/noop';\nimport {fillProperties} from '../util/property';\n\nimport {ViewEncapsulation} from './view';\n\n\n\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport interface DirectiveDecorator {\n  /**\n   * Marks a class as an Angular directive. You can define your own\n   * directives to attach custom behavior to elements in the DOM.\n   * The options provide configuration metadata that determines\n   * how the directive should be processed, instantiated and used at\n   * runtime.\n   *\n   * Directive classes, like component classes, can implement\n   * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n   *\n   *\n   * @usageNotes\n   * To define a directive, mark the class with the decorator and provide metadata.\n   *\n   * ```\n   * import {Directive} from '@angular/core';\n   *\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * export class MyDirective {\n   * ...\n   * }\n   * ```\n   *\n   * ### Declaring directives\n   *\n   * Directives are [declarables](guide/glossary#declarable).\n   * They must be declared by an NgModule\n   * in order to be usable in an app.\n   *\n   * A directive must belong to exactly one NgModule. Do not re-declare\n   * a directive imported from another module.\n   * List the directive class in the `declarations` field of an NgModule.\n   *\n   * ```\n   * declarations: [\n   *  AppComponent,\n   *  MyDirective\n   * ],\n   * ```\n   *\n   * @Annotation\n   */\n  (obj: Directive): TypeDecorator;\n\n  /**\n   * See the `Directive` decorator.\n   */\n  new (obj: Directive): Directive;\n}\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport interface Directive {\n  /**\n   * The CSS selector that identifies this directive in a template\n   * and triggers instantiation of the directive.\n   *\n   * Declare as one of the following:\n   *\n   * - `element-name`: Select by element name.\n   * - `.class`: Select by class name.\n   * - `[attribute]`: Select by attribute name.\n   * - `[attribute=value]`: Select by attribute name and value.\n   * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n   *\n   * Angular only allows directives to apply on CSS selectors that do not cross\n   * element boundaries.\n   *\n   * For the following template HTML, a directive with an `input[type=text]` selector,\n   * would be instantiated only on the `<input type=\"text\">` element.\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   */\n  selector?: string;\n\n  /**\n   * Enumerates the set of data-bound input properties for a directive\n   *\n   * Angular automatically updates input properties during change detection.\n   * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * The following example creates a component with two data-bound properties.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   inputs: ['bankName', 'id: account-id'],\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   bankName: string;\n   *   id: string;\n   *\n   * ```\n   *\n   */\n  inputs?: string[];\n\n  /**\n   * Enumerates the set of event-bound output properties.\n   *\n   * When an output property emits an event, an event handler attached to that event\n   * in the template is invoked.\n   *\n   * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `bindingProperty` specifies the DOM property the event handler is attached to.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * ```typescript\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   *\n   */\n  outputs?: string[];\n\n  /**\n   * Configures the [injector](guide/glossary#injector) of this\n   * directive or component with a [token](guide/glossary#di-token)\n   * that maps to a [provider](guide/glossary#provider) of a dependency.\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * @usageNotes\n   *\n   * ### Simple Example\n   *\n   * ```\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   *\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * The following example shows how queries are defined\n   * and when their results are available in lifecycle hooks:\n   *\n   * ```\n   * @Component({\n   *   selector: 'someDir',\n   *   queries: {\n   *     contentChildren: new ContentChildren(ChildDirective),\n   *     viewChildren: new ViewChildren(ChildDirective)\n   *   },\n   *   template: '<child-directive></child-directive>'\n   * })\n   * class SomeDir {\n   *   contentChildren: QueryList<ChildDirective>,\n   *   viewChildren: QueryList<ChildDirective>\n   *\n   *   ngAfterContentInit() {\n   *     // contentChildren is set\n   *   }\n   *\n   *   ngAfterViewInit() {\n   *     // viewChildren is set\n   *   }\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  queries?: {[key: string]: any};\n\n  /**\n   * Maps class properties to host element bindings for properties,\n   * attributes, and events, using a set of key-value pairs.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, Angular updates the directive's host element.\n   *\n   * When the key is a property of the host element, the property value is\n   * the propagated to the specified DOM property.\n   *\n   * When the key is a static attribute in the DOM, the attribute value\n   * is propagated to the specified property in the host element.\n   *\n   * For event handling:\n   * - The key is the DOM event that the directive listens to.\n   * To listen to global events, add the target to the event name.\n   * The target can be `window`, `document` or `body`.\n   * - The value is the statement to execute when the event occurs. If the\n   * statement evalueates to `false`, then `preventDefault` is applied on the DOM\n   * event. A handler method can refer to the `$event` local variable.\n   *\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * If true, this directive/component will be skipped by the AOT compiler and so will always be\n   * compiled using JIT.\n   *\n   * This exists to support future Ivy work and has no effect currently.\n   */\n  jit?: true;\n}\n\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport const Directive: DirectiveDecorator = makeDecorator(\n    'Directive', (dir: Directive = {}) => dir, undefined, undefined,\n    (type: Type<any>, meta: Directive) => SWITCH_COMPILE_DIRECTIVE(type, meta));\n\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport interface ComponentDecorator {\n  /**\n   * Decorator that marks a class as an Angular component and provides configuration\n   * metadata that determines how the component should be processed,\n   * instantiated, and used at runtime.\n   *\n   * Components are the most basic UI building block of an Angular app.\n   * An Angular app contains a tree of Angular components.\n   *\n   * Angular components are a subset of directives, always associated with a template.\n   * Unlike other directives, only one component can be instantiated per an element in a template.\n   *\n   * A component must belong to an NgModule in order for it to be available\n   * to another component or application. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `@NgModule` metadata.\n   *\n   * Note that, in addition to these options for configuring a directive,\n   * you can control a component's runtime behavior by implementing\n   * life-cycle hooks. For more information, see the\n   * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n   *\n   * @usageNotes\n   *\n   * ### Setting component inputs\n   *\n   * The following example creates a component with two data-bound properties,\n   * specified by the `inputs` value.\n   *\n   * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\">\n   * </code-example>\n   *\n   *\n   * ### Setting component outputs\n   *\n   * The following example shows two event emitters that emit on an interval. One\n   * emits an output every second, while the other emits every five seconds.\n   *\n   * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n   *\n   * ### Injecting a class with a view provider\n   *\n   * The following simple example injects a class into a component\n   * using the view provider specified in component metadata:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'needs-greeter'\n   * })\n   * class NeedsGreeter {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   viewProviders: [\n   *     Greeter\n   *   ],\n   *   template: `<needs-greeter></needs-greeter>`\n   * })\n   * class HelloWorld {\n   * }\n   *\n   * ```\n   *\n   * ### Preserving whitespace\n   *\n   * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n   * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n   * To change the default setting for all components in your application, set\n   * the `preserveWhitespaces` option of the AOT compiler.\n   *\n   * By default, the AOT compiler removes whitespace characters as follows:\n   * * Trims all whitespaces at the beginning and the end of a template.\n   * * Removes whitespace-only text nodes. For example,\n   *\n   * ```\n   * <button>Action 1</button>  <button>Action 2</button>\n   * ```\n   *\n   * becomes:\n   *\n   * ```\n   * <button>Action 1</button><button>Action 2</button>\n   * ```\n   *\n   * * Replaces a series of whitespace characters in text nodes with a single space.\n   * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n   * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n   * where whitespace characters are significant.\n   *\n   * Note that these transformations can influence DOM nodes layout, although impact\n   * should be minimal.\n   *\n   * You can override the default behavior to preserve whitespace characters\n   * in certain fragments of a template. For example, you can exclude an entire\n   * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n   *\n   * ```html\n   * <div ngPreserveWhitespaces>\n   *     whitespaces are preserved here\n   *     <span>    and here </span>\n   * </div>\n   * ```\n   *\n   * You can force a single space to be preserved in a text node by using `&ngsp;`,\n   * which is replaced with a space character by Angular's template\n   * compiler:\n   *\n   * ```html\n   * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n   * <!-->compiled to be equivalent to:</>\n   *  <a>Spaces</a> <a>between</a> <a>links.</a>\n   * ```\n   *\n   * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n   * the `preserveWhitespaces` option is set to `false`.\n   *\n   * ```html\n   * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n   * <!-->compiled to be equivalent to:</>\n   *  <a>Spaces</a> <a>between</a> <a>links.</a>\n   * ```\n   *\n   * To preserve sequences of whitespace characters, use the\n   * `ngPreserveWhitespaces` attribute.\n   *\n   * @Annotation\n   */\n  (obj: Component): TypeDecorator;\n  /**\n   * See the `@Component` decorator.\n   */\n  new (obj: Component): Component;\n}\n\n/**\n * Supplies configuration metadata for an Angular component.\n *\n * @publicApi\n */\nexport interface Component extends Directive {\n  /**\n   * The change-detection strategy to use for this component.\n   *\n   * When a component is instantiated, Angular creates a change detector,\n   * which is responsible for propagating the component's bindings.\n   * The strategy is one of:\n   * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n   * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Defines the set of injectable objects that are visible to its view DOM children.\n   * See [example](#injecting-a-class-with-a-view-provider).\n   *\n   */\n  viewProviders?: Provider[];\n\n  /**\n   * The module ID of the module that contains the component.\n   * The component must be able to resolve relative URLs for templates and styles.\n   * SystemJS exposes the `__moduleName` variable within each module.\n   * In CommonJS, this can  be set to `module.id`.\n   *\n   */\n  moduleId?: string;\n\n  /**\n   * The URL of a template file for an Angular component. If provided,\n   * do not supply an inline template using `template`.\n   *\n   */\n  templateUrl?: string;\n\n  /**\n   * An inline template for an Angular component. If provided,\n   * do not supply a template file using `templateUrl`.\n   *\n   */\n  template?: string;\n\n  /**\n   * One or more URLs for files containing CSS stylesheets to use\n   * in this component.\n   */\n  styleUrls?: string[];\n\n  /**\n   * One or more inline CSS stylesheets to use\n   * in this component.\n   */\n  styles?: string[];\n\n  /**\n   * One or more animation `trigger()` calls, containing\n   * `state()` and `transition()` definitions.\n   * See the [Animations guide](/guide/animations) and animations API documentation.\n   *\n   */\n  animations?: any[];\n\n  /**\n   * An encapsulation policy for the template and CSS styles. One of:\n   * - `ViewEncapsulation.Native`: Use shadow roots. This works\n   * only if natively available on the platform.\n   * - `ViewEncapsulation.Emulated`: Use shimmed CSS that\n   * emulates the native behavior.\n   * - `ViewEncapsulation.None`: Use global CSS without any\n   * encapsulation.\n   *\n   * If not supplied, the value is taken from `CompilerOptions`. The default compiler option is\n   * `ViewEncapsulation.Emulated`.\n   *\n   * If the policy is set to `ViewEncapsulation.Emulated` and the component has no `styles`\n   * or `styleUrls` specified, the policy is automatically switched to `ViewEncapsulation.None`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default encapsulation start and end delimiters (`{{` and `}}`)\n   */\n  interpolation?: [string, string];\n\n  /**\n   * A set of components that should be compiled along with\n   * this component. For each component listed here,\n   * Angular creates a {@link ComponentFactory} and stores it in the\n   * {@link ComponentFactoryResolver}.\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * True to preserve or false to remove potentially superfluous whitespace characters\n   * from the compiled template. Whitespace characters are those matching the `\\s`\n   * character class in JavaScript regular expressions. Default is false, unless\n   * overridden in compiler options.\n   */\n  preserveWhitespaces?: boolean;\n}\n\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Component: ComponentDecorator = makeDecorator(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}),\n    Directive, undefined,\n    (type: Type<any>, meta: Component) => SWITCH_COMPILE_COMPONENT(type, meta));\n\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport interface PipeDecorator {\n  /**\n   * Declares a reusable pipe function, and supplies configuration metadata.\n   *\n   */\n  (obj: Pipe): TypeDecorator;\n\n  /**\n   * See the `Pipe` decorator.\n   */\n  new (obj: Pipe): Pipe;\n}\n\n/**\n * Type of the Pipe metadata.\n *\n * @publicApi\n */\nexport interface Pipe {\n  /**\n   * The pipe name to use in template bindings.\n   *\n   */\n  name: string;\n\n  /**\n   * When true, the pipe is pure, meaning that the\n   * `transform()` method is invoked only when its input arguments\n   * change. Pipes are pure by default.\n   *\n   * If the pipe has internal state (that is, the result\n   * depends on state other than its arguments), set `pure` to false.\n   * In this case, the pipe is invoked on each change-detection cycle,\n   * even if the arguments have not changed.\n   */\n  pure?: boolean;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Pipe: PipeDecorator = makeDecorator(\n    'Pipe', (p: Pipe) => ({pure: true, ...p}), undefined, undefined,\n    (type: Type<any>, meta: Pipe) => SWITCH_COMPILE_PIPE(type, meta));\n\n\n/**\n * @publicApi\n */\nexport interface InputDecorator {\n  /**\n   * Decorator that marks a class as pipe and supplies configuration metadata.\n   *\n   * A pipe class must implement the `PipeTransform` interface.\n   * For example, if the name is \"myPipe\", use a template binding expression\n   * such as the following:\n   *\n   * ```\n   * {{ exp | myPipe }}\n   * ```\n   *\n   * The result of the expression is passed to the pipe's `transform()` method.\n   *\n   * A pipe must belong to an NgModule in order for it to be available\n   * to a template. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `@NgModule` metadata.\n   *\n   */\n  (bindingPropertyName?: string): any;\n  new (bindingPropertyName?: string): any;\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n * @publicApi\n */\nexport interface Input {\n  /**\n   * Decorator that marks a class field as an input property and supplies configuration metadata.\n   * Declares a data-bound input property, which Angular automatically updates\n   * during change detection.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for input binding.\n   *\n   * The following example creates a component with two input properties,\n   * one of which is given a special binding name.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   // This property is bound using its original name.\n   *   @Input() bankName: string;\n   *   // this property value is bound to a different property name\n   *   // when this component is instantiated in a template.\n   *   @Input('account-id') id: string;\n   *\n   *   // this property is not bound, and is not automatically updated by Angular\n   *   normalizedBankName: string;\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `\n   *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n   *   `\n   * })\n   *\n   * class App {}\n   * ```\n   *\n   */\n  bindingPropertyName?: string;\n}\n\nconst initializeBaseDef = (target: any): void => {\n  const constructor = target.constructor;\n  const inheritedBaseDef = constructor.ngBaseDef;\n\n  const baseDef = constructor.ngBaseDef = {\n    inputs: {},\n    outputs: {},\n    declaredInputs: {},\n  };\n\n  if (inheritedBaseDef) {\n    fillProperties(baseDef.inputs, inheritedBaseDef.inputs);\n    fillProperties(baseDef.outputs, inheritedBaseDef.outputs);\n    fillProperties(baseDef.declaredInputs, inheritedBaseDef.declaredInputs);\n  }\n};\n\n/**\n * Does the work of creating the `ngBaseDef` property for the @Input and @Output decorators.\n * @param key \"inputs\" or \"outputs\"\n */\nconst updateBaseDefFromIOProp = (getProp: (baseDef: {inputs?: any, outputs?: any}) => any) =>\n    (target: any, name: string, ...args: any[]) => {\n      const constructor = target.constructor;\n\n      if (!constructor.hasOwnProperty(NG_BASE_DEF)) {\n        initializeBaseDef(target);\n      }\n\n      const baseDef = constructor.ngBaseDef;\n      const defProp = getProp(baseDef);\n      defProp[name] = args[0];\n    };\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Input: InputDecorator = makePropDecorator(\n    'Input', (bindingPropertyName?: string) => ({bindingPropertyName}), undefined,\n    updateBaseDefFromIOProp(baseDef => baseDef.inputs || {}));\n\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OutputDecorator {\n  /**\n  * Decorator that marks a class field as an output property and supplies configuration metadata.\n  * Declares a data-bound output property, which Angular automatically updates\n  * during change detection.\n  *\n  * @usageNotes\n  *\n  * You can supply an optional name to use in templates when the\n  * component is instantiated, that maps to the\n  * name of the bound property. By default, the original\n  * name of the bound property is used for output binding.\n  *\n  * See `@Input` decorator for an example of providing a binding name.\n  *\n  */\n  (bindingPropertyName?: string): any;\n  new (bindingPropertyName?: string): any;\n}\n\n/**\n * Type of the Output metadata.\n *\n * @publicApi\n */\nexport interface Output { bindingPropertyName?: string; }\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Output: OutputDecorator = makePropDecorator(\n    'Output', (bindingPropertyName?: string) => ({bindingPropertyName}), undefined,\n    updateBaseDefFromIOProp(baseDef => baseDef.outputs || {}));\n\n\n\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostBindingDecorator {\n  /**\n   * Decorator that marks a DOM property as a host-binding property and supplies configuration\n   * metadata.\n   * Angular automatically checks host property bindings during change detection, and\n   * if a binding changes it updates the host element of the directive.\n   *\n   * @usageNotes\n   *\n   * The following example creates a directive that sets the `valid` and `invalid`\n   * properties on the DOM element that has an `ngModel` directive on it.\n   *\n   * ```typescript\n   * @Directive({selector: '[ngModel]'})\n   * class NgModelStatus {\n   *   constructor(public control: NgModel) {}\n   *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n   *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`,\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   *\n   */\n  (hostPropertyName?: string): any;\n  new (hostPropertyName?: string): any;\n}\n\n/**\n * Type of the HostBinding metadata.\n *\n * @publicApi\n */\nexport interface HostBinding { hostPropertyName?: string; }\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const HostBinding: HostBindingDecorator =\n    makePropDecorator('HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\n\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostListenerDecorator {\n  (eventName: string, args?: string[]): any;\n  new (eventName: string, args?: string[]): any;\n}\n\n/**\n * Type of the HostListener metadata.\n *\n * @publicApi\n */\nexport interface HostListener {\n  /**\n   * The CSS event to listen for.\n   */\n  eventName?: string;\n  /**\n   * A set of arguments to pass to the handler method when the event occurs.\n   */\n  args?: string[];\n}\n\n/**\n * Binds a CSS event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *  }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n * ```\n *\n * @Annotation\n * @publicApi\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n\n\n\nexport const SWITCH_COMPILE_COMPONENT__POST_R3__ = render3CompileComponent;\nexport const SWITCH_COMPILE_DIRECTIVE__POST_R3__ = render3CompileDirective;\nexport const SWITCH_COMPILE_PIPE__POST_R3__ = render3CompilePipe;\n\nconst SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;\nconst SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;\nconst SWITCH_COMPILE_PIPE__PRE_R3__ = noop;\n\nconst SWITCH_COMPILE_COMPONENT: typeof render3CompileComponent = SWITCH_COMPILE_COMPONENT__PRE_R3__;\nconst SWITCH_COMPILE_DIRECTIVE: typeof render3CompileDirective = SWITCH_COMPILE_DIRECTIVE__PRE_R3__;\nconst SWITCH_COMPILE_PIPE: typeof render3CompilePipe = SWITCH_COMPILE_PIPE__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {Type} from '../type';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {inject, injectArgs} from './injector_compatibility';\nimport {ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './provider';\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\nconst EMPTY_ARRAY: any[] = [];\n\nexport function convertInjectableProviderToFactory(\n    type: Type<any>, provider?: ValueSansProvider | ExistingSansProvider | StaticClassSansProvider |\n        ConstructorSansProvider | FactorySansProvider | ClassSansProvider): () => any {\n  if (!provider) {\n    const reflectionCapabilities = new ReflectionCapabilities();\n    const deps = reflectionCapabilities.parameters(type);\n    // TODO - convert to flags.\n    return () => new type(...injectArgs(deps as any[]));\n  }\n\n  if (USE_VALUE in provider) {\n    const valueProvider = (provider as ValueSansProvider);\n    return () => valueProvider.useValue;\n  } else if ((provider as ExistingSansProvider).useExisting) {\n    const existingProvider = (provider as ExistingSansProvider);\n    return () => inject(existingProvider.useExisting);\n  } else if ((provider as FactorySansProvider).useFactory) {\n    const factoryProvider = (provider as FactorySansProvider);\n    return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY));\n  } else if ((provider as StaticClassSansProvider | ClassSansProvider).useClass) {\n    const classProvider = (provider as StaticClassSansProvider | ClassSansProvider);\n    let deps = (provider as StaticClassSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new classProvider.useClass(...injectArgs(deps));\n  } else {\n    let deps = (provider as ConstructorSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new type(...injectArgs(deps !));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {InjectorType, defineInjector} from '../di/defs';\nimport {Provider} from '../di/provider';\nimport {convertInjectableProviderToFactory} from '../di/util';\nimport {NgModuleType} from '../render3';\nimport {compileNgModule as render3CompileNgModule} from '../render3/jit/module';\nimport {Type} from '../type';\nimport {TypeDecorator, makeDecorator} from '../util/decorators';\n\n/**\n * Represents the expansion of an `NgModule` into its scopes.\n *\n * A scope is a set of directives and pipes that are visible in a particular context. Each\n * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will\n * be recognized in the templates of components declared by the module. The `exported` scope is the\n * set of directives and pipes exported by a module (that is, module B's exported scope gets added\n * to module A's compilation scope when module A imports B).\n */\nexport interface NgModuleTransitiveScopes {\n  compilation: {directives: Set<any>; pipes: Set<any>;};\n  exported: {directives: Set<any>; pipes: Set<any>;};\n}\n\nexport type NgModuleDefWithMeta<T, Declarations, Imports, Exports> = NgModuleDef<T>;\n\n/**\n * Runtime link information for NgModules.\n *\n * This is the internal data structure used by the runtime to assemble components, directives,\n * pipes, and injectors.\n *\n * NOTE: Always use `defineNgModule` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n */\nexport interface NgModuleDef<T> {\n  /** Token representing the module. Used by DI. */\n  type: T;\n\n  /** List of components to bootstrap. */\n  bootstrap: Type<any>[];\n\n  /** List of components, directives, and pipes declared by this module. */\n  declarations: Type<any>[];\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports: Type<any>[];\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports: Type<any>[];\n\n  /**\n   * Cached value of computed `transitiveCompileScopes` for this module.\n   *\n   * This should never be read directly, but accessed via `transitiveScopesFor`.\n   */\n  transitiveCompileScopes: NgModuleTransitiveScopes|null;\n}\n\n/**\n * A wrapper around an NgModule that associates it with the providers.\n *\n * @param T the module type. In Ivy applications, this must be explicitly\n * provided.\n *\n * @publicApi\n */\nexport interface ModuleWithProviders<\n    T = any /** TODO(alxhub): remove default when callers pass explicit type param */> {\n  ngModule: Type<T>;\n  providers?: Provider[];\n}\n\n/**\n * A schema definition associated with an NgModule.\n *\n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\n *\n * @param name The name of a defined schema.\n *\n * @publicApi\n */\nexport interface SchemaMetadata { name: string; }\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\n/**\n * Defines a schema that allows any property on any element.\n *\n * @publicApi\n */\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\n\n/**\n * Type of the NgModule decorator / constructor function.\n */\nexport interface NgModuleDecorator {\n  /**\n   * Marks a class as an NgModule and supplies configuration metadata.\n   */\n  (obj?: NgModule): TypeDecorator;\n  new (obj?: NgModule): NgModule;\n}\n\n/**\n * Type of the NgModule metadata.\n *\n * @publicApi\n */\nexport interface NgModule {\n  /**\n   * The set of injectable objects that are available in the injector\n   * of this module.\n   *\n   * @see [Dependency Injection guide](guide/dependency-injection)\n   * @see [NgModule guide](guide/providers)\n   *\n   * @usageNotes\n   *\n   * Dependencies whose providers are listed here become available for injection\n   * into any component, directive, pipe or service that is a child of this injector.\n   * The NgModule used for bootstrapping uses the root injector, and can provide dependencies\n   * to any part of the app.\n   *\n   * A lazy-loaded module has its own injector, typically a child of the app root injector.\n   * Lazy-loaded services are scoped to the lazy-loaded module's injector.\n   * If a lazy-loaded module also provides the `UserService`, any component created\n   * within that module's context (such as by router navigation) gets the local instance\n   * of the service, not the instance in the root injector.\n   * Components in external modules continue to receive the instance provided by their injectors.\n   *\n   * ### Example\n   *\n   * The following example defines a class that is injected in\n   * the HelloWorld NgModule:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @NgModule({\n   *   providers: [\n   *     Greeter\n   *   ]\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```\n   */\n  providers?: Provider[];\n\n  /**\n   * The set of components, directives, and pipes ([declarables](guide/glossary#declarable))\n   * that belong to this module.\n   *\n   * @usageNotes\n   *\n   * The set of selectors that are available to a template include those declared here, and\n   * those that are exported from imported NgModules.\n   *\n   * Declarables must belong to exactly one module.\n   * The compiler emits an error if you try to declare the same class in more than one module.\n   * Be careful not to declare a class that is imported from another module.\n   *\n   * ### Example\n   *\n   * The following example allows the CommonModule to use the `NgFor`\n   * directive.\n   *\n   * ```javascript\n   * @NgModule({\n   *   declarations: [NgFor]\n   * })\n   * class CommonModule {\n   * }\n   * ```\n   */\n  declarations?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of NgModules whose exported [declarables](guide/glossary#declarable)\n   * are available to templates in this module.\n   *\n   * @usageNotes\n   *\n   * A template can use exported declarables from any\n   * imported module, including those from modules that are imported indirectly\n   * and re-exported.\n   * For example, `ModuleA` imports `ModuleB`, and also exports\n   * it, which makes the declarables from `ModuleB` available\n   * wherever `ModuleA` is imported.\n   *\n   * ### Example\n   *\n   * The following example allows MainModule to use anthing exported by\n   * `CommonModule`:\n   *\n   * ```javascript\n   * @NgModule({\n   *   imports: [CommonModule]\n   * })\n   * class MainModule {\n   * }\n   * ```\n   *\n   */\n  imports?: Array<Type<any>|ModuleWithProviders<{}>|any[]>;\n\n  /**\n   * The set of components, directives, and pipes declared in this\n   * NgModule that can be used in the template of any component that is part of an\n   * NgModule that imports this NgModule. Exported declarations are the module's public API.\n   *\n   * A declarable belongs to one and only one NgModule.\n   * A module can list another module among its exports, in which case all of that module's\n   * public declaration are exported.\n   *\n   * @usageNotes\n   *\n   * Declarations are private by default.\n   * If this ModuleA does not export UserComponent, then only the components within this\n   * ModuleA can use UserComponent.\n   *\n   * ModuleA can import ModuleB and also export it, making exports from ModuleB\n   * available to an NgModule that imports ModuleA.\n   *\n   * ### Example\n   *\n   * The following example exports the `NgFor` directive from CommonModule.\n   *\n   * ```javascript\n   * @NgModule({\n   *   exports: [NgFor]\n   * })\n   * class CommonModule {\n   * }\n   * ```\n   */\n  exports?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of components to compile when this NgModule is defined,\n   * so that they can be dynamically loaded into the view.\n   *\n   * For each component listed here, Angular creates a `ComponentFactory`\n   * and stores it in the `ComponentFactoryResolver`.\n   *\n   * Angular automatically adds components in the module's bootstrap\n   * and route definitions into the `entryComponents` list. Use this\n   * option to add components that are bootstrapped\n   * using one of the imperative techniques, such as `ViewContainerRef.createComponent()`.\n   *\n   * @see [Entry Components](guide/entry-components)\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of components that are bootstrapped when\n   * this module is bootstrapped. The components listed here\n   * are automatically added to `entryComponents`.\n   */\n  bootstrap?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   * Elements and properties that are neither Angular components nor directives\n   * must be declared in a schema.\n   *\n   * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.\n   *\n   * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`\n   * you must ensure that allowed elements and properties securely escape inputs.\n   */\n  schemas?: Array<SchemaMetadata|any[]>;\n\n  /**\n   * A name or path that uniquely identifies this NgModule in `getModuleFactory`.\n   * If left `undefined`, the NgModule is not registered with\n   * `getModuleFactory`.\n   */\n  id?: string;\n\n  /**\n   * If true, this module will be skipped by the AOT compiler and so will always be compiled\n   * using JIT.\n   *\n   * This exists to support future Ivy work and has no effect currently.\n   */\n  jit?: true;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const NgModule: NgModuleDecorator = makeDecorator(\n    'NgModule', (ngModule: NgModule) => ngModule, undefined, undefined,\n    /**\n     * Decorator that marks the following class as an NgModule, and supplies\n     * configuration metadata for it.\n     *\n     * * The `declarations` and `entryComponents` options configure the compiler\n     * with information about what belongs to the NgModule.\n     * * The `providers` options configures the NgModule's injector to provide\n     * dependencies the NgModule members.\n     * * The `imports` and `exports` options bring in members from other modules, and make\n     * this module's members available to others.\n     */\n    (type: NgModuleType, meta: NgModule) => SWITCH_COMPILE_NGMODULE(type, meta));\n\n/**\n * @description\n * Hook for manual bootstrapping of the application instead of using bootstrap array in @NgModule\n * annotation.\n *\n * Reference to the current application is provided as a parameter.\n *\n * See [\"Bootstrapping\"](guide/bootstrapping) and [\"Entry components\"](guide/entry-components).\n *\n * @usageNotes\n * ```typescript\n * class AppModule implements DoBootstrap {\n *   ngDoBootstrap(appRef: ApplicationRef) {\n *     appRef.bootstrap(AppComponent); // Or some other component\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport interface DoBootstrap { ngDoBootstrap(appRef: ApplicationRef): void; }\n\nfunction preR3NgModuleCompile(moduleType: InjectorType<any>, metadata: NgModule): void {\n  let imports = (metadata && metadata.imports) || [];\n  if (metadata && metadata.exports) {\n    imports = [...imports, metadata.exports];\n  }\n\n  moduleType.ngInjectorDef = defineInjector({\n    factory: convertInjectableProviderToFactory(moduleType, {useClass: moduleType}),\n    providers: metadata && metadata.providers,\n    imports: imports,\n  });\n}\n\n\nexport const SWITCH_COMPILE_NGMODULE__POST_R3__ = render3CompileNgModule;\nconst SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;\nconst SWITCH_COMPILE_NGMODULE: typeof render3CompileNgModule = SWITCH_COMPILE_NGMODULE__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileInjectable as render3CompileInjectable} from '../render3/jit/injectable';\nimport {Type} from '../type';\nimport {TypeDecorator, makeDecorator} from '../util/decorators';\n\nimport {InjectableDef, InjectableType, defineInjectable, getInjectableDef} from './defs';\nimport {ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider} from './provider';\nimport {convertInjectableProviderToFactory} from './util';\n\n\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @publicApi\n */\nexport type InjectableProvider = ValueSansProvider | ExistingSansProvider |\n    StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\n\n/**\n * Type of the Injectable decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectableDecorator {\n  /**\n   * A marker metadata that marks a class as available to `Injector` for creation.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Injectable'}\n   *\n   * `Injector` will throw an error when trying to instantiate a class that\n   * does not have `@Injectable` marker, as shown in the example below.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}\n   *\n   */\n  (): TypeDecorator;\n  (options?: {providedIn: Type<any>| 'root' | null}&InjectableProvider): TypeDecorator;\n  new (): Injectable;\n  new (options?: {providedIn: Type<any>| 'root' | null}&InjectableProvider): Injectable;\n}\n\n/**\n * Type of the Injectable metadata.\n *\n * @publicApi\n */\nexport interface Injectable { providedIn?: Type<any>|'root'|null; }\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Injectable: InjectableDecorator = makeDecorator(\n    'Injectable', undefined, undefined, undefined,\n    (type: Type<any>, meta: Injectable) => SWITCH_COMPILE_INJECTABLE(type as any, meta));\n\n/**\n * Type representing injectable service.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> { ngInjectableDef: InjectableDef<T>; }\n\n/**\n * Supports @Injectable() in JIT mode for Render2.\n */\nfunction render2CompileInjectable(\n    injectableType: InjectableType<any>,\n    options: {providedIn?: Type<any>| 'root' | null} & InjectableProvider): void {\n  if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {\n    injectableType.ngInjectableDef = defineInjectable({\n      providedIn: options.providedIn,\n      factory: convertInjectableProviderToFactory(injectableType, options),\n    });\n  }\n}\n\nexport const SWITCH_COMPILE_INJECTABLE__POST_R3__ = render3CompileInjectable;\nconst SWITCH_COMPILE_INJECTABLE__PRE_R3__ = render2CompileInjectable;\nconst SWITCH_COMPILE_INJECTABLE: typeof render3CompileInjectable =\n    SWITCH_COMPILE_INJECTABLE__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../../di/injectable';\nimport {ClassSansProvider, ExistingSansProvider, FactorySansProvider, ValueProvider, ValueSansProvider} from '../../di/provider';\nimport {Type} from '../../type';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {NG_INJECTABLE_DEF} from '../fields';\n\nimport {R3InjectableMetadataFacade, getCompilerFacade} from './compiler_facade';\nimport {angularCoreEnv} from './environment';\nimport {convertDependencies, reflectDependencies} from './util';\n\n\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * `ngInjectableDef` onto the injectable type.\n */\nexport function compileInjectable(type: Type<any>, srcMeta?: Injectable): void {\n  let def: any = null;\n\n  // if NG_INJECTABLE_DEF is already defined on this class then don't overwrite it\n  if (type.hasOwnProperty(NG_INJECTABLE_DEF)) return;\n\n  Object.defineProperty(type, NG_INJECTABLE_DEF, {\n    get: () => {\n      if (def === null) {\n        // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n        const meta: Injectable = srcMeta || {providedIn: null};\n        const hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) ||\n            isUseValueProvider(meta) || isUseExistingProvider(meta);\n\n\n        const compilerMeta: R3InjectableMetadataFacade = {\n          name: type.name,\n          type: type,\n          typeArgumentCount: 0,\n          providedIn: meta.providedIn,\n          ctorDeps: reflectDependencies(type),\n          userDeps: undefined\n        };\n        if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n          compilerMeta.userDeps = convertDependencies(meta.deps);\n        }\n        if (!hasAProvider) {\n          // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.\n          // The deps will have been reflected above, causing the factory to create the class by\n          // calling\n          // its constructor with injected deps.\n          compilerMeta.useClass = type;\n        } else if (isUseClassProvider(meta)) {\n          // The user explicitly specified useClass, and may or may not have provided deps.\n          compilerMeta.useClass = meta.useClass;\n        } else if (isUseValueProvider(meta)) {\n          // The user explicitly specified useValue.\n          compilerMeta.useValue = meta.useValue;\n        } else if (isUseFactoryProvider(meta)) {\n          // The user explicitly specified useFactory.\n          compilerMeta.useFactory = meta.useFactory;\n        } else if (isUseExistingProvider(meta)) {\n          // The user explicitly specified useExisting.\n          compilerMeta.useExisting = meta.useExisting;\n        } else {\n          // Can't happen - either hasAProvider will be false, or one of the providers will be set.\n          throw new Error(`Unreachable state.`);\n        }\n        def = getCompilerFacade().compileInjectable(\n            angularCoreEnv, `ng://${type.name}/ngInjectableDef.js`, compilerMeta);\n      }\n      return def;\n    },\n  });\n}\n\ntype UseClassProvider = Injectable & ClassSansProvider & {deps?: any[]};\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\nfunction isUseClassProvider(meta: Injectable): meta is UseClassProvider {\n  return (meta as UseClassProvider).useClass !== undefined;\n}\n\nfunction isUseValueProvider(meta: Injectable): meta is Injectable&ValueSansProvider {\n  return USE_VALUE in meta;\n}\n\nfunction isUseFactoryProvider(meta: Injectable): meta is Injectable&FactorySansProvider {\n  return (meta as FactorySansProvider).useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta: Injectable): meta is Injectable&ExistingSansProvider {\n  return (meta as ExistingSansProvider).useExisting !== undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DebugContext} from './view';\n\nexport const ERROR_TYPE = 'ngType';\nexport const ERROR_DEBUG_CONTEXT = 'ngDebugContext';\nexport const ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nexport const ERROR_LOGGER = 'ngErrorLogger';\n\n\nexport function getType(error: Error): Function {\n  return (error as any)[ERROR_TYPE];\n}\n\nexport function getDebugContext(error: Error): DebugContext {\n  return (error as any)[ERROR_DEBUG_CONTEXT];\n}\n\nexport function getOriginalError(error: Error): Error {\n  return (error as any)[ERROR_ORIGINAL_ERROR];\n}\n\nexport function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void {\n  return (error as any)[ERROR_LOGGER] || defaultErrorLogger;\n}\n\n\nfunction defaultErrorLogger(console: Console, ...values: any[]) {\n  (<any>console.error)(...values);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_ORIGINAL_ERROR, getDebugContext, getErrorLogger, getOriginalError} from './errors';\n\n\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nexport class ErrorHandler {\n  /**\n   * @internal\n   */\n  _console: Console = console;\n\n  handleError(error: any): void {\n    const originalError = this._findOriginalError(error);\n    const context = this._findContext(error);\n    // Note: Browser consoles show the place from where console.error was called.\n    // We can use this to give users additional information about the error.\n    const errorLogger = getErrorLogger(error);\n\n    errorLogger(this._console, `ERROR`, error);\n    if (originalError) {\n      errorLogger(this._console, `ORIGINAL ERROR`, originalError);\n    }\n    if (context) {\n      errorLogger(this._console, 'ERROR CONTEXT', context);\n    }\n  }\n\n  /** @internal */\n  _findContext(error: any): any {\n    if (error) {\n      return getDebugContext(error) ? getDebugContext(error) :\n                                      this._findContext(getOriginalError(error));\n    }\n\n    return null;\n  }\n\n  /** @internal */\n  _findOriginalError(error: Error): any {\n    let e = getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n\n    return e;\n  }\n}\n\nexport function wrappedError(message: string, originalError: any): Error {\n  const msg =\n      `${message} caused by: ${originalError instanceof Error ? originalError.message: originalError }`;\n  const error = Error(msg);\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../util';\nimport {resolveForwardRef} from './forward_ref';\n\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nexport class ReflectiveKey {\n  public readonly displayName: string;\n  /**\n   * Private\n   */\n  constructor(public token: Object, public id: number) {\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n    this.displayName = stringify(this.token);\n  }\n\n  /**\n   * Retrieves a `Key` for a token.\n   */\n  static get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n\n  /**\n   * @returns the number of keys registered in the system.\n   */\n  static get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }\n}\n\nexport class KeyRegistry {\n  private _allKeys = new Map<Object, ReflectiveKey>();\n\n  get(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token) !;\n    }\n\n    const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n\n  get numberOfKeys(): number { return this._allKeys.size; }\n}\n\nconst _globalKeyRegistry = new KeyRegistry();\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReflectionCapabilities} from './reflection_capabilities';\nimport {Reflector} from './reflector';\n\nexport {Reflector} from './reflector';\n\n/**\n * The {@link Reflector} used internally in Angular to access metadata\n * about symbols.\n */\nexport const reflector = new Reflector(new ReflectionCapabilities());\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\nexport {PlatformReflectionCapabilities};\nexport {GetterFn, MethodFn, SetterFn};\n\n/**\n * Provides access to reflection data about symbols. Used internally by Angular\n * to power dependency injection and compilation.\n */\nexport class Reflector {\n  constructor(public reflectionCapabilities: PlatformReflectionCapabilities) {}\n\n  updateCapabilities(caps: PlatformReflectionCapabilities) { this.reflectionCapabilities = caps; }\n\n  factory(type: Type<any>): Function { return this.reflectionCapabilities.factory(type); }\n\n  parameters(typeOrFunc: Type<any>): any[][] {\n    return this.reflectionCapabilities.parameters(typeOrFunc);\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    return this.reflectionCapabilities.annotations(typeOrFunc);\n  }\n\n  propMetadata(typeOrFunc: Type<any>): {[key: string]: any[]} {\n    return this.reflectionCapabilities.propMetadata(typeOrFunc);\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n  }\n\n  getter(name: string): GetterFn { return this.reflectionCapabilities.getter(name); }\n\n  setter(name: string): SetterFn { return this.reflectionCapabilities.setter(name); }\n\n  method(name: string): MethodFn { return this.reflectionCapabilities.method(name); }\n\n  importUri(type: any): string { return this.reflectionCapabilities.importUri(type); }\n\n  resourceUri(type: any): string { return this.reflectionCapabilities.resourceUri(type); }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\n  }\n\n  resolveEnum(identifier: any, name: string): any {\n    return this.reflectionCapabilities.resolveEnum(identifier, name);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, THROW_IF_NOT_FOUND} from './injector';\nimport {Self, SkipSelf} from './metadata';\nimport {Provider} from './provider';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst UNDEFINED = new Object();\n\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nexport abstract class ReflectiveInjector implements Injector {\n  /**\n   * Turns an array of provider definitions into an array of resolved providers.\n   *\n   * A resolution is a process of flattening multiple nested arrays and converting individual\n   * providers into an array of `ResolvedReflectiveProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n   *\n   * expect(providers.length).toEqual(2);\n   *\n   * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n   * expect(providers[0].key.displayName).toBe(\"Car\");\n   * expect(providers[0].dependencies.length).toEqual(1);\n   * expect(providers[0].factory).toBeDefined();\n   *\n   * expect(providers[1].key.displayName).toBe(\"Engine\");\n   * });\n   * ```\n   *\n   */\n  static resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n\n  /**\n   * Resolves an array of providers and creates an injector from those providers.\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n\n  /**\n   * Creates an injector from previously resolved providers.\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, Engine]);\n   * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n\n  /**\n   * Parent of this injector.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   */\n  abstract get parent(): Injector|null;\n\n  /**\n   * Resolves an array of providers and creates a child injector from those providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n   * var child = parent.resolveAndCreateChild([ChildProvider]);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n\n  /**\n   * Creates a child injector from previously resolved providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n   * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n   *\n   * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n   * var child = parent.createChildFromResolved(childProviders);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n\n  /**\n   * Resolves a provider and instantiates an object in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   *\n   * var car = injector.resolveAndInstantiate(Car);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n   * ```\n   */\n  abstract resolveAndInstantiate(provider: Provider): any;\n\n  /**\n   * Instantiates an object using a resolved provider in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   * var carProvider = ReflectiveInjector.resolve([Car])[0];\n   * var car = injector.instantiateResolved(carProvider);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n   * ```\n   */\n  abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n\n  abstract get(token: any, notFoundValue?: any): any;\n}\n\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  private static INJECTOR_KEY = ReflectiveKey.get(Injector);\n  /** @internal */\n  _constructionCounter: number = 0;\n  /** @internal */\n  public _providers: ResolvedReflectiveProvider[];\n  public readonly parent: Injector|null;\n\n  keyIds: number[];\n  objs: any[];\n  /**\n   * Private\n   */\n  constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector) {\n    this._providers = _providers;\n    this.parent = _parent || null;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n\n  resolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n\n  createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const inj = new ReflectiveInjector_(providers);\n    (inj as{parent: Injector | null}).parent = this;\n    return inj;\n  }\n\n  resolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n\n  instantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n\n  getProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n\n  /** @internal */\n  _new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n\n  private _getMaxNumberOfObjects(): number { return this.objs.length; }\n\n  private _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const res = new Array(provider.resolvedFactories.length);\n      for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n\n  private _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const factory = ResolvedReflectiveFactory.factory;\n\n    let deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch (e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let obj: any;\n    try {\n      obj = factory(...deps);\n    } catch (e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n\n  private _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n\n  private _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf|null, notFoundValue: any): any {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n\n  private _getObjByKeyId(keyId: number): any {\n    for (let i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n\n  /** @internal */\n  _throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n\n  /** @internal */\n  _getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n\n  /** @internal */\n  _getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf|null): any {\n    let inj: Injector|null;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this.parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const inj_ = <ReflectiveInjector_>inj;\n      const obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_.parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n\n  get displayName(): string {\n    const providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n\n  toString(): string { return this.displayName; }\n}\n\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const res: any[] = new Array(injector._providers.length);\n  for (let i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { FactoryOrValue, MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subjectOrSubjectFactory: FactoryOrValue<Subject<T>>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<R>>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: OperatorFunction<T, R>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * ![](multicast.png)\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n","import { Observable } from '../Observable';\nimport { multicast } from './multicast';\nimport { refCount } from './refCount';\nimport { Subject } from '../Subject';\n\nimport { MonoTypeOperatorFunction } from '../types';\n\nfunction shareSubjectFactory() {\n  return new Subject();\n}\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * ![](share.png)\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nexport function share<T>(): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => refCount()(multicast(shareSubjectFactory)(source)) as Observable<T>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise(obj: any): obj is Promise<any> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\n/**\n * Determine if the argument is an Observable\n */\nexport function isObservable(obj: any | Observable<any>): obj is Observable<any> {\n  // TODO: use isObservable once we update pass rxjs 6.1\n  // https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03\n  return !!obj && typeof obj.subscribe === 'function';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isPromise} from '../src/util/lang';\n\nimport {Inject, Injectable, InjectionToken, Optional} from './di';\n\n\n/**\n * A function that will be executed when an application is initialized.\n *\n * @publicApi\n */\nexport const APP_INITIALIZER = new InjectionToken<Array<() => void>>('Application Initializer');\n\n/**\n * A class that reflects the state of running {@link APP_INITIALIZER}s.\n *\n * @publicApi\n */\n@Injectable()\nexport class ApplicationInitStatus {\n  // TODO(issue/24571): remove '!'.\n  private resolve !: Function;\n  // TODO(issue/24571): remove '!'.\n  private reject !: Function;\n  private initialized = false;\n  public readonly donePromise: Promise<any>;\n  public readonly done = false;\n\n  constructor(@Inject(APP_INITIALIZER) @Optional() private appInits: (() => any)[]) {\n    this.donePromise = new Promise((res, rej) => {\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n\n  /** @internal */\n  runInitializers() {\n    if (this.initialized) {\n      return;\n    }\n\n    const asyncInitPromises: Promise<any>[] = [];\n\n    const complete = () => {\n      (this as{done: boolean}).done = true;\n      this.resolve();\n    };\n\n    if (this.appInits) {\n      for (let i = 0; i < this.appInits.length; i++) {\n        const initResult = this.appInits[i]();\n        if (isPromise(initResult)) {\n          asyncInitPromises.push(initResult);\n        }\n      }\n    }\n\n    Promise.all(asyncInitPromises).then(() => { complete(); }).catch(e => { this.reject(e); });\n\n    if (asyncInitPromises.length === 0) {\n      complete();\n    }\n    this.initialized = true;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './di';\nimport {ComponentRef} from './linker/component_factory';\n\n\n/**\n * A DI Token representing a unique string id assigned to the application by Angular and used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\n *\n * If you need to avoid randomly generated value to be used as an application id, you can provide\n * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\n * using this token.\n * @publicApi\n */\nexport const APP_ID = new InjectionToken<string>('AppId');\n\nexport function _appIdRandomProviderFactory() {\n  return `${_randomChar()}${_randomChar()}${_randomChar()}`;\n}\n\n/**\n * Providers that will generate a random APP_ID_TOKEN.\n * @publicApi\n */\nexport const APP_ID_RANDOM_PROVIDER = {\n  provide: APP_ID,\n  useFactory: _appIdRandomProviderFactory,\n  deps: <any[]>[],\n};\n\nfunction _randomChar(): string {\n  return String.fromCharCode(97 + Math.floor(Math.random() * 25));\n}\n\n/**\n * A function that will be executed when a platform is initialized.\n * @publicApi\n */\nexport const PLATFORM_INITIALIZER = new InjectionToken<Array<() => void>>('Platform Initializer');\n\n/**\n * A token that indicates an opaque platform id.\n * @publicApi\n */\nexport const PLATFORM_ID = new InjectionToken<Object>('Platform ID');\n\n/**\n * All callbacks provided via this token will be called for every component that is bootstrapped.\n * Signature of the callback:\n *\n * `(componentRef: ComponentRef) => void`.\n *\n * @publicApi\n */\nexport const APP_BOOTSTRAP_LISTENER =\n    new InjectionToken<Array<(compRef: ComponentRef<any>) => void>>('appBootstrapListener');\n\n/**\n * A token which indicates the root directory of the application\n * @publicApi\n */\nexport const PACKAGE_ROOT_URL = new InjectionToken<string>('Application Packages Root URL');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from './di';\n\n@Injectable()\nexport class Console {\n  log(message: string): void {\n    // tslint:disable-next-line:no-console\n    console.log(message);\n  }\n  // Note: for reporting errors use `DOM.logError()` as it is platform specific\n  warn(message: string): void {\n    // tslint:disable-next-line:no-console\n    console.warn(message);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di/injectable';\nimport {InjectionToken} from '../di/injection_token';\nimport {StaticProvider} from '../di/provider';\nimport {MissingTranslationStrategy} from '../i18n/tokens';\nimport {ViewEncapsulation} from '../metadata';\nimport {NgModuleFactory as NgModuleFactoryR3} from '../render3/ng_module_ref';\nimport {Type} from '../type';\n\nimport {ComponentFactory} from './component_factory';\nimport {NgModuleFactory} from './ng_module_factory';\n\n\n\n/**\n * Combination of NgModuleFactory and ComponentFactorys.\n *\n * @publicApi\n */\nexport class ModuleWithComponentFactories<T> {\n  constructor(\n      public ngModuleFactory: NgModuleFactory<T>,\n      public componentFactories: ComponentFactory<any>[]) {}\n}\n\n\nfunction _throwError() {\n  throw new Error(`Runtime compiler is not loaded`);\n}\n\nconst Compiler_compileModuleSync__PRE_R3__: <T>(moduleType: Type<T>) => NgModuleFactory<T> =\n    _throwError as any;\nexport const Compiler_compileModuleSync__POST_R3__: <T>(moduleType: Type<T>) =>\n    NgModuleFactory<T> = function<T>(moduleType: Type<T>): NgModuleFactory<T> {\n  return new NgModuleFactoryR3(moduleType);\n};\nconst Compiler_compileModuleSync = Compiler_compileModuleSync__PRE_R3__;\n\nconst Compiler_compileModuleAsync__PRE_R3__: <T>(moduleType: Type<T>) =>\n    Promise<NgModuleFactory<T>> = _throwError as any;\nexport const Compiler_compileModuleAsync__POST_R3__: <T>(moduleType: Type<T>) =>\n    Promise<NgModuleFactory<T>> = function<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>> {\n  return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));\n};\nconst Compiler_compileModuleAsync = Compiler_compileModuleAsync__PRE_R3__;\n\nconst Compiler_compileModuleAndAllComponentsSync__PRE_R3__: <T>(moduleType: Type<T>) =>\n    ModuleWithComponentFactories<T> = _throwError as any;\nexport const Compiler_compileModuleAndAllComponentsSync__POST_R3__: <T>(moduleType: Type<T>) =>\n    ModuleWithComponentFactories<T> = function<T>(moduleType: Type<T>):\n        ModuleWithComponentFactories<T> {\n  return new ModuleWithComponentFactories(Compiler_compileModuleSync__POST_R3__(moduleType), []);\n};\nconst Compiler_compileModuleAndAllComponentsSync =\n    Compiler_compileModuleAndAllComponentsSync__PRE_R3__;\n\nconst Compiler_compileModuleAndAllComponentsAsync__PRE_R3__: <T>(moduleType: Type<T>) =>\n    Promise<ModuleWithComponentFactories<T>> = _throwError as any;\nexport const Compiler_compileModuleAndAllComponentsAsync__POST_R3__: <T>(moduleType: Type<T>) =>\n    Promise<ModuleWithComponentFactories<T>> = function<T>(moduleType: Type<T>):\n        Promise<ModuleWithComponentFactories<T>> {\n  return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));\n};\nconst Compiler_compileModuleAndAllComponentsAsync =\n    Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;\n\n/**\n * Low-level service for running the angular compiler during runtime\n * to create {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n *\n * Each `@NgModule` provides an own `Compiler` to its injector,\n * that will use the directives/pipes of the ng module for compilation\n * of components.\n *\n * @publicApi\n */\n@Injectable()\nexport class Compiler {\n  /**\n   * Compiles the given NgModule and all of its components. All templates of the components listed\n   * in `entryComponents` have to be inlined.\n   */\n  compileModuleSync: <T>(moduleType: Type<T>) => NgModuleFactory<T> = Compiler_compileModuleSync;\n\n  /**\n   * Compiles the given NgModule and all of its components\n   */\n  compileModuleAsync:\n      <T>(moduleType: Type<T>) => Promise<NgModuleFactory<T>> = Compiler_compileModuleAsync;\n\n  /**\n   * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsSync: <T>(moduleType: Type<T>) => ModuleWithComponentFactories<T> =\n      Compiler_compileModuleAndAllComponentsSync;\n\n  /**\n   * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsAsync: <T>(moduleType: Type<T>) =>\n      Promise<ModuleWithComponentFactories<T>> = Compiler_compileModuleAndAllComponentsAsync;\n\n  /**\n   * Clears all caches.\n   */\n  clearCache(): void {}\n\n  /**\n   * Clears the cache for the given component/ngModule.\n   */\n  clearCacheFor(type: Type<any>) {}\n\n  /**\n   * Returns the id for a given NgModule, if one is defined and known to the compiler.\n   */\n  getModuleId(moduleType: Type<any>): string|undefined { return undefined; }\n}\n\n/**\n * Options for creating a compiler\n *\n * @publicApi\n */\nexport type CompilerOptions = {\n  useJit?: boolean,\n  defaultEncapsulation?: ViewEncapsulation,\n  providers?: StaticProvider[],\n  missingTranslation?: MissingTranslationStrategy,\n  preserveWhitespaces?: boolean,\n};\n\n/**\n * Token to provide CompilerOptions in the platform injector.\n *\n * @publicApi\n */\nexport const COMPILER_OPTIONS = new InjectionToken<CompilerOptions[]>('compilerOptions');\n\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nexport abstract class CompilerFactory {\n  abstract createCompiler(options?: CompilerOptions[]): Compiler;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../util';\n\n/**\n * A scope function for the Web Tracing Framework (WTF).\n *\n * @publicApi\n */\nexport interface WtfScopeFn { (arg0?: any, arg1?: any): any; }\n\ninterface WTF {\n  trace: Trace;\n}\n\ninterface Trace {\n  events: Events;\n  leaveScope(scope: Scope, returnValue: any): any /** TODO #9100 */;\n  beginTimeRange(rangeType: string, action: string): Range;\n  endTimeRange(range: Range): any /** TODO #9100 */;\n}\n\nexport interface Range {}\n\ninterface Events {\n  createScope(signature: string, flags: any): Scope;\n}\n\nexport interface Scope { (...args: any[] /** TODO #9100 */): any; }\n\nlet trace: Trace;\nlet events: Events;\n\nexport function detectWTF(): boolean {\n  const wtf: WTF = (global as any /** TODO #9100 */)['wtf'];\n  if (wtf) {\n    trace = wtf['trace'];\n    if (trace) {\n      events = trace['events'];\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function createScope(signature: string, flags: any = null): any {\n  return events.createScope(signature, flags);\n}\n\nexport function leave<T>(scope: Scope): void;\nexport function leave<T>(scope: Scope, returnValue?: T): T;\nexport function leave<T>(scope: Scope, returnValue?: any): any {\n  trace.leaveScope(scope, returnValue);\n  return returnValue;\n}\n\nexport function startTimeRange(rangeType: string, action: string): Range {\n  return trace.beginTimeRange(rangeType, action);\n}\n\nexport function endTimeRange(range: Range): void {\n  trace.endTimeRange(range);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WtfScopeFn, createScope, detectWTF, endTimeRange, leave, startTimeRange} from './wtf_impl';\n\nexport {WtfScopeFn} from './wtf_impl';\n\n\n/**\n * True if WTF is enabled.\n */\nexport const wtfEnabled = detectWTF();\n\nfunction noopScope(arg0?: any, arg1?: any): any {\n  return null;\n}\n\n/**\n * Create trace scope.\n *\n * Scopes must be strictly nested and are analogous to stack frames, but\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\n * nesting. You may want to use\n * [Event\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n * as they are defined in WTF.\n *\n * Used to mark scope entry. The return value is used to leave the scope.\n *\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n *\n *     someMethod() {\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n *        // DO SOME WORK HERE\n *        return wtfLeave(s, 123); // Return value 123\n *     }\n *\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n * negatively impact the performance of your application. For this reason we recommend that\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n * an exception is expected during normal execution while profiling.\n *\n * @publicApi\n */\nexport const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn =\n    wtfEnabled ? createScope : (signature: string, flags?: any) => noopScope;\n\n/**\n * Used to mark end of Scope.\n *\n * - `scope` to end.\n * - `returnValue` (optional) to be passed to the WTF.\n *\n * Returns the `returnValue for easy chaining.\n * @publicApi\n */\nexport const wtfLeave: <T>(scope: any, returnValue?: T) => T =\n    wtfEnabled ? leave : (s: any, r?: any) => r;\n\n/**\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n * enabled.\n *\n *     someMethod() {\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n *        var future = new Future.delay(5).then((_) {\n *          wtfEndTimeRange(s);\n *        });\n *     }\n * @publicApi\n */\nexport const wtfStartTimeRange: (rangeType: string, action: string) => any =\n    wtfEnabled ? startTimeRange : (rangeType: string, action: string) => null;\n\n/**\n * Ends a async time range operation.\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n * enabled.\n * @publicApi\n */\nexport const wtfEndTimeRange: (range: any) => void = wtfEnabled ? endTimeRange : (r: any) => null;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '../event_emitter';\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  readonly isStable: boolean = true;\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  readonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  readonly onStable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies that an error has been delivered.\n   */\n  readonly onError: EventEmitter<any> = new EventEmitter(false);\n\n  constructor({enableLongStackTrace = false}) {\n    if (typeof Zone == 'undefined') {\n      throw new Error(`In this configuration Angular requires Zone.js`);\n    }\n\n    Zone.assertZonePatched();\n    const self = this as any as NgZonePrivate;\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    if ((Zone as any)['wtfZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['wtfZoneSpec']);\n    }\n\n    if ((Zone as any)['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new ((Zone as any)['TaskTrackingZoneSpec'] as any));\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n\n    forkInnerZoneWithAngularBehavior(self);\n  }\n\n  static isInAngularZone(): boolean { return Zone.current.get('isAngularZone') === true; }\n\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new Error('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new Error('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.run(fn, applyThis, applyArgs) as T;\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const zone = (this as any as NgZonePrivate)._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs) as T;\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.runGuarded(fn, applyThis, applyArgs) as T;\n  }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return (this as any as NgZonePrivate)._outer.run(fn) as T;\n  }\n}\n\nfunction noop() {}\nconst EMPTY_PAYLOAD = {};\n\n\ninterface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n\n  hasPendingMicrotasks: boolean;\n  hasPendingMacrotasks: boolean;\n  isStable: boolean;\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: <any>{'isAngularZone': true},\n    onInvokeTask: (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task, applyThis: any,\n                   applyArgs: any): any => {\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n\n    onInvoke: (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function,\n               applyThis: any, applyArgs: any[], source: string): any => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n    onHasTask:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => {\n          delegate.hasTask(target, hasTaskState);\n          if (current === target) {\n            // We are only interested in hasTask events which originate from our zone\n            // (A child hasTask event is not interesting to us)\n            if (hasTaskState.change == 'microTask') {\n              zone.hasPendingMicrotasks = hasTaskState.microTask;\n              checkStable(zone);\n            } else if (hasTaskState.change == 'macroTask') {\n              zone.hasPendingMacrotasks = hasTaskState.macroTask;\n            }\n          }\n        },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\n\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport class NoopNgZone implements NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly isStable: boolean = true;\n  readonly onUnstable: EventEmitter<any> = new EventEmitter();\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter();\n  readonly onStable: EventEmitter<any> = new EventEmitter();\n  readonly onError: EventEmitter<any> = new EventEmitter();\n\n  run(fn: () => any): any { return fn(); }\n\n  runGuarded(fn: () => any): any { return fn(); }\n\n  runOutsideAngular(fn: () => any): any { return fn(); }\n\n  runTask<T>(fn: () => any): any { return fn(); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, Observer, Subscription, merge} from 'rxjs';\nimport {share} from 'rxjs/operators';\n\nimport {ApplicationInitStatus} from './application_init';\nimport {APP_BOOTSTRAP_LISTENER, PLATFORM_INITIALIZER} from './application_tokens';\nimport {Console} from './console';\nimport {Injectable, InjectionToken, Injector, StaticProvider} from './di';\nimport {ErrorHandler} from './error_handler';\nimport {isDevMode} from './is_dev_mode';\nimport {CompilerFactory, CompilerOptions} from './linker/compiler';\nimport {ComponentFactory, ComponentRef} from './linker/component_factory';\nimport {ComponentFactoryBoundToModule, ComponentFactoryResolver} from './linker/component_factory_resolver';\nimport {InternalNgModuleRef, NgModuleFactory, NgModuleRef} from './linker/ng_module_factory';\nimport {InternalViewRef, ViewRef} from './linker/view_ref';\nimport {WtfScopeFn, wtfCreateScope, wtfLeave} from './profile/profile';\nimport {assertNgModuleType} from './render3/assert';\nimport {NgModuleFactory as R3NgModuleFactory} from './render3/ng_module_ref';\nimport {Testability, TestabilityRegistry} from './testability/testability';\nimport {Type} from './type';\nimport {scheduleMicroTask, stringify} from './util';\nimport {isPromise} from './util/lang';\nimport {NgZone, NoopNgZone} from './zone/ng_zone';\n\nlet _platform: PlatformRef;\n\nlet compileNgModuleFactory:\n    <M>(injector: Injector, options: CompilerOptions, moduleType: Type<M>) =>\n        Promise<NgModuleFactory<M>> = compileNgModuleFactory__PRE_R3__;\n\nfunction compileNgModuleFactory__PRE_R3__<M>(\n    injector: Injector, options: CompilerOptions,\n    moduleType: Type<M>): Promise<NgModuleFactory<M>> {\n  const compilerFactory: CompilerFactory = injector.get(CompilerFactory);\n  const compiler = compilerFactory.createCompiler([options]);\n  return compiler.compileModuleAsync(moduleType);\n}\n\nexport function compileNgModuleFactory__POST_R3__<M>(\n    injector: Injector, options: CompilerOptions,\n    moduleType: Type<M>): Promise<NgModuleFactory<M>> {\n  ngDevMode && assertNgModuleType(moduleType);\n  return Promise.resolve(new R3NgModuleFactory(moduleType));\n}\n\nexport const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken<boolean>('AllowMultipleToken');\n\n\n\n/**\n * A token for third-party components that can register themselves with NgProbe.\n *\n * @publicApi\n */\nexport class NgProbeToken {\n  constructor(public name: string, public token: any) {}\n}\n\n/**\n * Creates a platform.\n * Platforms have to be eagerly created via this function.\n *\n * @publicApi\n */\nexport function createPlatform(injector: Injector): PlatformRef {\n  if (_platform && !_platform.destroyed &&\n      !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n    throw new Error(\n        'There can be only one platform. Destroy the previous one to create a new one.');\n  }\n  _platform = injector.get(PlatformRef);\n  const inits = injector.get(PLATFORM_INITIALIZER, null);\n  if (inits) inits.forEach((init: any) => init());\n  return _platform;\n}\n\n/**\n * Creates a factory for a platform\n *\n * @publicApi\n */\nexport function createPlatformFactory(\n    parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null,\n    name: string, providers: StaticProvider[] = []): (extraProviders?: StaticProvider[]) =>\n    PlatformRef {\n  const desc = `Platform: ${name}`;\n  const marker = new InjectionToken(desc);\n  return (extraProviders: StaticProvider[] = []) => {\n    let platform = getPlatform();\n    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n      if (parentPlatformFactory) {\n        parentPlatformFactory(\n            providers.concat(extraProviders).concat({provide: marker, useValue: true}));\n      } else {\n        const injectedProviders: StaticProvider[] =\n            providers.concat(extraProviders).concat({provide: marker, useValue: true});\n        createPlatform(Injector.create({providers: injectedProviders, name: desc}));\n      }\n    }\n    return assertPlatform(marker);\n  };\n}\n\n/**\n * Checks that there currently is a platform which contains the given token as a provider.\n *\n * @publicApi\n */\nexport function assertPlatform(requiredToken: any): PlatformRef {\n  const platform = getPlatform();\n\n  if (!platform) {\n    throw new Error('No platform exists!');\n  }\n\n  if (!platform.injector.get(requiredToken, null)) {\n    throw new Error(\n        'A platform with a different configuration has been created. Please destroy it first.');\n  }\n\n  return platform;\n}\n\n/**\n * Destroy the existing platform.\n *\n * @publicApi\n */\nexport function destroyPlatform(): void {\n  if (_platform && !_platform.destroyed) {\n    _platform.destroy();\n  }\n}\n\n/**\n * Returns the current platform.\n *\n * @publicApi\n */\nexport function getPlatform(): PlatformRef|null {\n  return _platform && !_platform.destroyed ? _platform : null;\n}\n\n/**\n * Provides additional options to the bootstraping process.\n *\n *\n */\nexport interface BootstrapOptions {\n  /**\n   * Optionally specify which `NgZone` should be used.\n   *\n   * - Provide your own `NgZone` instance.\n   * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\n   * - `noop` - Use `NoopNgZone` which does nothing.\n   */\n  ngZone?: NgZone|'zone.js'|'noop';\n}\n\n/**\n * The Angular platform is the entry point for Angular on a web page. Each page\n * has exactly one platform, and services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n *\n * A page's platform is initialized implicitly when a platform is created via a platform factory\n * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\n *\n * @publicApi\n */\n@Injectable()\nexport class PlatformRef {\n  private _modules: NgModuleRef<any>[] = [];\n  private _destroyListeners: Function[] = [];\n  private _destroyed: boolean = false;\n\n  /** @internal */\n  constructor(private _injector: Injector) {}\n\n  /**\n   * Creates an instance of an `@NgModule` for the given platform\n   * for offline compilation.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```typescript\n   * my_module.ts:\n   *\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * main.ts:\n   * import {MyModuleNgFactory} from './my_module.ngfactory';\n   * import {platformBrowser} from '@angular/platform-browser';\n   *\n   * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\n   * ```\n   */\n  bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions):\n      Promise<NgModuleRef<M>> {\n    // Note: We need to create the NgZone _before_ we instantiate the module,\n    // as instantiating the module creates some providers eagerly.\n    // So we create a mini parent injector that just contains the new NgZone and\n    // pass that as parent to the NgModuleFactory.\n    const ngZoneOption = options ? options.ngZone : undefined;\n    const ngZone = getNgZone(ngZoneOption);\n    const providers: StaticProvider[] = [{provide: NgZone, useValue: ngZone}];\n    // Attention: Don't use ApplicationRef.run here,\n    // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\n    return ngZone.run(() => {\n      const ngZoneInjector = Injector.create(\n          {providers: providers, parent: this.injector, name: moduleFactory.moduleType.name});\n      const moduleRef = <InternalNgModuleRef<M>>moduleFactory.create(ngZoneInjector);\n      const exceptionHandler: ErrorHandler = moduleRef.injector.get(ErrorHandler, null);\n      if (!exceptionHandler) {\n        throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\n      }\n      moduleRef.onDestroy(() => remove(this._modules, moduleRef));\n      ngZone !.runOutsideAngular(\n          () => ngZone !.onError.subscribe(\n              {next: (error: any) => { exceptionHandler.handleError(error); }}));\n      return _callAndReportToErrorHandler(exceptionHandler, ngZone !, () => {\n        const initStatus: ApplicationInitStatus = moduleRef.injector.get(ApplicationInitStatus);\n        initStatus.runInitializers();\n        return initStatus.donePromise.then(() => {\n          this._moduleDoBootstrap(moduleRef);\n          return moduleRef;\n        });\n      });\n    });\n  }\n\n  /**\n   * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```typescript\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n   * ```\n   *\n   */\n  bootstrapModule<M>(\n      moduleType: Type<M>, compilerOptions: (CompilerOptions&BootstrapOptions)|\n      Array<CompilerOptions&BootstrapOptions> = []): Promise<NgModuleRef<M>> {\n    const options = optionsReducer({}, compilerOptions);\n    return compileNgModuleFactory(this.injector, options, moduleType)\n        .then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));\n  }\n\n  private _moduleDoBootstrap(moduleRef: InternalNgModuleRef<any>): void {\n    const appRef = moduleRef.injector.get(ApplicationRef) as ApplicationRef;\n    if (moduleRef._bootstrapComponents.length > 0) {\n      moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));\n    } else if (moduleRef.instance.ngDoBootstrap) {\n      moduleRef.instance.ngDoBootstrap(appRef);\n    } else {\n      throw new Error(\n          `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ` +\n          `Please define one of these.`);\n    }\n    this._modules.push(moduleRef);\n  }\n\n  /**\n   * Register a listener to be called when the platform is disposed.\n   */\n  onDestroy(callback: () => void): void { this._destroyListeners.push(callback); }\n\n  /**\n   * Retrieve the platform {@link Injector}, which is the parent injector for\n   * every Angular application on the page and provides singleton providers.\n   */\n  get injector(): Injector { return this._injector; }\n\n  /**\n   * Destroy the Angular platform and all Angular applications on the page.\n   */\n  destroy() {\n    if (this._destroyed) {\n      throw new Error('The platform has already been destroyed!');\n    }\n    this._modules.slice().forEach(module => module.destroy());\n    this._destroyListeners.forEach(listener => listener());\n    this._destroyed = true;\n  }\n\n  get destroyed() { return this._destroyed; }\n}\n\nfunction getNgZone(ngZoneOption?: NgZone | 'zone.js' | 'noop'): NgZone {\n  let ngZone: NgZone;\n\n  if (ngZoneOption === 'noop') {\n    ngZone = new NoopNgZone();\n  } else {\n    ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) ||\n        new NgZone({enableLongStackTrace: isDevMode()});\n  }\n  return ngZone;\n}\n\nfunction _callAndReportToErrorHandler(\n    errorHandler: ErrorHandler, ngZone: NgZone, callback: () => any): any {\n  try {\n    const result = callback();\n    if (isPromise(result)) {\n      return result.catch((e: any) => {\n        ngZone.runOutsideAngular(() => errorHandler.handleError(e));\n        // rethrow as the exception handler might not do it\n        throw e;\n      });\n    }\n\n    return result;\n  } catch (e) {\n    ngZone.runOutsideAngular(() => errorHandler.handleError(e));\n    // rethrow as the exception handler might not do it\n    throw e;\n  }\n}\n\nfunction optionsReducer<T extends Object>(dst: any, objs: T | T[]): T {\n  if (Array.isArray(objs)) {\n    dst = objs.reduce(optionsReducer, dst);\n  } else {\n    dst = {...dst, ...(objs as any)};\n  }\n  return dst;\n}\n\n/**\n * A reference to an Angular application running on a page.\n *\n * @publicApi\n */\n@Injectable()\nexport class ApplicationRef {\n  /** @internal */\n  static _tickScope: WtfScopeFn = wtfCreateScope('ApplicationRef#tick()');\n  private _bootstrapListeners: ((compRef: ComponentRef<any>) => void)[] = [];\n  private _views: InternalViewRef[] = [];\n  private _runningTick: boolean = false;\n  private _enforceNoNewChanges: boolean = false;\n  private _stable = true;\n\n  /**\n   * Get a list of component types registered to this application.\n   * This list is populated even before the component is created.\n   */\n  public readonly componentTypes: Type<any>[] = [];\n\n  /**\n   * Get a list of components registered to this application.\n   */\n  public readonly components: ComponentRef<any>[] = [];\n\n  /**\n   * Returns an Observable that indicates when the application is stable or unstable.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly isStable !: Observable<boolean>;\n\n  /** @internal */\n  constructor(\n      private _zone: NgZone, private _console: Console, private _injector: Injector,\n      private _exceptionHandler: ErrorHandler,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _initStatus: ApplicationInitStatus) {\n    this._enforceNoNewChanges = isDevMode();\n\n    this._zone.onMicrotaskEmpty.subscribe(\n        {next: () => { this._zone.run(() => { this.tick(); }); }});\n\n    const isCurrentlyStable = new Observable<boolean>((observer: Observer<boolean>) => {\n      this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks &&\n          !this._zone.hasPendingMicrotasks;\n      this._zone.runOutsideAngular(() => {\n        observer.next(this._stable);\n        observer.complete();\n      });\n    });\n\n    const isStable = new Observable<boolean>((observer: Observer<boolean>) => {\n      // Create the subscription to onStable outside the Angular Zone so that\n      // the callback is run outside the Angular Zone.\n      let stableSub: Subscription;\n      this._zone.runOutsideAngular(() => {\n        stableSub = this._zone.onStable.subscribe(() => {\n          NgZone.assertNotInAngularZone();\n\n          // Check whether there are no pending macro/micro tasks in the next tick\n          // to allow for NgZone to update the state.\n          scheduleMicroTask(() => {\n            if (!this._stable && !this._zone.hasPendingMacrotasks &&\n                !this._zone.hasPendingMicrotasks) {\n              this._stable = true;\n              observer.next(true);\n            }\n          });\n        });\n      });\n\n      const unstableSub: Subscription = this._zone.onUnstable.subscribe(() => {\n        NgZone.assertInAngularZone();\n        if (this._stable) {\n          this._stable = false;\n          this._zone.runOutsideAngular(() => { observer.next(false); });\n        }\n      });\n\n      return () => {\n        stableSub.unsubscribe();\n        unstableSub.unsubscribe();\n      };\n    });\n\n    (this as{isStable: Observable<boolean>}).isStable =\n        merge(isCurrentlyStable, isStable.pipe(share()));\n  }\n\n  /**\n   * Bootstrap a new component at the root level of the application.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a new root component into an application, Angular mounts the\n   * specified application component onto DOM elements identified by the componentType's\n   * selector and kicks off automatic change detection to finish initializing the component.\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * componentType's selector.\n   *\n   * ### Example\n   * {@example core/ts/platform/platform.ts region='longform'}\n   */\n  bootstrap<C>(componentOrFactory: ComponentFactory<C>|Type<C>, rootSelectorOrNode?: string|any):\n      ComponentRef<C> {\n    if (!this._initStatus.done) {\n      throw new Error(\n          'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\n    }\n    let componentFactory: ComponentFactory<C>;\n    if (componentOrFactory instanceof ComponentFactory) {\n      componentFactory = componentOrFactory;\n    } else {\n      componentFactory =\n          this._componentFactoryResolver.resolveComponentFactory(componentOrFactory) !;\n    }\n    this.componentTypes.push(componentFactory.componentType);\n\n    // Create a factory associated with the current module if it's not bound to some other\n    const ngModule = componentFactory instanceof ComponentFactoryBoundToModule ?\n        null :\n        this._injector.get(NgModuleRef);\n    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;\n    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);\n\n    compRef.onDestroy(() => { this._unloadComponent(compRef); });\n    const testability = compRef.injector.get(Testability, null);\n    if (testability) {\n      compRef.injector.get(TestabilityRegistry)\n          .registerApplication(compRef.location.nativeElement, testability);\n    }\n\n    this._loadComponent(compRef);\n    if (isDevMode()) {\n      this._console.log(\n          `Angular is running in the development mode. Call enableProdMode() to enable the production mode.`);\n    }\n    return compRef;\n  }\n\n  /**\n   * Invoke this method to explicitly process change detection and its side-effects.\n   *\n   * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n   * further changes are detected. If additional changes are picked up during this second cycle,\n   * bindings in the app have side-effects that cannot be resolved in a single change detection\n   * pass.\n   * In this case, Angular throws an error, since an Angular application can only have one change\n   * detection pass during which all change detection must complete.\n   */\n  tick(): void {\n    if (this._runningTick) {\n      throw new Error('ApplicationRef.tick is called recursively');\n    }\n\n    const scope = ApplicationRef._tickScope();\n    try {\n      this._runningTick = true;\n      this._views.forEach((view) => view.detectChanges());\n      if (this._enforceNoNewChanges) {\n        this._views.forEach((view) => view.checkNoChanges());\n      }\n    } catch (e) {\n      // Attention: Don't rethrow as it could cancel subscriptions to Observables!\n      this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));\n    } finally {\n      this._runningTick = false;\n      wtfLeave(scope);\n    }\n  }\n\n  /**\n   * Attaches a view so that it will be dirty checked.\n   * The view will be automatically detached when it is destroyed.\n   * This will throw if the view is already attached to a ViewContainer.\n   */\n  attachView(viewRef: ViewRef): void {\n    const view = (viewRef as InternalViewRef);\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n\n  /**\n   * Detaches a view from dirty checking again.\n   */\n  detachView(viewRef: ViewRef): void {\n    const view = (viewRef as InternalViewRef);\n    remove(this._views, view);\n    view.detachFromAppRef();\n  }\n\n  private _loadComponent(componentRef: ComponentRef<any>): void {\n    this.attachView(componentRef.hostView);\n    this.tick();\n    this.components.push(componentRef);\n    // Get the listeners lazily to prevent DI cycles.\n    const listeners =\n        this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);\n    listeners.forEach((listener) => listener(componentRef));\n  }\n\n  private _unloadComponent(componentRef: ComponentRef<any>): void {\n    this.detachView(componentRef.hostView);\n    remove(this.components, componentRef);\n  }\n\n  /** @internal */\n  ngOnDestroy() {\n    // TODO(alxhub): Dispose of the NgZone.\n    this._views.slice().forEach((view) => view.destroy());\n  }\n\n  /**\n   * Returns the number of attached views.\n   */\n  get viewCount() { return this._views.length; }\n}\n\nfunction remove<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di';\nimport {scheduleMicroTask} from '../util';\nimport {NgZone} from '../zone/ng_zone';\n\n/**\n * Testability API.\n * `declare` keyword causes tsickle to generate externs, so these methods are\n * not renamed by Closure Compiler.\n * @publicApi\n */\nexport declare interface PublicTestability {\n  isStable(): boolean;\n  whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\n  findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\n\n// Angular internal, not intended for public API.\nexport interface PendingMacrotask {\n  source: string;\n  creationLocation: Error;\n  runCount?: number;\n  data: TaskData;\n}\n\nexport interface TaskData {\n  target?: XMLHttpRequest;\n  delay?: number;\n  isPeriodic?: boolean;\n}\n\n// Angular internal, not intended for public API.\nexport type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;\nexport type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;\n\ninterface WaitCallback {\n  // Needs to be 'any' - setTimeout returns a number according to ES6, but\n  // on NodeJS it returns a Timer.\n  timeoutId: any;\n  doneCb: DoneCallback;\n  updateCb?: UpdateCallback;\n}\n\n/**\n * The Testability service provides testing hooks that can be accessed from\n * the browser and by services such as Protractor. Each bootstrapped Angular\n * application on the page will have an instance of Testability.\n * @publicApi\n */\n@Injectable()\nexport class Testability implements PublicTestability {\n  private _pendingCount: number = 0;\n  private _isZoneStable: boolean = true;\n  /**\n   * Whether any work was done since the last 'whenStable' callback. This is\n   * useful to detect if this could have potentially destabilized another\n   * component while it is stabilizing.\n   * @internal\n   */\n  private _didWork: boolean = false;\n  private _callbacks: WaitCallback[] = [];\n\n  private taskTrackingZone: {macroTasks: Task[]}|null = null;\n\n  constructor(private _ngZone: NgZone) {\n    this._watchAngularEvents();\n    _ngZone.run(() => {\n      this.taskTrackingZone =\n          typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');\n    });\n  }\n\n  private _watchAngularEvents(): void {\n    this._ngZone.onUnstable.subscribe({\n      next: () => {\n        this._didWork = true;\n        this._isZoneStable = false;\n      }\n    });\n\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.subscribe({\n        next: () => {\n          NgZone.assertNotInAngularZone();\n          scheduleMicroTask(() => {\n            this._isZoneStable = true;\n            this._runCallbacksIfReady();\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Increases the number of pending request\n   * @deprecated pending requests are now tracked with zones.\n   */\n  increasePendingRequestCount(): number {\n    this._pendingCount += 1;\n    this._didWork = true;\n    return this._pendingCount;\n  }\n\n  /**\n   * Decreases the number of pending request\n   * @deprecated pending requests are now tracked with zones\n   */\n  decreasePendingRequestCount(): number {\n    this._pendingCount -= 1;\n    if (this._pendingCount < 0) {\n      throw new Error('pending async requests below zero');\n    }\n    this._runCallbacksIfReady();\n    return this._pendingCount;\n  }\n\n  /**\n   * Whether an associated application is stable\n   */\n  isStable(): boolean {\n    return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;\n  }\n\n  private _runCallbacksIfReady(): void {\n    if (this.isStable()) {\n      // Schedules the call backs in a new frame so that it is always async.\n      scheduleMicroTask(() => {\n        while (this._callbacks.length !== 0) {\n          let cb = this._callbacks.pop() !;\n          clearTimeout(cb.timeoutId);\n          cb.doneCb(this._didWork);\n        }\n        this._didWork = false;\n      });\n    } else {\n      // Still not stable, send updates.\n      let pending = this.getPendingTasks();\n      this._callbacks = this._callbacks.filter((cb) => {\n        if (cb.updateCb && cb.updateCb(pending)) {\n          clearTimeout(cb.timeoutId);\n          return false;\n        }\n\n        return true;\n      });\n\n      this._didWork = true;\n    }\n  }\n\n  private getPendingTasks(): PendingMacrotask[] {\n    if (!this.taskTrackingZone) {\n      return [];\n    }\n\n    // Copy the tasks data so that we don't leak tasks.\n    return this.taskTrackingZone.macroTasks.map((t: Task) => {\n      return {\n        source: t.source,\n        // From TaskTrackingZone:\n        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\n        creationLocation: (t as any).creationLocation as Error,\n        data: t.data\n      };\n    });\n  }\n\n  private addCallback(cb: DoneCallback, timeout?: number, updateCb?: UpdateCallback) {\n    let timeoutId: any = -1;\n    if (timeout && timeout > 0) {\n      timeoutId = setTimeout(() => {\n        this._callbacks = this._callbacks.filter((cb) => cb.timeoutId !== timeoutId);\n        cb(this._didWork, this.getPendingTasks());\n      }, timeout);\n    }\n    this._callbacks.push(<WaitCallback>{doneCb: cb, timeoutId: timeoutId, updateCb: updateCb});\n  }\n\n  /**\n   * Wait for the application to be stable with a timeout. If the timeout is reached before that\n   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n   *\n   * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n   *    whichever comes first.\n   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n   *    specified, whenStable() will wait forever.\n   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n   *    and no further updates will be issued.\n   */\n  whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void {\n    if (updateCb && !this.taskTrackingZone) {\n      throw new Error(\n          'Task tracking zone is required when passing an update callback to ' +\n          'whenStable(). Is \"zone.js/dist/task-tracking.js\" loaded?');\n    }\n    // These arguments are 'Function' above to keep the public API simple.\n    this.addCallback(doneCb as DoneCallback, timeout, updateCb as UpdateCallback);\n    this._runCallbacksIfReady();\n  }\n\n  /**\n   * Get the number of pending requests\n   * @deprecated pending requests are now tracked with zones\n   */\n  getPendingRequestCount(): number { return this._pendingCount; }\n\n  /**\n   * Find providers by name\n   * @param using The root element to search from\n   * @param provider The name of binding variable\n   * @param exactMatch Whether using exactMatch\n   */\n  findProviders(using: any, provider: string, exactMatch: boolean): any[] {\n    // TODO(juliemr): implement.\n    return [];\n  }\n}\n\n/**\n * A global registry of {@link Testability} instances for specific elements.\n * @publicApi\n */\n@Injectable()\nexport class TestabilityRegistry {\n  /** @internal */\n  _applications = new Map<any, Testability>();\n\n  constructor() { _testabilityGetter.addToWindow(this); }\n\n  /**\n   * Registers an application with a testability hook so that it can be tracked\n   * @param token token of application, root element\n   * @param testability Testability hook\n   */\n  registerApplication(token: any, testability: Testability) {\n    this._applications.set(token, testability);\n  }\n\n  /**\n   * Unregisters an application.\n   * @param token token of application, root element\n   */\n  unregisterApplication(token: any) { this._applications.delete(token); }\n\n  /**\n   * Unregisters all applications\n   */\n  unregisterAllApplications() { this._applications.clear(); }\n\n  /**\n   * Get a testability hook associated with the application\n   * @param elem root element\n   */\n  getTestability(elem: any): Testability|null { return this._applications.get(elem) || null; }\n\n  /**\n   * Get all registered testabilities\n   */\n  getAllTestabilities(): Testability[] { return Array.from(this._applications.values()); }\n\n  /**\n   * Get all registered applications(root elements)\n   */\n  getAllRootElements(): any[] { return Array.from(this._applications.keys()); }\n\n  /**\n   * Find testability of a node in the Tree\n   * @param elem node\n   * @param findInAncestors whether finding testability in ancestors if testability was not found in\n   * current node\n   */\n  findTestabilityInTree(elem: Node, findInAncestors: boolean = true): Testability|null {\n    return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\n  }\n}\n\n/**\n * Adapter interface for retrieving the `Testability` service associated for a\n * particular context.\n *\n * @publicApi\n */\nexport interface GetTestability {\n  addToWindow(registry: TestabilityRegistry): void;\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null;\n}\n\nclass _NoopGetTestability implements GetTestability {\n  addToWindow(registry: TestabilityRegistry): void {}\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    return null;\n  }\n}\n\n/**\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\n * @publicApi\n */\nexport function setTestabilityGetter(getter: GetTestability): void {\n  _testabilityGetter = getter;\n}\n\nlet _testabilityGetter: GetTestability = new _NoopGetTestability();\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike} from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n * ### Merge together two Observables: 1s interval and clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * ### Merge together 3 Observables, but only 2 run concurrently\n * ```javascript\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: SchedulerLike = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <SchedulerLike>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll<R>(concurrent)(fromArray<any>(observables, scheduler));\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput } from '../types';\n\nexport function mergeAll<T>(concurrent?: number): OperatorFunction<ObservableInput<T>, T>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map((ev) => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(10))),\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport function mergeAll<T>(concurrent: number = Number.POSITIVE_INFINITY): MonoTypeOperatorFunction<T> {\n  return mergeMap<T, T>(identity as (value: T, index: number) => ObservableInput<T>, concurrent);\n}\n","import { Observable } from '../Observable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isIterable } from '../util/isIterable';\nimport { fromArray } from './fromArray';\nimport { fromPromise } from './fromPromise';\nimport { fromIterable } from './fromIterable';\nimport { fromObservable } from './fromObservable';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { ObservableInput, SchedulerLike } from '../types';\n\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport function from<T>(input: ObservableInput<ObservableInput<T>>, scheduler?: SchedulerLike): Observable<Observable<T>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n * ### Converts an array to an Observable\n * ```javascript\n * import { from } from 'rxjs/observable/from';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10 20 30\n * ```\n *\n * ---\n *\n * ### Convert an infinite iterable (from a generator) to an Observable\n * ```javascript\n * import { take } from 'rxjs/operators';\n * import { from } from 'rxjs/observable/from';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3 6 12 24 48 96 192 384 768 1536\n * ```\n *\n * ---\n *\n * ### with async scheduler\n * ```javascript\n * import { from } from 'rxjs/observable/from';\n * import { async } from 'rxjs/scheduler/async';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, async);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // start end 10 20 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n * @see {@link fromPromise}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n * @name from\n * @owner Observable\n */\n\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  if (!scheduler) {\n    if (input instanceof Observable) {\n      return input;\n    }\n    return new Observable<T>(subscribeTo(input));\n  }\n\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromObservable(input, scheduler);\n    } else if (isPromise(input)) {\n      return fromPromise(input, scheduler);\n    } else if (isArrayLike(input)) {\n      return fromArray(input, scheduler);\n    }  else if (isIterable(input) || typeof input === 'string') {\n      return fromIterable(input, scheduler);\n    }\n  }\n\n  throw new TypeError((input !== null && typeof input || input) + ' is not observable');\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return input && typeof input[Symbol_observable] === 'function';\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { subscribeToObservable } from '../util/subscribeToObservable';\nimport { InteropObservable, SchedulerLike, Subscribable } from '../types';\n\nexport function fromObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToObservable(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      sub.add(scheduler.schedule(() => {\n        const observable: Subscribable<T> = input[Symbol_observable]();\n        sub.add(observable.subscribe({\n          next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); },\n          error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); },\n          complete() { sub.add(scheduler.schedule(() => subscriber.complete())); },\n        }));\n      }));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToPromise } from '../util/subscribeToPromise';\n\nexport function fromPromise<T>(input: PromiseLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToPromise(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      sub.add(scheduler.schedule(() => input.then(\n        value => {\n          sub.add(scheduler.schedule(() => {\n            subscriber.next(value);\n            sub.add(scheduler.schedule(() => subscriber.complete()));\n          }));\n        },\n        err => {\n          sub.add(scheduler.schedule(() => subscriber.error(err)));\n        }\n      )));\n      return sub;\n    });\n  }\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return input && typeof input[Symbol_iterator] === 'function';\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { subscribeToIterable } from '../util/subscribeToIterable';\n\nexport function fromIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  if (!scheduler) {\n    return new Observable<T>(subscribeToIterable(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let iterator: Iterator<T>;\n      sub.add(() => {\n        // Finalize generators\n        if (iterator && typeof iterator.return === 'function') {\n          iterator.return();\n        }\n      });\n      sub.add(scheduler.schedule(() => {\n        iterator = input[Symbol_iterator]();\n        sub.add(scheduler.schedule(function () {\n          if (subscriber.closed) {\n            return;\n          }\n          let value: T;\n          let done: boolean;\n          try {\n            const result = iterator.next();\n            value = result.value;\n            done = result.done;\n          } catch (err) {\n            subscriber.error(err);\n            return;\n          }\n          if (done) {\n            subscriber.complete();\n          } else {\n            subscriber.next(value);\n            this.schedule();\n          }\n        }));\n      }));\n      return sub;\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\nimport {EventEmitter} from '../event_emitter';\nimport {getSymbolIterator} from '../util';\n\n\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nexport class QueryList<T>/* implements Iterable<T> */ {\n  public readonly dirty = true;\n  private _results: Array<T> = [];\n  public readonly changes: Observable<any> = new EventEmitter();\n\n  readonly length: number = 0;\n  // TODO(issue/24571): remove '!'.\n  readonly first !: T;\n  // TODO(issue/24571): remove '!'.\n  readonly last !: T;\n\n  /**\n   * See\n   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   */\n  map<U>(fn: (item: T, index: number, array: T[]) => U): U[] { return this._results.map(fn); }\n\n  /**\n   * See\n   * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n   */\n  filter(fn: (item: T, index: number, array: T[]) => boolean): T[] {\n    return this._results.filter(fn);\n  }\n\n  /**\n   * See\n   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n   */\n  find(fn: (item: T, index: number, array: T[]) => boolean): T|undefined {\n    return this._results.find(fn);\n  }\n\n  /**\n   * See\n   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n   */\n  reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U {\n    return this._results.reduce(fn, init);\n  }\n\n  /**\n   * See\n   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   */\n  forEach(fn: (item: T, index: number, array: T[]) => void): void { this._results.forEach(fn); }\n\n  /**\n   * See\n   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n   */\n  some(fn: (value: T, index: number, array: T[]) => boolean): boolean {\n    return this._results.some(fn);\n  }\n\n  toArray(): T[] { return this._results.slice(); }\n\n  [getSymbolIterator()](): Iterator<T> { return (this._results as any)[getSymbolIterator()](); }\n\n  toString(): string { return this._results.toString(); }\n\n  reset(res: Array<T|any[]>): void {\n    this._results = flatten(res);\n    (this as{dirty: boolean}).dirty = false;\n    (this as{length: number}).length = this._results.length;\n    (this as{last: T}).last = this._results[this.length - 1];\n    (this as{first: T}).first = this._results[0];\n  }\n\n  notifyOnChanges(): void { (this.changes as EventEmitter<any>).emit(this); }\n\n  /** internal */\n  setDirty() { (this as{dirty: boolean}).dirty = true; }\n\n  /** internal */\n  destroy(): void {\n    (this.changes as EventEmitter<any>).complete();\n    (this.changes as EventEmitter<any>).unsubscribe();\n  }\n}\n\nfunction flatten<T>(list: Array<T|T[]>): T[] {\n  return list.reduce((flat: any[], item: T | T[]): T[] => {\n    const flatItem = Array.isArray(item) ? flatten(item) : item;\n    return (<T[]>flat).concat(flatItem);\n  }, []);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {injectViewContainerRef as render3InjectViewContainerRef} from '../render3/view_engine_compatibility';\nimport {noop} from '../util/noop';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {TemplateRef} from './template_ref';\nimport {EmbeddedViewRef, ViewRef} from './view_ref';\n\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nexport abstract class ViewContainerRef {\n  /**\n   * Anchor element that specifies the location of this container in the containing view.\n   * Each view container can have only one anchor element, and each anchor element\n   * can have only a single view container.\n   *\n   * Root elements of views attached to this container become siblings of the anchor element in\n   * the rendered view.\n   *\n   * Access the `ViewContainerRef` of an element by placing a `Directive` injected\n   * with `ViewContainerRef` on the element, or use a `ViewChild` query.\n   *\n   * <!-- TODO: rename to anchorElement -->\n   */\n  abstract get element(): ElementRef;\n\n  /**\n   * The [dependency injector](guide/glossary#injector) for this view container.\n   */\n  abstract get injector(): Injector;\n\n  /** @deprecated No replacement */\n  abstract get parentInjector(): Injector;\n\n  /**\n   * Destroys all views in this container.\n   */\n  abstract clear(): void;\n\n  /**\n   * Retrieves a view from this container.\n   * @param index The 0-based index of the view to retrieve.\n   * @returns The `ViewRef` instance, or null if the index is out of range.\n   */\n  abstract get(index: number): ViewRef|null;\n\n  /**\n   * Reports how many views are currently attached to this container.\n   * @returns The number of views.\n   */\n  abstract get length(): number;\n\n  /**\n   * Instantiates an embedded view and inserts it\n   * into this container.\n   * @param templateRef The HTML template that defines the view.\n   * @param index The 0-based index at which to insert the new view into this container.\n   * If not specified, appends the new view as the last entry.\n   *\n   * @returns The `ViewRef` instance for the newly created view.\n   */\n  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n      EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates a single component and inserts its host view into this container.\n   *\n   * @param componentFactory The factory to use.\n   * @param index The index at which to insert the new component's host view into this container.\n   * If not specified, appends the new view as the last entry.\n   * @param injector The injector to use as the parent for the new component.\n   * @param projectableNodes\n   * @param ngModule\n   *\n   * @returns The new component instance, containing the host view.\n   *\n   */\n  abstract createComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;\n\n  /**\n   * Inserts a view into this container.\n   * @param viewRef The view to insert.\n   * @param index The 0-based index at which to insert the view.\n   * If not specified, appends the new view as the last entry.\n   * @returns The inserted `ViewRef` instance.\n   *\n   */\n  abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n\n  /**\n   * Moves a view to a new location in this container.\n   * @param viewRef The view to move.\n   * @param index The 0-based index of the new location.\n   * @returns The moved `ViewRef` instance.\n   */\n  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\n\n  /**\n   * Returns the index of a view within the current container.\n   * @param viewRef The view to query.\n   * @returns The 0-based index of the view's position in this container,\n   * or `-1` if this container doesn't contain the view.\n   */\n  abstract indexOf(viewRef: ViewRef): number;\n\n  /**\n   * Destroys a view attached to this container\n   * @param index The 0-based index of the view to destroy.\n   * If not specified, the last view in the container is removed.\n   */\n  abstract remove(index?: number): void;\n\n  /**\n   * Detaches a view from this container without destroying it.\n   * Use along with `insert()` to move a view within the current container.\n   * @param index The 0-based index of the view to detach.\n   * If not specified, the last view in the container is detached.\n   */\n  abstract detach(index?: number): ViewRef|null;\n\n  /** @internal */\n  static __NG_ELEMENT_ID__:\n      () => ViewContainerRef = () => SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef)\n}\n\nexport const SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ = render3InjectViewContainerRef;\nconst SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__ = noop;\nconst SWITCH_VIEW_CONTAINER_REF_FACTORY: typeof render3InjectViewContainerRef =\n    SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectChangeDetectorRef as render3InjectChangeDetectorRef} from '../render3/view_engine_compatibility';\n\n/**\n * Base class for Angular Views, provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\"\n * region=\"mark-for-check\"></code-example>\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"reattach\"></code-example>\n *\n * @publicApi\n */\nexport abstract class ChangeDetectorRef {\n  /**\n   * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)\n   * change detection strategy, explicitly marks the view as changed so that\n   * it can be checked again.\n   *\n   * Components are normally marked as dirty (in need of rerendering) when inputs\n   * have changed or events have fired in the view. Call this method to ensure that\n   * a component is checked even if these triggers have not occured.\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   */\n  abstract markForCheck(): void;\n\n  /**\n   * Detaches this view from the change-detection tree.\n   * A detached view is  not checked until it is reattached.\n   * Use in combination with `detectChanges()` to implement local change detection checks.\n   *\n   * Detached views are not checked during change detection runs until they are\n   * re-attached, even if they are marked as dirty.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detach(): void;\n\n  /**\n   * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach\n   * detach}\n   * to implement local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detectChanges(): void;\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * Use in development mode to verify that running change detection doesn't introduce\n   * other changes.\n   */\n  abstract checkNoChanges(): void;\n\n  /**\n   * Re-attaches the previously detached view to the change detection tree.\n   * Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   */\n  abstract reattach(): void;\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => ChangeDetectorRef = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY();\n}\n\n\n\nexport const SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = render3InjectChangeDetectorRef;\nconst SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ = (...args: any[]): any => {};\nconst SWITCH_CHANGE_DETECTOR_REF_FACTORY: typeof render3InjectChangeDetectorRef =\n    SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di';\nimport {assertDomNode} from '../render3/assert';\nimport {getComponent, getContext, getInjectionTokens, getInjector, getListeners, getLocalRefs, isBrowserEvents, loadLContext, loadLContextFromNode} from '../render3/discovery_utils';\nimport {TNode} from '../render3/interfaces/node';\nimport {StylingIndex} from '../render3/interfaces/styling';\nimport {TVIEW} from '../render3/interfaces/view';\nimport {getProp, getValue, isClassBasedValue} from '../render3/styling/class_and_style_bindings';\nimport {getStylingContext} from '../render3/styling/util';\nimport {DebugContext} from '../view/index';\n\nexport class EventListener {\n  constructor(public name: string, public callback: Function) {}\n}\n\n/**\n * @publicApi\n */\nexport interface DebugNode {\n  readonly listeners: EventListener[];\n  readonly parent: DebugElement|null;\n  readonly nativeNode: any;\n  readonly injector: Injector;\n  readonly componentInstance: any;\n  readonly context: any;\n  readonly references: {[key: string]: any};\n  readonly providerTokens: any[];\n}\nexport class DebugNode__PRE_R3__ {\n  readonly listeners: EventListener[] = [];\n  readonly parent: DebugElement|null = null;\n  readonly nativeNode: any;\n  private readonly _debugContext: DebugContext;\n\n  constructor(nativeNode: any, parent: DebugNode|null, _debugContext: DebugContext) {\n    this._debugContext = _debugContext;\n    this.nativeNode = nativeNode;\n    if (parent && parent instanceof DebugElement__PRE_R3__) {\n      parent.addChild(this);\n    }\n  }\n\n  get injector(): Injector { return this._debugContext.injector; }\n\n  get componentInstance(): any { return this._debugContext.component; }\n\n  get context(): any { return this._debugContext.context; }\n\n  get references(): {[key: string]: any} { return this._debugContext.references; }\n\n  get providerTokens(): any[] { return this._debugContext.providerTokens; }\n}\n\n/**\n * @publicApi\n */\nexport interface DebugElement extends DebugNode {\n  readonly name: string;\n  readonly properties: {[key: string]: any};\n  readonly attributes: {[key: string]: string | null};\n  readonly classes: {[key: string]: boolean};\n  readonly styles: {[key: string]: string | null};\n  readonly childNodes: DebugNode[];\n  readonly nativeElement: any;\n  readonly children: DebugElement[];\n\n  query(predicate: Predicate<DebugElement>): DebugElement;\n  queryAll(predicate: Predicate<DebugElement>): DebugElement[];\n  queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];\n  triggerEventHandler(eventName: string, eventObj: any): void;\n}\nexport class DebugElement__PRE_R3__ extends DebugNode__PRE_R3__ implements DebugElement {\n  readonly name !: string;\n  readonly properties: {[key: string]: any} = {};\n  readonly attributes: {[key: string]: string | null} = {};\n  readonly classes: {[key: string]: boolean} = {};\n  readonly styles: {[key: string]: string | null} = {};\n  readonly childNodes: DebugNode[] = [];\n  readonly nativeElement: any;\n\n  constructor(nativeNode: any, parent: any, _debugContext: DebugContext) {\n    super(nativeNode, parent, _debugContext);\n    this.nativeElement = nativeNode;\n  }\n\n  addChild(child: DebugNode) {\n    if (child) {\n      this.childNodes.push(child);\n      (child as{parent: DebugNode}).parent = this;\n    }\n  }\n\n  removeChild(child: DebugNode) {\n    const childIndex = this.childNodes.indexOf(child);\n    if (childIndex !== -1) {\n      (child as{parent: DebugNode | null}).parent = null;\n      this.childNodes.splice(childIndex, 1);\n    }\n  }\n\n  insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]) {\n    const siblingIndex = this.childNodes.indexOf(child);\n    if (siblingIndex !== -1) {\n      this.childNodes.splice(siblingIndex + 1, 0, ...newChildren);\n      newChildren.forEach(c => {\n        if (c.parent) {\n          (c.parent as DebugElement__PRE_R3__).removeChild(c);\n        }\n        (child as{parent: DebugNode}).parent = this;\n      });\n    }\n  }\n\n  insertBefore(refChild: DebugNode, newChild: DebugNode): void {\n    const refIndex = this.childNodes.indexOf(refChild);\n    if (refIndex === -1) {\n      this.addChild(newChild);\n    } else {\n      if (newChild.parent) {\n        (newChild.parent as DebugElement__PRE_R3__).removeChild(newChild);\n      }\n      (newChild as{parent: DebugNode}).parent = this;\n      this.childNodes.splice(refIndex, 0, newChild);\n    }\n  }\n\n  query(predicate: Predicate<DebugElement>): DebugElement {\n    const results = this.queryAll(predicate);\n    return results[0] || null;\n  }\n\n  queryAll(predicate: Predicate<DebugElement>): DebugElement[] {\n    const matches: DebugElement[] = [];\n    _queryElementChildren(this, predicate, matches);\n    return matches;\n  }\n\n  queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[] {\n    const matches: DebugNode[] = [];\n    _queryNodeChildren(this, predicate, matches);\n    return matches;\n  }\n\n  get children(): DebugElement[] {\n    return this\n        .childNodes  //\n        .filter((node) => node instanceof DebugElement__PRE_R3__) as DebugElement[];\n  }\n\n  triggerEventHandler(eventName: string, eventObj: any) {\n    this.listeners.forEach((listener) => {\n      if (listener.name == eventName) {\n        listener.callback(eventObj);\n      }\n    });\n  }\n}\n\n/**\n * @publicApi\n */\nexport function asNativeElements(debugEls: DebugElement[]): any {\n  return debugEls.map((el) => el.nativeElement);\n}\n\nfunction _queryElementChildren(\n    element: DebugElement, predicate: Predicate<DebugElement>, matches: DebugElement[]) {\n  element.childNodes.forEach(node => {\n    if (node instanceof DebugElement__PRE_R3__) {\n      if (predicate(node)) {\n        matches.push(node);\n      }\n      _queryElementChildren(node, predicate, matches);\n    }\n  });\n}\n\nfunction _queryNodeChildren(\n    parentNode: DebugNode, predicate: Predicate<DebugNode>, matches: DebugNode[]) {\n  if (parentNode instanceof DebugElement__PRE_R3__) {\n    parentNode.childNodes.forEach(node => {\n      if (predicate(node)) {\n        matches.push(node);\n      }\n      if (node instanceof DebugElement__PRE_R3__) {\n        _queryNodeChildren(node, predicate, matches);\n      }\n    });\n  }\n}\n\nfunction notImplemented(): Error {\n  throw new Error('Missing proper ivy implementation.');\n}\n\nclass DebugNode__POST_R3__ implements DebugNode {\n  readonly nativeNode: Node;\n\n  constructor(nativeNode: Node) { this.nativeNode = nativeNode; }\n\n  get parent(): DebugElement|null {\n    const parent = this.nativeNode.parentNode as Element;\n    return parent ? new DebugElement__POST_R3__(parent) : null;\n  }\n\n  get injector(): Injector { return getInjector(this.nativeNode); }\n\n  get componentInstance(): any {\n    const nativeElement = this.nativeNode;\n    return nativeElement && getComponent(nativeElement as Element);\n  }\n  get context(): any { return getContext(this.nativeNode as Element); }\n\n  get listeners(): EventListener[] {\n    return getListeners(this.nativeNode as Element).filter(isBrowserEvents);\n  }\n\n  get references(): {[key: string]: any;} { return getLocalRefs(this.nativeNode); }\n\n  get providerTokens(): any[] { return getInjectionTokens(this.nativeNode as Element); }\n}\n\nclass DebugElement__POST_R3__ extends DebugNode__POST_R3__ implements DebugElement {\n  constructor(nativeNode: Element) {\n    ngDevMode && assertDomNode(nativeNode);\n    super(nativeNode);\n  }\n\n  get nativeElement(): Element|null {\n    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode as Element : null;\n  }\n\n  get name(): string { return this.nativeElement !.nodeName; }\n\n  get properties(): {[key: string]: any;} {\n    const context = loadLContext(this.nativeNode) !;\n    const lView = context.lView;\n    const tView = lView[TVIEW];\n    const tNode = tView.data[context.nodeIndex] as TNode;\n    const properties = {};\n    // TODO: https://angular-team.atlassian.net/browse/FW-681\n    // Missing implementation here...\n    return properties;\n  }\n\n  get attributes(): {[key: string]: string | null;} {\n    const attributes: {[key: string]: string | null;} = {};\n    const element = this.nativeElement;\n    if (element) {\n      const eAttrs = element.attributes;\n      for (let i = 0; i < eAttrs.length; i++) {\n        const attr = eAttrs[i];\n        attributes[attr.name] = attr.value;\n      }\n    }\n    return attributes;\n  }\n\n  get classes(): {[key: string]: boolean;} {\n    const classes: {[key: string]: boolean;} = {};\n    const element = this.nativeElement;\n    if (element) {\n      const lContext = loadLContextFromNode(element);\n      const lNode = lContext.lView[lContext.nodeIndex];\n      const stylingContext = getStylingContext(lContext.nodeIndex, lContext.lView);\n      if (stylingContext) {\n        for (let i = StylingIndex.SingleStylesStartPosition; i < lNode.length;\n             i += StylingIndex.Size) {\n          if (isClassBasedValue(lNode, i)) {\n            const className = getProp(lNode, i);\n            const value = getValue(lNode, i);\n            if (typeof value == 'boolean') {\n              // we want to ignore `null` since those don't overwrite the values.\n              classes[className] = value;\n            }\n          }\n        }\n      } else {\n        // Fallback, just read DOM.\n        const eClasses = element.classList;\n        for (let i = 0; i < eClasses.length; i++) {\n          classes[eClasses[i]] = true;\n        }\n      }\n    }\n    return classes;\n  }\n\n  get styles(): {[key: string]: string | null;} {\n    const styles: {[key: string]: string | null;} = {};\n    const element = this.nativeElement;\n    if (element) {\n      const lContext = loadLContextFromNode(element);\n      const lNode = lContext.lView[lContext.nodeIndex];\n      const stylingContext = getStylingContext(lContext.nodeIndex, lContext.lView);\n      if (stylingContext) {\n        for (let i = StylingIndex.SingleStylesStartPosition; i < lNode.length;\n             i += StylingIndex.Size) {\n          if (!isClassBasedValue(lNode, i)) {\n            const styleName = getProp(lNode, i);\n            const value = getValue(lNode, i) as string | null;\n            if (value !== null) {\n              // we want to ignore `null` since those don't overwrite the values.\n              styles[styleName] = value;\n            }\n          }\n        }\n      } else {\n        // Fallback, just read DOM.\n        const eStyles = (element as HTMLElement).style;\n        for (let i = 0; i < eStyles.length; i++) {\n          const name = eStyles.item(i);\n          styles[name] = eStyles.getPropertyValue(name);\n        }\n      }\n    }\n    return styles;\n  }\n\n  get childNodes(): DebugNode[] {\n    const childNodes = this.nativeNode.childNodes;\n    const children: DebugNode[] = [];\n    for (let i = 0; i < childNodes.length; i++) {\n      const element = childNodes[i];\n      children.push(getDebugNode__POST_R3__(element));\n    }\n    return children;\n  }\n\n  get children(): DebugElement[] {\n    const nativeElement = this.nativeElement;\n    if (!nativeElement) return [];\n    const childNodes = nativeElement.children;\n    const children: DebugElement[] = [];\n    for (let i = 0; i < childNodes.length; i++) {\n      const element = childNodes[i];\n      children.push(getDebugNode__POST_R3__(element));\n    }\n    return children;\n  }\n\n  query(predicate: Predicate<DebugElement>): DebugElement {\n    const results = this.queryAll(predicate);\n    return results[0] || null;\n  }\n\n  queryAll(predicate: Predicate<DebugElement>): DebugElement[] {\n    const matches: DebugElement[] = [];\n    _queryNodeChildrenR3(this, predicate, matches, true);\n    return matches;\n  }\n\n  queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[] {\n    const matches: DebugNode[] = [];\n    _queryNodeChildrenR3(this, predicate, matches, false);\n    return matches;\n  }\n\n  triggerEventHandler(eventName: string, eventObj: any): void {\n    this.listeners.forEach((listener) => {\n      if (listener.name === eventName) {\n        listener.callback(eventObj);\n      }\n    });\n  }\n}\n\nfunction _queryNodeChildrenR3(\n    parentNode: DebugNode, predicate: Predicate<DebugNode>, matches: DebugNode[],\n    elementsOnly: boolean) {\n  if (parentNode instanceof DebugElement__POST_R3__) {\n    parentNode.childNodes.forEach(node => {\n      if (predicate(node)) {\n        matches.push(node);\n      }\n      if (node instanceof DebugElement__POST_R3__) {\n        if (elementsOnly ? node.nativeElement : true) {\n          _queryNodeChildrenR3(node, predicate, matches, elementsOnly);\n        }\n      }\n    });\n  }\n}\n\n\n// Need to keep the nodes in a global Map so that multiple angular apps are supported.\nconst _nativeNodeToDebugNode = new Map<any, DebugNode>();\n\nfunction getDebugNode__PRE_R3__(nativeNode: any): DebugNode|null {\n  return _nativeNodeToDebugNode.get(nativeNode) || null;\n}\n\nexport function getDebugNode__POST_R3__(nativeNode: Element): DebugElement__POST_R3__;\nexport function getDebugNode__POST_R3__(nativeNode: Node): DebugNode__POST_R3__;\nexport function getDebugNode__POST_R3__(nativeNode: null): null;\nexport function getDebugNode__POST_R3__(nativeNode: any): DebugNode|null {\n  if (nativeNode instanceof Node) {\n    return nativeNode.nodeType == Node.ELEMENT_NODE ?\n        new DebugElement__POST_R3__(nativeNode as Element) :\n        new DebugNode__POST_R3__(nativeNode);\n  }\n  return null;\n}\n\n/**\n * @publicApi\n */\nexport const getDebugNode: (nativeNode: any) => DebugNode | null = getDebugNode__PRE_R3__;\n\nexport function getAllDebugNodes(): DebugNode[] {\n  return Array.from(_nativeNodeToDebugNode.values());\n}\n\nexport function indexDebugNode(node: DebugNode) {\n  _nativeNodeToDebugNode.set(node.nativeNode, node);\n}\n\nexport function removeDebugNodeFromIndex(node: DebugNode) {\n  _nativeNodeToDebugNode.delete(node.nativeNode);\n}\n\n/**\n * A boolean-valued function over a value, possibly including context information\n * regarding that value's position in an array.\n *\n * @publicApi\n */\nexport interface Predicate<T> { (value: T): boolean; }\n\n/**\n * @publicApi\n */\nexport const DebugNode: {new (...args: any[]): DebugNode} = DebugNode__PRE_R3__ as any;\n\n/**\n * @publicApi\n */\nexport const DebugElement: {new (...args: any[]): DebugElement} = DebugElement__PRE_R3__ as any;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {looseIdentical, stringify} from '../../util';\nimport {isListLikeIterable, iterateListLike} from '../change_detection_util';\nimport {IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction} from './iterable_differs';\n\n\nexport class DefaultIterableDifferFactory implements IterableDifferFactory {\n  constructor() {}\n  supports(obj: Object|null|undefined): boolean { return isListLikeIterable(obj); }\n\n  create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V> {\n    return new DefaultIterableDiffer<V>(trackByFn);\n  }\n}\n\nconst trackByIdentity = (index: number, item: any) => item;\n\n/**\n * @deprecated v4.0.0 - Should not be part of public API.\n * @publicApi\n */\nexport class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\n  public readonly length: number = 0;\n  // TODO(issue/24571): remove '!'.\n  public readonly collection !: V[] | Iterable<V>| null;\n  // Keeps track of the used records at any point in time (during & across `_check()` calls)\n  private _linkedRecords: _DuplicateMap<V>|null = null;\n  // Keeps track of the removed records at any point in time during `_check()` calls.\n  private _unlinkedRecords: _DuplicateMap<V>|null = null;\n  private _previousItHead: IterableChangeRecord_<V>|null = null;\n  private _itHead: IterableChangeRecord_<V>|null = null;\n  private _itTail: IterableChangeRecord_<V>|null = null;\n  private _additionsHead: IterableChangeRecord_<V>|null = null;\n  private _additionsTail: IterableChangeRecord_<V>|null = null;\n  private _movesHead: IterableChangeRecord_<V>|null = null;\n  private _movesTail: IterableChangeRecord_<V>|null = null;\n  private _removalsHead: IterableChangeRecord_<V>|null = null;\n  private _removalsTail: IterableChangeRecord_<V>|null = null;\n  // Keeps track of records where custom track by is the same, but item identity has changed\n  private _identityChangesHead: IterableChangeRecord_<V>|null = null;\n  private _identityChangesTail: IterableChangeRecord_<V>|null = null;\n  private _trackByFn: TrackByFunction<V>;\n\n  constructor(trackByFn?: TrackByFunction<V>) { this._trackByFn = trackByFn || trackByIdentity; }\n\n  forEachItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._itHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachOperation(\n      fn: (item: IterableChangeRecord<V>, previousIndex: number|null, currentIndex: number|null) =>\n          void) {\n    let nextIt = this._itHead;\n    let nextRemove = this._removalsHead;\n    let addRemoveOffset = 0;\n    let moveOffsets: number[]|null = null;\n    while (nextIt || nextRemove) {\n      // Figure out which is the next record to process\n      // Order: remove, add, move\n      const record: IterableChangeRecord<V> = !nextRemove ||\n              nextIt &&\n                  nextIt.currentIndex ! <\n                      getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\n          nextIt ! :\n          nextRemove;\n      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n      const currentIndex = record.currentIndex;\n\n      // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n      if (record === nextRemove) {\n        addRemoveOffset--;\n        nextRemove = nextRemove._nextRemoved;\n      } else {\n        nextIt = nextIt !._next;\n        if (record.previousIndex == null) {\n          addRemoveOffset++;\n        } else {\n          // INVARIANT:  currentIndex < previousIndex\n          if (!moveOffsets) moveOffsets = [];\n          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n          const localCurrentIndex = currentIndex ! - addRemoveOffset;\n          if (localMovePreviousIndex != localCurrentIndex) {\n            for (let i = 0; i < localMovePreviousIndex; i++) {\n              const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n              const index = offset + i;\n              if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                moveOffsets[i] = offset + 1;\n              }\n            }\n            const previousIndex = record.previousIndex;\n            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n          }\n        }\n      }\n\n      if (adjPreviousIndex !== currentIndex) {\n        fn(record, adjPreviousIndex, currentIndex);\n      }\n    }\n  }\n\n  forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._movesHead; record !== null; record = record._nextMoved) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n      fn(record);\n    }\n  }\n\n  diff(collection: NgIterable<V>): DefaultIterableDiffer<V>|null {\n    if (collection == null) collection = [];\n    if (!isListLikeIterable(collection)) {\n      throw new Error(\n          `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);\n    }\n\n    if (this.check(collection)) {\n      return this;\n    } else {\n      return null;\n    }\n  }\n\n  onDestroy() {}\n\n  check(collection: NgIterable<V>): boolean {\n    this._reset();\n\n    let record: IterableChangeRecord_<V>|null = this._itHead;\n    let mayBeDirty: boolean = false;\n    let index: number;\n    let item: V;\n    let itemTrackBy: any;\n    if (Array.isArray(collection)) {\n      (this as{length: number}).length = collection.length;\n\n      for (let index = 0; index < this.length; index++) {\n        item = collection[index];\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            // TODO(misko): can we limit this to duplicates only?\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);\n        }\n\n        record = record._next;\n      }\n    } else {\n      index = 0;\n      iterateListLike(collection, (item: V) => {\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            // TODO(misko): can we limit this to duplicates only?\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);\n        }\n        record = record._next;\n        index++;\n      });\n      (this as{length: number}).length = index;\n    }\n\n    this._truncate(record);\n    (this as{collection: V[] | Iterable<V>}).collection = collection;\n    return this.isDirty;\n  }\n\n  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n   * changes.\n   */\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._movesHead !== null ||\n        this._removalsHead !== null || this._identityChangesHead !== null;\n  }\n\n  /**\n   * Reset the state of the change objects to show no changes. This means set previousKey to\n   * currentKey, and clear all of the queues (additions, moves, removals).\n   * Set the previousIndexes of moved and added items to their currentIndexes\n   * Reset the list of additions, moves and removals\n   *\n   * @internal\n   */\n  _reset() {\n    if (this.isDirty) {\n      let record: IterableChangeRecord_<V>|null;\n      let nextRecord: IterableChangeRecord_<V>|null;\n\n      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._additionsHead = this._additionsTail = null;\n\n      for (record = this._movesHead; record !== null; record = nextRecord) {\n        record.previousIndex = record.currentIndex;\n        nextRecord = record._nextMoved;\n      }\n      this._movesHead = this._movesTail = null;\n      this._removalsHead = this._removalsTail = null;\n      this._identityChangesHead = this._identityChangesTail = null;\n\n      // TODO(vicb): when assert gets supported\n      // assert(!this.isDirty);\n    }\n  }\n\n  /**\n   * This is the core function which handles differences between collections.\n   *\n   * - `record` is the record which we saw at this position last time. If null then it is a new\n   *   item.\n   * - `item` is the current item in the collection\n   * - `index` is the position of the item in the collection\n   *\n   * @internal\n   */\n  _mismatch(record: IterableChangeRecord_<V>|null, item: V, itemTrackBy: any, index: number):\n      IterableChangeRecord_<V> {\n    // The previous record after which we will append the current one.\n    let previousRecord: IterableChangeRecord_<V>|null;\n\n    if (record === null) {\n      previousRecord = this._itTail;\n    } else {\n      previousRecord = record._prev;\n      // Remove the record from the collection since we know it does not match the item.\n      this._remove(record);\n    }\n\n    // Attempt to see if we have seen the item before.\n    record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n    if (record !== null) {\n      // We have seen this before, we need to move it forward in the collection.\n      // But first we need to check if identity changed, so we can update in view if necessary\n      if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);\n\n      this._moveAfter(record, previousRecord, index);\n    } else {\n      // Never seen it, check evicted list.\n      record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n      if (record !== null) {\n        // It is an item which we have evicted earlier: reinsert it back into the list.\n        // But first we need to check if identity changed, so we can update in view if necessary\n        if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);\n\n        this._reinsertAfter(record, previousRecord, index);\n      } else {\n        // It is a new item: add it.\n        record =\n            this._addAfter(new IterableChangeRecord_<V>(item, itemTrackBy), previousRecord, index);\n      }\n    }\n    return record;\n  }\n\n  /**\n   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n   *\n   * Use case: `[a, a]` => `[b, a, a]`\n   *\n   * If we did not have this check then the insertion of `b` would:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) leave `a` at index `1` as is. <-- this is wrong!\n   *   3) reinsert `a` at index 2. <-- this is wrong!\n   *\n   * The correct behavior is:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) reinsert `a` at index 1.\n   *   3) move `a` at from `1` to `2`.\n   *\n   *\n   * Double check that we have not evicted a duplicate item. We need to check if the item type may\n   * have already been removed:\n   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n   * at the end.\n   *\n   * @internal\n   */\n  _verifyReinsertion(record: IterableChangeRecord_<V>, item: V, itemTrackBy: any, index: number):\n      IterableChangeRecord_<V> {\n    let reinsertRecord: IterableChangeRecord_<V>|null =\n        this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (reinsertRecord !== null) {\n      record = this._reinsertAfter(reinsertRecord, record._prev !, index);\n    } else if (record.currentIndex != index) {\n      record.currentIndex = index;\n      this._addToMoves(record, index);\n    }\n    return record;\n  }\n\n  /**\n   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\n   *\n   * - `record` The first excess {@link IterableChangeRecord_}.\n   *\n   * @internal\n   */\n  _truncate(record: IterableChangeRecord_<V>|null) {\n    // Anything after that needs to be removed;\n    while (record !== null) {\n      const nextRecord: IterableChangeRecord_<V>|null = record._next;\n      this._addToRemovals(this._unlink(record));\n      record = nextRecord;\n    }\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.clear();\n    }\n\n    if (this._additionsTail !== null) {\n      this._additionsTail._nextAdded = null;\n    }\n    if (this._movesTail !== null) {\n      this._movesTail._nextMoved = null;\n    }\n    if (this._itTail !== null) {\n      this._itTail._next = null;\n    }\n    if (this._removalsTail !== null) {\n      this._removalsTail._nextRemoved = null;\n    }\n    if (this._identityChangesTail !== null) {\n      this._identityChangesTail._nextIdentityChange = null;\n    }\n  }\n\n  /** @internal */\n  _reinsertAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.remove(record);\n    }\n    const prev = record._prevRemoved;\n    const next = record._nextRemoved;\n\n    if (prev === null) {\n      this._removalsHead = next;\n    } else {\n      prev._nextRemoved = next;\n    }\n    if (next === null) {\n      this._removalsTail = prev;\n    } else {\n      next._prevRemoved = prev;\n    }\n\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _moveAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    this._unlink(record);\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _addAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    this._insertAfter(record, prevRecord, index);\n\n    if (this._additionsTail === null) {\n      // TODO(vicb):\n      // assert(this._additionsHead === null);\n      this._additionsTail = this._additionsHead = record;\n    } else {\n      // TODO(vicb):\n      // assert(_additionsTail._nextAdded === null);\n      // assert(record._nextAdded === null);\n      this._additionsTail = this._additionsTail._nextAdded = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _insertAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    // TODO(vicb):\n    // assert(record != prevRecord);\n    // assert(record._next === null);\n    // assert(record._prev === null);\n\n    const next: IterableChangeRecord_<V>|null =\n        prevRecord === null ? this._itHead : prevRecord._next;\n    // TODO(vicb):\n    // assert(next != record);\n    // assert(prevRecord != record);\n    record._next = next;\n    record._prev = prevRecord;\n    if (next === null) {\n      this._itTail = record;\n    } else {\n      next._prev = record;\n    }\n    if (prevRecord === null) {\n      this._itHead = record;\n    } else {\n      prevRecord._next = record;\n    }\n\n    if (this._linkedRecords === null) {\n      this._linkedRecords = new _DuplicateMap<V>();\n    }\n    this._linkedRecords.put(record);\n\n    record.currentIndex = index;\n    return record;\n  }\n\n  /** @internal */\n  _remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    return this._addToRemovals(this._unlink(record));\n  }\n\n  /** @internal */\n  _unlink(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._linkedRecords !== null) {\n      this._linkedRecords.remove(record);\n    }\n\n    const prev = record._prev;\n    const next = record._next;\n\n    // TODO(vicb):\n    // assert((record._prev = null) === null);\n    // assert((record._next = null) === null);\n\n    if (prev === null) {\n      this._itHead = next;\n    } else {\n      prev._next = next;\n    }\n    if (next === null) {\n      this._itTail = prev;\n    } else {\n      next._prev = prev;\n    }\n\n    return record;\n  }\n\n  /** @internal */\n  _addToMoves(record: IterableChangeRecord_<V>, toIndex: number): IterableChangeRecord_<V> {\n    // TODO(vicb):\n    // assert(record._nextMoved === null);\n\n    if (record.previousIndex === toIndex) {\n      return record;\n    }\n\n    if (this._movesTail === null) {\n      // TODO(vicb):\n      // assert(_movesHead === null);\n      this._movesTail = this._movesHead = record;\n    } else {\n      // TODO(vicb):\n      // assert(_movesTail._nextMoved === null);\n      this._movesTail = this._movesTail._nextMoved = record;\n    }\n\n    return record;\n  }\n\n  private _addToRemovals(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords === null) {\n      this._unlinkedRecords = new _DuplicateMap<V>();\n    }\n    this._unlinkedRecords.put(record);\n    record.currentIndex = null;\n    record._nextRemoved = null;\n\n    if (this._removalsTail === null) {\n      // TODO(vicb):\n      // assert(_removalsHead === null);\n      this._removalsTail = this._removalsHead = record;\n      record._prevRemoved = null;\n    } else {\n      // TODO(vicb):\n      // assert(_removalsTail._nextRemoved === null);\n      // assert(record._nextRemoved === null);\n      record._prevRemoved = this._removalsTail;\n      this._removalsTail = this._removalsTail._nextRemoved = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _addIdentityChange(record: IterableChangeRecord_<V>, item: V) {\n    record.item = item;\n    if (this._identityChangesTail === null) {\n      this._identityChangesTail = this._identityChangesHead = record;\n    } else {\n      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n    }\n    return record;\n  }\n}\n\nexport class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\n  currentIndex: number|null = null;\n  previousIndex: number|null = null;\n\n  /** @internal */\n  _nextPrevious: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prev: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _next: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prevDup: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextDup: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prevRemoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextRemoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextAdded: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextMoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextIdentityChange: IterableChangeRecord_<V>|null = null;\n\n\n  constructor(public item: V, public trackById: any) {}\n}\n\n// A linked list of CollectionChangeRecords with the same IterableChangeRecord_.item\nclass _DuplicateItemRecordList<V> {\n  /** @internal */\n  _head: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _tail: IterableChangeRecord_<V>|null = null;\n\n  /**\n   * Append the record to the list of duplicates.\n   *\n   * Note: by design all records in the list of duplicates hold the same value in record.item.\n   */\n  add(record: IterableChangeRecord_<V>): void {\n    if (this._head === null) {\n      this._head = this._tail = record;\n      record._nextDup = null;\n      record._prevDup = null;\n    } else {\n      // TODO(vicb):\n      // assert(record.item ==  _head.item ||\n      //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\n      this._tail !._nextDup = record;\n      record._prevDup = this._tail;\n      record._nextDup = null;\n      this._tail = record;\n    }\n  }\n\n  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\n  // IterableChangeRecord_.currentIndex >= atOrAfterIndex\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<V>|null {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._head; record !== null; record = record._nextDup) {\n      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex !) &&\n          looseIdentical(record.trackById, trackById)) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove one {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * Returns whether the list of duplicates is empty.\n   */\n  remove(record: IterableChangeRecord_<V>): boolean {\n    // TODO(vicb):\n    // assert(() {\n    //  // verify that the record being removed is in the list.\n    //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {\n    //    if (identical(cursor, record)) return true;\n    //  }\n    //  return false;\n    //});\n\n    const prev: IterableChangeRecord_<V>|null = record._prevDup;\n    const next: IterableChangeRecord_<V>|null = record._nextDup;\n    if (prev === null) {\n      this._head = next;\n    } else {\n      prev._nextDup = next;\n    }\n    if (next === null) {\n      this._tail = prev;\n    } else {\n      next._prevDup = prev;\n    }\n    return this._head === null;\n  }\n}\n\nclass _DuplicateMap<V> {\n  map = new Map<any, _DuplicateItemRecordList<V>>();\n\n  put(record: IterableChangeRecord_<V>) {\n    const key = record.trackById;\n\n    let duplicates = this.map.get(key);\n    if (!duplicates) {\n      duplicates = new _DuplicateItemRecordList<V>();\n      this.map.set(key, duplicates);\n    }\n    duplicates.add(record);\n  }\n\n  /**\n   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\n   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\n   *\n   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n   * have any more `a`s needs to return the second `a`.\n   */\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<V>|null {\n    const key = trackById;\n    const recordList = this.map.get(key);\n    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\n  }\n\n  /**\n   * Removes a {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * The list of duplicates also is removed from the map if it gets empty.\n   */\n  remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    const key = record.trackById;\n    const recordList: _DuplicateItemRecordList<V> = this.map.get(key) !;\n    // Remove the list of duplicates when it gets empty\n    if (recordList.remove(record)) {\n      this.map.delete(key);\n    }\n    return record;\n  }\n\n  get isEmpty(): boolean { return this.map.size === 0; }\n\n  clear() { this.map.clear(); }\n}\n\nfunction getPreviousIndex(\n    item: any, addRemoveOffset: number, moveOffsets: number[] | null): number {\n  const previousIndex = item.previousIndex;\n  if (previousIndex === null) return previousIndex;\n  let moveOffset = 0;\n  if (moveOffsets && previousIndex < moveOffsets.length) {\n    moveOffset = moveOffsets[previousIndex];\n  }\n  return previousIndex + addRemoveOffset + moveOffset;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {looseIdentical, stringify} from '../../util';\nimport {isJsObject} from '../change_detection_util';\nimport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory} from './keyvalue_differs';\n\n\nexport class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\n  constructor() {}\n  supports(obj: any): boolean { return obj instanceof Map || isJsObject(obj); }\n\n  create<K, V>(): KeyValueDiffer<K, V> { return new DefaultKeyValueDiffer<K, V>(); }\n}\n\nexport class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\n  private _records = new Map<K, KeyValueChangeRecord_<K, V>>();\n  private _mapHead: KeyValueChangeRecord_<K, V>|null = null;\n  // _appendAfter is used in the check loop\n  private _appendAfter: KeyValueChangeRecord_<K, V>|null = null;\n  private _previousMapHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsTail: KeyValueChangeRecord_<K, V>|null = null;\n\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._changesHead !== null ||\n        this._removalsHead !== null;\n  }\n\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._mapHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._changesHead; record !== null; record = record._nextChanged) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  diff(map?: Map<any, any>|{[k: string]: any}|null): any {\n    if (!map) {\n      map = new Map();\n    } else if (!(map instanceof Map || isJsObject(map))) {\n      throw new Error(\n          `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);\n    }\n\n    return this.check(map) ? this : null;\n  }\n\n  onDestroy() {}\n\n  /**\n   * Check the current state of the map vs the previous.\n   * The algorithm is optimised for when the keys do no change.\n   */\n  check(map: Map<any, any>|{[k: string]: any}): boolean {\n    this._reset();\n\n    let insertBefore = this._mapHead;\n    this._appendAfter = null;\n\n    this._forEach(map, (value: any, key: any) => {\n      if (insertBefore && insertBefore.key === key) {\n        this._maybeAddToChanges(insertBefore, value);\n        this._appendAfter = insertBefore;\n        insertBefore = insertBefore._next;\n      } else {\n        const record = this._getOrCreateRecordForKey(key, value);\n        insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n      }\n    });\n\n    // Items remaining at the end of the list have been deleted\n    if (insertBefore) {\n      if (insertBefore._prev) {\n        insertBefore._prev._next = null;\n      }\n\n      this._removalsHead = insertBefore;\n\n      for (let record: KeyValueChangeRecord_<K, V>|null = insertBefore; record !== null;\n           record = record._nextRemoved) {\n        if (record === this._mapHead) {\n          this._mapHead = null;\n        }\n        this._records.delete(record.key);\n        record._nextRemoved = record._next;\n        record.previousValue = record.currentValue;\n        record.currentValue = null;\n        record._prev = null;\n        record._next = null;\n      }\n    }\n\n    // Make sure tails have no next records from previous runs\n    if (this._changesTail) this._changesTail._nextChanged = null;\n    if (this._additionsTail) this._additionsTail._nextAdded = null;\n\n    return this.isDirty;\n  }\n\n  /**\n   * Inserts a record before `before` or append at the end of the list when `before` is null.\n   *\n   * Notes:\n   * - This method appends at `this._appendAfter`,\n   * - This method updates `this._appendAfter`,\n   * - The return value is the new value for the insertion pointer.\n   */\n  private _insertBeforeOrAppend(\n      before: KeyValueChangeRecord_<K, V>|null,\n      record: KeyValueChangeRecord_<K, V>): KeyValueChangeRecord_<K, V>|null {\n    if (before) {\n      const prev = before._prev;\n      record._next = before;\n      record._prev = prev;\n      before._prev = record;\n      if (prev) {\n        prev._next = record;\n      }\n      if (before === this._mapHead) {\n        this._mapHead = record;\n      }\n\n      this._appendAfter = before;\n      return before;\n    }\n\n    if (this._appendAfter) {\n      this._appendAfter._next = record;\n      record._prev = this._appendAfter;\n    } else {\n      this._mapHead = record;\n    }\n\n    this._appendAfter = record;\n    return null;\n  }\n\n  private _getOrCreateRecordForKey(key: K, value: V): KeyValueChangeRecord_<K, V> {\n    if (this._records.has(key)) {\n      const record = this._records.get(key) !;\n      this._maybeAddToChanges(record, value);\n      const prev = record._prev;\n      const next = record._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      }\n      record._next = null;\n      record._prev = null;\n\n      return record;\n    }\n\n    const record = new KeyValueChangeRecord_<K, V>(key);\n    this._records.set(key, record);\n    record.currentValue = value;\n    this._addToAdditions(record);\n    return record;\n  }\n\n  /** @internal */\n  _reset() {\n    if (this.isDirty) {\n      let record: KeyValueChangeRecord_<K, V>|null;\n      // let `_previousMapHead` contain the state of the map before the changes\n      this._previousMapHead = this._mapHead;\n      for (record = this._previousMapHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      // Update `record.previousValue` with the value of the item before the changes\n      // We need to update all changed items (that's those which have been added and changed)\n      for (record = this._changesHead; record !== null; record = record._nextChanged) {\n        record.previousValue = record.currentValue;\n      }\n      for (record = this._additionsHead; record != null; record = record._nextAdded) {\n        record.previousValue = record.currentValue;\n      }\n\n      this._changesHead = this._changesTail = null;\n      this._additionsHead = this._additionsTail = null;\n      this._removalsHead = null;\n    }\n  }\n\n  // Add the record or a given key to the list of changes only when the value has actually changed\n  private _maybeAddToChanges(record: KeyValueChangeRecord_<K, V>, newValue: any): void {\n    if (!looseIdentical(newValue, record.currentValue)) {\n      record.previousValue = record.currentValue;\n      record.currentValue = newValue;\n      this._addToChanges(record);\n    }\n  }\n\n  private _addToAdditions(record: KeyValueChangeRecord_<K, V>) {\n    if (this._additionsHead === null) {\n      this._additionsHead = this._additionsTail = record;\n    } else {\n      this._additionsTail !._nextAdded = record;\n      this._additionsTail = record;\n    }\n  }\n\n  private _addToChanges(record: KeyValueChangeRecord_<K, V>) {\n    if (this._changesHead === null) {\n      this._changesHead = this._changesTail = record;\n    } else {\n      this._changesTail !._nextChanged = record;\n      this._changesTail = record;\n    }\n  }\n\n  /** @internal */\n  private _forEach<K, V>(obj: Map<K, V>|{[k: string]: V}, fn: (v: V, k: any) => void) {\n    if (obj instanceof Map) {\n      obj.forEach(fn);\n    } else {\n      Object.keys(obj).forEach(k => fn(obj[k], k));\n    }\n  }\n}\n\nclass KeyValueChangeRecord_<K, V> implements KeyValueChangeRecord<K, V> {\n  previousValue: V|null = null;\n  currentValue: V|null = null;\n\n  /** @internal */\n  _nextPrevious: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _next: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _prev: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextAdded: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextRemoved: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextChanged: KeyValueChangeRecord_<K, V>|null = null;\n\n  constructor(public key: K) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {defineInjectable} from '../../di/defs';\nimport {Optional, SkipSelf} from '../../di/metadata';\nimport {StaticProvider} from '../../di/provider';\nimport {DefaultIterableDifferFactory} from '../differs/default_iterable_differ';\n\n\n/**\n * A type describing supported iterable types.\n *\n * @publicApi\n */\nexport type NgIterable<T> = Array<T>| Iterable<T>;\n\n/**\n * A strategy for tracking changes over time to an iterable. Used by {@link NgForOf} to\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\n *\n * @publicApi\n */\nexport interface IterableDiffer<V> {\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: NgIterable<V>): IterableChanges<V>|null;\n}\n\n/**\n * An object describing the changes in the `Iterable` collection since last time\n * `IterableDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport interface IterableChanges<V> {\n  /**\n   * Iterate over all changes. `IterableChangeRecord` will contain information about changes\n   * to each item.\n   */\n  forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /**\n   * Iterate over a set of operations which when applied to the original `Iterable` will produce the\n   * new `Iterable`.\n   *\n   * NOTE: These are not necessarily the actual operations which were applied to the original\n   * `Iterable`, rather these are a set of computed operations which may not be the same as the\n   * ones applied.\n   *\n   * @param record A change which needs to be applied\n   * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the\n   *        original `Iterable` location, where as `previousIndex` refers to the transient location\n   *        of the item, after applying the operations up to this point.\n   * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the\n   *        original `Iterable` location, where as `currentIndex` refers to the transient location\n   *        of the item, after applying the operations up to this point.\n   */\n  forEachOperation(\n      fn:\n          (record: IterableChangeRecord<V>, previousIndex: number|null,\n           currentIndex: number|null) => void): void;\n\n  /**\n   * Iterate over changes in the order of original `Iterable` showing where the original items\n   * have moved.\n   */\n  forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all added items. */\n  forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all moved items. */\n  forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all removed items. */\n  forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all items which had their identity (as computed by the `TrackByFunction`)\n   * changed. */\n  forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;\n}\n\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport interface IterableChangeRecord<V> {\n  /** Current index of the item in `Iterable` or null if removed. */\n  readonly currentIndex: number|null;\n\n  /** Previous index of the item in `Iterable` or null if added. */\n  readonly previousIndex: number|null;\n\n  /** The item. */\n  readonly item: V;\n\n  /** Track by identity as computed by the `TrackByFunction`. */\n  readonly trackById: any;\n}\n\n/**\n * @deprecated v4.0.0 - Use IterableChangeRecord instead.\n * @publicApi\n */\nexport interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {}\n\n/**\n * An optional function passed into {@link NgForOf} that defines how to track\n * items in an iterable (e.g. fby index or id)\n *\n * @publicApi\n */\nexport interface TrackByFunction<T> { (index: number, item: T): any; }\n\n/**\n * Provides a factory for {@link IterableDiffer}.\n *\n * @publicApi\n */\nexport interface IterableDifferFactory {\n  supports(objects: any): boolean;\n  create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;\n}\n\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n *\n * @publicApi\n */\nexport class IterableDiffers {\n  /** @nocollapse */\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'root',\n    factory: () => new IterableDiffers([new DefaultIterableDifferFactory()])\n  });\n\n  /**\n   * @deprecated v4.0.0 - Should be private\n   */\n  factories: IterableDifferFactory[];\n  constructor(factories: IterableDifferFactory[]) { this.factories = factories; }\n\n  static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers {\n    if (parent != null) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n\n    return new IterableDiffers(factories);\n  }\n\n  /**\n   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n   * inherited {@link IterableDiffers} instance with the provided factories and return a new\n   * {@link IterableDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link IterableDiffer} available.\n   *\n   * ```\n   * @Component({\n   *   viewProviders: [\n   *     IterableDiffers.extend([new ImmutableListDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend(factories: IterableDifferFactory[]): StaticProvider {\n    return {\n      provide: IterableDiffers,\n      useFactory: (parent: IterableDiffers) => {\n        if (!parent) {\n          // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\n          // to\n          // bootstrap(), which would override default pipes instead of extending them.\n          throw new Error('Cannot extend IterableDiffers without a parent injector');\n        }\n        return IterableDiffers.create(factories, parent);\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n\n  find(iterable: any): IterableDifferFactory {\n    const factory = this.factories.find(f => f.supports(iterable));\n    if (factory != null) {\n      return factory;\n    } else {\n      throw new Error(\n          `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);\n    }\n  }\n}\n\nexport function getTypeNameForDebugging(type: any): string {\n  return type['name'] || typeof type;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Optional, SkipSelf, StaticProvider, defineInjectable} from '../../di';\nimport {DefaultKeyValueDifferFactory} from './default_keyvalue_differ';\n\n\n/**\n * A differ that tracks changes made to an object over time.\n *\n * @publicApi\n */\nexport interface KeyValueDiffer<K, V> {\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: Map<K, V>): KeyValueChanges<K, V>|null;\n\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: {[key: string]: V}): KeyValueChanges<string, V>|null;\n  // TODO(TS2.1): diff<KP extends string>(this: KeyValueDiffer<KP, V>, object: Record<KP, V>):\n  // KeyValueDiffer<KP, V>;\n}\n\n/**\n * An object describing the changes in the `Map` or `{[k:string]: string}` since last time\n * `KeyValueDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport interface KeyValueChanges<K, V> {\n  /**\n   * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes\n   * to each item.\n   */\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over changes in the order of original Map showing where the original items\n   * have moved.\n   */\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all keys for which values have changed.\n   */\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all added items.\n   */\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all removed items.\n   */\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n}\n\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport interface KeyValueChangeRecord<K, V> {\n  /**\n   * Current key in the Map.\n   */\n  readonly key: K;\n\n  /**\n   * Current value for the key or `null` if removed.\n   */\n  readonly currentValue: V|null;\n\n  /**\n   * Previous value for the key or `null` if added.\n   */\n  readonly previousValue: V|null;\n}\n\n/**\n * Provides a factory for {@link KeyValueDiffer}.\n *\n * @publicApi\n */\nexport interface KeyValueDifferFactory {\n  /**\n   * Test to see if the differ knows how to diff this kind of object.\n   */\n  supports(objects: any): boolean;\n\n  /**\n   * Create a `KeyValueDiffer`.\n   */\n  create<K, V>(): KeyValueDiffer<K, V>;\n}\n\n/**\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n *\n * @publicApi\n */\nexport class KeyValueDiffers {\n  /** @nocollapse */\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'root',\n    factory: () => new KeyValueDiffers([new DefaultKeyValueDifferFactory()])\n  });\n\n  /**\n   * @deprecated v4.0.0 - Should be private.\n   */\n  factories: KeyValueDifferFactory[];\n\n  constructor(factories: KeyValueDifferFactory[]) { this.factories = factories; }\n\n  static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers {\n    if (parent) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n    return new KeyValueDiffers(factories);\n  }\n\n  /**\n   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n   * {@link KeyValueDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link KeyValueDiffer} available.\n   *\n   * ```\n   * @Component({\n   *   viewProviders: [\n   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider {\n    return {\n      provide: KeyValueDiffers,\n      useFactory: (parent: KeyValueDiffers) => {\n        if (!parent) {\n          // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\n          // to bootstrap(), which would override default pipes instead of extending them.\n          throw new Error('Cannot extend KeyValueDiffers without a parent injector');\n        }\n        return KeyValueDiffers.create(factories, parent);\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n\n  find(kv: any): KeyValueDifferFactory {\n    const factory = this.factories.find(f => f.supports(kv));\n    if (factory) {\n      return factory;\n    }\n    throw new Error(`Cannot find a differ supporting object '${kv}'`);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DefaultIterableDifferFactory} from './differs/default_iterable_differ';\nimport {DefaultKeyValueDifferFactory} from './differs/default_keyvalue_differ';\nimport {IterableDifferFactory, IterableDiffers} from './differs/iterable_differs';\nimport {KeyValueDifferFactory, KeyValueDiffers} from './differs/keyvalue_differs';\n\nexport {SimpleChanges} from '../metadata/lifecycle_hooks';\nexport {SimpleChange, WrappedValue, devModeEqual} from './change_detection_util';\nexport {ChangeDetectorRef} from './change_detector_ref';\nexport {ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy} from './constants';\nexport {DefaultIterableDifferFactory} from './differs/default_iterable_differ';\nexport {DefaultIterableDiffer} from './differs/default_iterable_differ';\nexport {DefaultKeyValueDifferFactory} from './differs/default_keyvalue_differ';\nexport {CollectionChangeRecord, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFunction} from './differs/iterable_differs';\nexport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers} from './differs/keyvalue_differs';\nexport {PipeTransform} from './pipe_transform';\n\n\n\n/**\n * Structural diffing for `Object`s and `Map`s.\n */\nconst keyValDiff: KeyValueDifferFactory[] = [new DefaultKeyValueDifferFactory()];\n\n/**\n * Structural diffing for `Iterable` types such as `Array`s.\n */\nconst iterableDiff: IterableDifferFactory[] = [new DefaultIterableDifferFactory()];\n\nexport const defaultIterableDiffers = new IterableDiffers(iterableDiff);\n\nexport const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PlatformRef, createPlatformFactory} from './application_ref';\nimport {PLATFORM_ID} from './application_tokens';\nimport {Console} from './console';\nimport {Injector, StaticProvider} from './di';\nimport {TestabilityRegistry} from './testability/testability';\n\nconst _CORE_PLATFORM_PROVIDERS: StaticProvider[] = [\n  // Set a default platform name for platforms that don't set it explicitly.\n  {provide: PLATFORM_ID, useValue: 'unknown'},\n  {provide: PlatformRef, deps: [Injector]},\n  {provide: TestabilityRegistry, deps: []},\n  {provide: Console, deps: []},\n];\n\n/**\n * This platform has to be included in any other platform\n *\n * @publicApi\n */\nexport const platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\n\n/**\n * Provide this token to set the locale of your application.\n * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\n * DecimalPipe and PercentPipe) and by ICU expressions.\n *\n * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { LOCALE_ID } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const LOCALE_ID = new InjectionToken<string>('LocaleId');\n\n/**\n * Use this token at bootstrap to provide the content of your translation file (`xtb`,\n * `xlf` or `xlf2`) when you want to translate your application in another language.\n *\n * See the [i18n guide](guide/i18n#merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * // content of your translation file\n * const translations = '....';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS, useValue: translations }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const TRANSLATIONS = new InjectionToken<string>('Translations');\n\n/**\n * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\n * `xlf` or `xlf2`.\n *\n * See the [i18n guide](guide/i18n#merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS_FORMAT } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const TRANSLATIONS_FORMAT = new InjectionToken<string>('TranslationsFormat');\n\n/**\n * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy\n * that the compiler should use in case of missing translations:\n * - Error: throw if you have missing translations.\n * - Warning (default): show a warning in the console and/or shell.\n * - Ignore: do nothing.\n *\n * See the [i18n guide](guide/i18n#missing-translation) for more information.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * import { MissingTranslationStrategy } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   missingTranslation: MissingTranslationStrategy.Error\n * });\n * ```\n *\n * @publicApi\n */\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_INITIALIZER, ApplicationInitStatus} from './application_init';\nimport {ApplicationRef} from './application_ref';\nimport {APP_ID_RANDOM_PROVIDER} from './application_tokens';\nimport {IterableDiffers, KeyValueDiffers, defaultIterableDiffers, defaultKeyValueDiffers} from './change_detection/change_detection';\nimport {Console} from './console';\nimport {InjectionToken, Injector, StaticProvider} from './di';\nimport {Inject, Optional, SkipSelf} from './di/metadata';\nimport {ErrorHandler} from './error_handler';\nimport {LOCALE_ID} from './i18n/tokens';\nimport {ComponentFactoryResolver} from './linker';\nimport {Compiler} from './linker/compiler';\nimport {NgModule} from './metadata';\nimport {NgZone} from './zone';\n\nexport function _iterableDiffersFactory() {\n  return defaultIterableDiffers;\n}\n\nexport function _keyValueDiffersFactory() {\n  return defaultKeyValueDiffers;\n}\n\nexport function _localeFactory(locale?: string): string {\n  return locale || 'en-US';\n}\n\n/**\n * A built-in [dependency injection token](guide/glossary#di-token)\n * that is used to configure the root injector for bootstrapping.\n */\nexport const APPLICATION_MODULE_PROVIDERS: StaticProvider[] = [\n  {\n    provide: ApplicationRef,\n    useClass: ApplicationRef,\n    deps:\n        [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]\n  },\n  {\n    provide: ApplicationInitStatus,\n    useClass: ApplicationInitStatus,\n    deps: [[new Optional(), APP_INITIALIZER]]\n  },\n  {provide: Compiler, useClass: Compiler, deps: []},\n  APP_ID_RANDOM_PROVIDER,\n  {provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: []},\n  {provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: []},\n  {\n    provide: LOCALE_ID,\n    useFactory: _localeFactory,\n    deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]\n  },\n];\n\n/**\n * Configures the root injector for an app with\n * providers of `@angular/core` dependencies that `ApplicationRef` needs\n * to bootstrap components.\n *\n * Re-exported by `BrowserModule`, which is included automatically in the root\n * `AppModule` when you create a new app with the CLI `new` command.\n *\n * @publicApi\n */\n@NgModule({providers: APPLICATION_MODULE_PROVIDERS})\nexport class ApplicationModule {\n  // Inject ApplicationRef to make it eager...\n  constructor(appRef: ApplicationRef) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di';\nimport {ErrorHandler} from '../error_handler';\nimport {ComponentFactory} from '../linker/component_factory';\nimport {NgModuleRef} from '../linker/ng_module_factory';\nimport {QueryList} from '../linker/query_list';\nimport {TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef} from '../linker/view_container_ref';\nimport {Renderer2, RendererFactory2, RendererType2} from '../render/api';\nimport {Sanitizer, SecurityContext} from '../sanitization/security';\nimport {Type} from '../type';\n\n\n// -------------------------------------\n// Defs\n// -------------------------------------\n\n/**\n * Factory for ViewDefinitions/NgModuleDefinitions.\n * We use a function so we can reexeute it in case an error happens and use the given logger\n * function to log the error from the definition of the node, which is shown in all browser\n * logs.\n */\nexport interface DefinitionFactory<D extends Definition<any>> { (logger: NodeLogger): D; }\n\n/**\n * Function to call console.error at the right source location. This is an indirection\n * via another function as browser will log the location that actually called\n * `console.error`.\n */\nexport interface NodeLogger { (): () => void; }\n\nexport interface Definition<DF extends DefinitionFactory<any>> { factory: DF|null; }\n\nexport interface NgModuleDefinition extends Definition<NgModuleDefinitionFactory> {\n  providers: NgModuleProviderDef[];\n  providersByKey: {[tokenKey: string]: NgModuleProviderDef};\n  modules: any[];\n  isRoot: boolean;\n}\n\nexport interface NgModuleDefinitionFactory extends DefinitionFactory<NgModuleDefinition> {}\n\nexport interface ViewDefinition extends Definition<ViewDefinitionFactory> {\n  flags: ViewFlags;\n  updateDirectives: ViewUpdateFn;\n  updateRenderer: ViewUpdateFn;\n  handleEvent: ViewHandleEventFn;\n  /**\n   * Order: Depth first.\n   * Especially providers are before elements / anchors.\n   */\n  nodes: NodeDef[];\n  /** aggregated NodeFlags for all nodes **/\n  nodeFlags: NodeFlags;\n  rootNodeFlags: NodeFlags;\n  lastRenderRootNode: NodeDef|null;\n  bindingCount: number;\n  outputCount: number;\n  /**\n   * Binary or of all query ids that are matched by one of the nodes.\n   * This includes query ids from templates as well.\n   * Used as a bloom filter.\n   */\n  nodeMatchedQueries: number;\n}\n\nexport interface ViewDefinitionFactory extends DefinitionFactory<ViewDefinition> {}\n\n\nexport interface ViewUpdateFn { (check: NodeCheckFn, view: ViewData): void; }\n\n// helper functions to create an overloaded function type.\nexport interface NodeCheckFn {\n  (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Dynamic, values: any[]): any;\n\n  (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Inline, v0?: any, v1?: any, v2?: any,\n   v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;\n}\n\nexport const enum ArgumentType {Inline = 0, Dynamic = 1}\n\nexport interface ViewHandleEventFn {\n  (view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;\n}\n\n/**\n * Bitmask for ViewDefinition.flags.\n */\nexport const enum ViewFlags {\n  None = 0,\n  OnPush = 1 << 1,\n}\n\n/**\n * A node definition in the view.\n *\n * Note: We use one type for all nodes so that loops that loop over all nodes\n * of a ViewDefinition stay monomorphic!\n */\nexport interface NodeDef {\n  flags: NodeFlags;\n  // Index of the node in view data and view definition (those are the same)\n  nodeIndex: number;\n  // Index of the node in the check functions\n  // Differ from nodeIndex when nodes are added or removed at runtime (ie after compilation)\n  checkIndex: number;\n  parent: NodeDef|null;\n  renderParent: NodeDef|null;\n  /** this is checked against NgContentDef.index to find matched nodes */\n  ngContentIndex: number|null;\n  /** number of transitive children */\n  childCount: number;\n  /** aggregated NodeFlags for all transitive children (does not include self) **/\n  childFlags: NodeFlags;\n  /** aggregated NodeFlags for all direct children (does not include self) **/\n  directChildFlags: NodeFlags;\n\n  bindingIndex: number;\n  bindings: BindingDef[];\n  bindingFlags: BindingFlags;\n  outputIndex: number;\n  outputs: OutputDef[];\n  /**\n   * references that the user placed on the element\n   */\n  references: {[refId: string]: QueryValueType};\n  /**\n   * ids and value types of all queries that are matched by this node.\n   */\n  matchedQueries: {[queryId: number]: QueryValueType};\n  /** Binary or of all matched query ids of this node. */\n  matchedQueryIds: number;\n  /**\n   * Binary or of all query ids that are matched by one of the children.\n   * This includes query ids from templates as well.\n   * Used as a bloom filter.\n   */\n  childMatchedQueries: number;\n  element: ElementDef|null;\n  provider: ProviderDef|null;\n  text: TextDef|null;\n  query: QueryDef|null;\n  ngContent: NgContentDef|null;\n}\n\n/**\n * Bitmask for NodeDef.flags.\n * Naming convention:\n * - `Type...`: flags that are mutually exclusive\n * - `Cat...`: union of multiple `Type...` (short for category).\n */\nexport const enum NodeFlags {\n  None = 0,\n  TypeElement = 1 << 0,\n  TypeText = 1 << 1,\n  ProjectedTemplate = 1 << 2,\n  CatRenderNode = TypeElement | TypeText,\n  TypeNgContent = 1 << 3,\n  TypePipe = 1 << 4,\n  TypePureArray = 1 << 5,\n  TypePureObject = 1 << 6,\n  TypePurePipe = 1 << 7,\n  CatPureExpression = TypePureArray | TypePureObject | TypePurePipe,\n  TypeValueProvider = 1 << 8,\n  TypeClassProvider = 1 << 9,\n  TypeFactoryProvider = 1 << 10,\n  TypeUseExistingProvider = 1 << 11,\n  LazyProvider = 1 << 12,\n  PrivateProvider = 1 << 13,\n  TypeDirective = 1 << 14,\n  Component = 1 << 15,\n  CatProviderNoDirective =\n      TypeValueProvider | TypeClassProvider | TypeFactoryProvider | TypeUseExistingProvider,\n  CatProvider = CatProviderNoDirective | TypeDirective,\n  OnInit = 1 << 16,\n  OnDestroy = 1 << 17,\n  DoCheck = 1 << 18,\n  OnChanges = 1 << 19,\n  AfterContentInit = 1 << 20,\n  AfterContentChecked = 1 << 21,\n  AfterViewInit = 1 << 22,\n  AfterViewChecked = 1 << 23,\n  EmbeddedViews = 1 << 24,\n  ComponentView = 1 << 25,\n  TypeContentQuery = 1 << 26,\n  TypeViewQuery = 1 << 27,\n  StaticQuery = 1 << 28,\n  DynamicQuery = 1 << 29,\n  TypeNgModule = 1 << 30,\n  CatQuery = TypeContentQuery | TypeViewQuery,\n\n  // mutually exclusive values...\n  Types = CatRenderNode | TypeNgContent | TypePipe | CatPureExpression | CatProvider | CatQuery\n}\n\nexport interface BindingDef {\n  flags: BindingFlags;\n  ns: string|null;\n  name: string|null;\n  nonMinifiedName: string|null;\n  securityContext: SecurityContext|null;\n  suffix: string|null;\n}\n\nexport const enum BindingFlags {\n  TypeElementAttribute = 1 << 0,\n  TypeElementClass = 1 << 1,\n  TypeElementStyle = 1 << 2,\n  TypeProperty = 1 << 3,\n  SyntheticProperty = 1 << 4,\n  SyntheticHostProperty = 1 << 5,\n  CatSyntheticProperty = SyntheticProperty | SyntheticHostProperty,\n\n  // mutually exclusive values...\n  Types = TypeElementAttribute | TypeElementClass | TypeElementStyle | TypeProperty\n}\n\nexport interface OutputDef {\n  type: OutputType;\n  target: 'window'|'document'|'body'|'component'|null;\n  eventName: string;\n  propName: string|null;\n}\n\nexport const enum OutputType {ElementOutput, DirectiveOutput}\n\nexport const enum QueryValueType {\n  ElementRef = 0,\n  RenderElement = 1,\n  TemplateRef = 2,\n  ViewContainerRef = 3,\n  Provider = 4\n}\n\nexport interface ElementDef {\n  // set to null for `<ng-container>`\n  name: string|null;\n  ns: string|null;\n  /** ns, name, value */\n  attrs: [string, string, string][]|null;\n  template: ViewDefinition|null;\n  componentProvider: NodeDef|null;\n  componentRendererType: RendererType2|null;\n  // closure to allow recursive components\n  componentView: ViewDefinitionFactory|null;\n  /**\n   * visible public providers for DI in the view,\n   * as see from this element. This does not include private providers.\n   */\n  publicProviders: {[tokenKey: string]: NodeDef}|null;\n  /**\n   * same as visiblePublicProviders, but also includes private providers\n   * that are located on this element.\n   */\n  allProviders: {[tokenKey: string]: NodeDef}|null;\n  handleEvent: ElementHandleEventFn|null;\n}\n\nexport interface ElementHandleEventFn { (view: ViewData, eventName: string, event: any): boolean; }\n\nexport interface ProviderDef {\n  token: any;\n  value: any;\n  deps: DepDef[];\n}\n\nexport interface NgModuleProviderDef {\n  flags: NodeFlags;\n  index: number;\n  token: any;\n  value: any;\n  deps: DepDef[];\n}\n\nexport interface DepDef {\n  flags: DepFlags;\n  token: any;\n  tokenKey: string;\n}\n\n/**\n * Bitmask for DI flags\n */\nexport const enum DepFlags {\n  None = 0,\n  SkipSelf = 1 << 0,\n  Optional = 1 << 1,\n  Self = 1 << 2,\n  Value = 1 << 3,\n}\n\nexport interface TextDef { prefix: string; }\n\nexport interface QueryDef {\n  id: number;\n  // variant of the id that can be used to check against NodeDef.matchedQueryIds, ...\n  filterId: number;\n  bindings: QueryBindingDef[];\n}\n\nexport interface QueryBindingDef {\n  propName: string;\n  bindingType: QueryBindingType;\n}\n\nexport const enum QueryBindingType {First = 0, All = 1}\n\nexport interface NgContentDef {\n  /**\n   * this index is checked against NodeDef.ngContentIndex to find the nodes\n   * that are matched by this ng-content.\n   * Note that a NodeDef with an ng-content can be reprojected, i.e.\n   * have a ngContentIndex on its own.\n   */\n  index: number;\n}\n\n// -------------------------------------\n// Data\n// -------------------------------------\n\nexport interface NgModuleData extends Injector, NgModuleRef<any> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _def: NgModuleDefinition;\n  _parent: Injector;\n  _providers: any[];\n}\n\n/**\n * View instance data.\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface ViewData {\n  def: ViewDefinition;\n  root: RootData;\n  renderer: Renderer2;\n  // index of component provider / anchor.\n  parentNodeDef: NodeDef|null;\n  parent: ViewData|null;\n  viewContainerParent: ViewData|null;\n  component: any;\n  context: any;\n  // Attention: Never loop over this, as this will\n  // create a polymorphic usage site.\n  // Instead: Always loop over ViewDefinition.nodes,\n  // and call the right accessor (e.g. `elementData`) based on\n  // the NodeType.\n  nodes: {[key: number]: NodeData};\n  state: ViewState;\n  oldValues: any[];\n  disposables: DisposableFn[]|null;\n  initIndex: number;\n}\n\n/**\n * Bitmask of states\n */\nexport const enum ViewState {\n  BeforeFirstCheck = 1 << 0,\n  FirstCheck = 1 << 1,\n  Attached = 1 << 2,\n  ChecksEnabled = 1 << 3,\n  IsProjectedView = 1 << 4,\n  CheckProjectedView = 1 << 5,\n  CheckProjectedViews = 1 << 6,\n  Destroyed = 1 << 7,\n\n  // InitState Uses 3 bits\n  InitState_Mask = 7 << 8,\n  InitState_BeforeInit = 0 << 8,\n  InitState_CallingOnInit = 1 << 8,\n  InitState_CallingAfterContentInit = 2 << 8,\n  InitState_CallingAfterViewInit = 3 << 8,\n  InitState_AfterInit = 4 << 8,\n\n  CatDetectChanges = Attached | ChecksEnabled,\n  CatInit = BeforeFirstCheck | CatDetectChanges | InitState_BeforeInit\n}\n\n// Called before each cycle of a view's check to detect whether this is in the\n// initState for which we need to call ngOnInit, ngAfterContentInit or ngAfterViewInit\n// lifecycle methods. Returns true if this check cycle should call lifecycle\n// methods.\nexport function shiftInitState(\n    view: ViewData, priorInitState: ViewState, newInitState: ViewState): boolean {\n  // Only update the InitState if we are currently in the prior state.\n  // For example, only move into CallingInit if we are in BeforeInit. Only\n  // move into CallingContentInit if we are in CallingInit. Normally this will\n  // always be true because of how checkCycle is called in checkAndUpdateView.\n  // However, if checkAndUpdateView is called recursively or if an exception is\n  // thrown while checkAndUpdateView is running, checkAndUpdateView starts over\n  // from the beginning. This ensures the state is monotonically increasing,\n  // terminating in the AfterInit state, which ensures the Init methods are called\n  // at least once and only once.\n  const state = view.state;\n  const initState = state & ViewState.InitState_Mask;\n  if (initState === priorInitState) {\n    view.state = (state & ~ViewState.InitState_Mask) | newInitState;\n    view.initIndex = -1;\n    return true;\n  }\n  return initState === newInitState;\n}\n\n// Returns true if the lifecycle init method should be called for the node with\n// the given init index.\nexport function shouldCallLifecycleInitHook(\n    view: ViewData, initState: ViewState, index: number): boolean {\n  if ((view.state & ViewState.InitState_Mask) === initState && view.initIndex <= index) {\n    view.initIndex = index + 1;\n    return true;\n  }\n  return false;\n}\n\nexport interface DisposableFn { (): void; }\n\n/**\n * Node instance data.\n *\n * We have a separate type per NodeType to save memory\n * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)\n *\n * To keep our code monomorphic,\n * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).\n * This way, no usage site can get a `NodeData` from view.nodes and then use it for different\n * purposes.\n */\nexport class NodeData { private __brand: any; }\n\n/**\n * Data for an instantiated NodeType.Text.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface TextData { renderText: any; }\n\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport function asTextData(view: ViewData, index: number): TextData {\n  return <any>view.nodes[index];\n}\n\n/**\n * Data for an instantiated NodeType.Element.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface ElementData {\n  renderElement: any;\n  componentView: ViewData;\n  viewContainer: ViewContainerData|null;\n  template: TemplateData;\n}\n\nexport interface ViewContainerData extends ViewContainerRef {\n  // Note: we are using the prefix _ as ViewContainerData is a ViewContainerRef and therefore\n  // directly\n  // exposed to the user.\n  _embeddedViews: ViewData[];\n}\n\nexport interface TemplateData extends TemplateRef<any> {\n  // views that have been created from the template\n  // of this element,\n  // but inserted into the embeddedViews of another element.\n  // By default, this is undefined.\n  // Note: we are using the prefix _ as TemplateData is a TemplateRef and therefore directly\n  // exposed to the user.\n  _projectedViews: ViewData[];\n}\n\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport function asElementData(view: ViewData, index: number): ElementData {\n  return <any>view.nodes[index];\n}\n\n/**\n * Data for an instantiated NodeType.Provider.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface ProviderData { instance: any; }\n\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport function asProviderData(view: ViewData, index: number): ProviderData {\n  return <any>view.nodes[index];\n}\n\n/**\n * Data for an instantiated NodeType.PureExpression.\n *\n * Attention: Adding fields to this is performance sensitive!\n */\nexport interface PureExpressionData { value: any; }\n\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport function asPureExpressionData(view: ViewData, index: number): PureExpressionData {\n  return <any>view.nodes[index];\n}\n\n/**\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\n */\nexport function asQueryList(view: ViewData, index: number): QueryList<any> {\n  return <any>view.nodes[index];\n}\n\nexport interface RootData {\n  injector: Injector;\n  ngModule: NgModuleRef<any>;\n  projectableNodes: any[][];\n  selectorOrNode: any;\n  renderer: Renderer2;\n  rendererFactory: RendererFactory2;\n  errorHandler: ErrorHandler;\n  sanitizer: Sanitizer;\n}\n\nexport abstract class DebugContext {\n  abstract get view(): ViewData;\n  abstract get nodeIndex(): number|null;\n  abstract get injector(): Injector;\n  abstract get component(): any;\n  abstract get providerTokens(): any[];\n  abstract get references(): {[key: string]: any};\n  abstract get context(): any;\n  abstract get componentRenderElement(): any;\n  abstract get renderNode(): any;\n  abstract logError(console: Console, ...values: any[]): void;\n}\n\n// -------------------------------------\n// Other\n// -------------------------------------\n\nexport const enum CheckType {CheckAndUpdate, CheckNoChanges}\n\nexport interface ProviderOverride {\n  token: any;\n  flags: NodeFlags;\n  value: any;\n  deps: ([DepFlags, any]|any)[];\n  deprecatedBehavior: boolean;\n}\n\nexport interface Services {\n  setCurrentNode(view: ViewData, nodeIndex: number): void;\n  createRootView(\n      injector: Injector, projectableNodes: any[][], rootSelectorOrNode: string|any,\n      def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData;\n  createEmbeddedView(parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any):\n      ViewData;\n  createComponentView(\n      parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData;\n  createNgModuleRef(\n      moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[],\n      def: NgModuleDefinition): NgModuleRef<any>;\n  overrideProvider(override: ProviderOverride): void;\n  overrideComponentView(compType: Type<any>, compFactory: ComponentFactory<any>): void;\n  clearOverrides(): void;\n  checkAndUpdateView(view: ViewData): void;\n  checkNoChangesView(view: ViewData): void;\n  destroyView(view: ViewData): void;\n  resolveDep(\n      view: ViewData, elDef: NodeDef|null, allowPrivateServices: boolean, depDef: DepDef,\n      notFoundValue?: any): any;\n  createDebugContext(view: ViewData, nodeIndex: number): DebugContext;\n  handleEvent: ViewHandleEventFn;\n  updateDirectives: (view: ViewData, checkType: CheckType) => void;\n  updateRenderer: (view: ViewData, checkType: CheckType) => void;\n  dirtyParentQueries: (view: ViewData) => void;\n}\n\n/**\n * This object is used to prevent cycles in the source files and to have a place where\n * debug mode can hook it. It is lazily filled when `isDevMode` is known.\n */\nexport const Services: Services = {\n  setCurrentNode: undefined !,\n  createRootView: undefined !,\n  createEmbeddedView: undefined !,\n  createComponentView: undefined !,\n  createNgModuleRef: undefined !,\n  overrideProvider: undefined !,\n  overrideComponentView: undefined !,\n  clearOverrides: undefined !,\n  checkAndUpdateView: undefined !,\n  checkNoChangesView: undefined !,\n  destroyView: undefined !,\n  resolveDep: undefined !,\n  createDebugContext: undefined !,\n  handleEvent: undefined !,\n  updateDirectives: undefined !,\n  updateRenderer: undefined !,\n  dirtyParentQueries: undefined !,\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_DEBUG_CONTEXT, ERROR_LOGGER, getDebugContext} from '../errors';\nimport {DebugContext, ViewState} from './types';\n\nexport function expressionChangedAfterItHasBeenCheckedError(\n    context: DebugContext, oldValue: any, currValue: any, isFirstCheck: boolean): Error {\n  let msg =\n      `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${oldValue}'. Current value: '${currValue}'.`;\n  if (isFirstCheck) {\n    msg +=\n        ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n        ` Has it been created in a change detection hook ?`;\n  }\n  return viewDebugError(msg, context);\n}\n\nexport function viewWrappedDebugError(err: any, context: DebugContext): Error {\n  if (!(err instanceof Error)) {\n    // errors that are not Error instances don't have a stack,\n    // so it is ok to wrap them into a new Error object...\n    err = new Error(err.toString());\n  }\n  _addDebugContext(err, context);\n  return err;\n}\n\nexport function viewDebugError(msg: string, context: DebugContext): Error {\n  const err = new Error(msg);\n  _addDebugContext(err, context);\n  return err;\n}\n\nfunction _addDebugContext(err: Error, context: DebugContext) {\n  (err as any)[ERROR_DEBUG_CONTEXT] = context;\n  (err as any)[ERROR_LOGGER] = context.logError.bind(context);\n}\n\nexport function isViewDebugError(err: Error): boolean {\n  return !!getDebugContext(err);\n}\n\nexport function viewDestroyedError(action: string): Error {\n  return new Error(`ViewDestroyedError: Attempt to use a destroyed view: ${action}`);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WrappedValue, devModeEqual} from '../change_detection/change_detection';\nimport {SOURCE} from '../di/injector';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {RendererType2} from '../render/api';\nimport {looseIdentical, stringify} from '../util';\nimport {expressionChangedAfterItHasBeenCheckedError} from './errors';\nimport {BindingDef, BindingFlags, Definition, DefinitionFactory, DepDef, DepFlags, ElementData, NodeDef, NodeFlags, QueryValueType, Services, ViewData, ViewDefinition, ViewDefinitionFactory, ViewFlags, ViewState, asElementData, asTextData} from './types';\n\nexport const NOOP: any = () => {};\n\nconst _tokenKeyCache = new Map<any, string>();\n\nexport function tokenKey(token: any): string {\n  let key = _tokenKeyCache.get(token);\n  if (!key) {\n    key = stringify(token) + '_' + _tokenKeyCache.size;\n    _tokenKeyCache.set(token, key);\n  }\n  return key;\n}\n\nexport function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any {\n  if (WrappedValue.isWrapped(value)) {\n    value = WrappedValue.unwrap(value);\n    const globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;\n    const oldValue = WrappedValue.unwrap(view.oldValues[globalBindingIdx]);\n    view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);\n  }\n  return value;\n}\n\nconst UNDEFINED_RENDERER_TYPE_ID = '$$undefined';\nconst EMPTY_RENDERER_TYPE_ID = '$$empty';\n\n// Attention: this function is called as top level function.\n// Putting any logic in here will destroy closure tree shaking!\nexport function createRendererType2(values: {\n  styles: (string | any[])[],\n  encapsulation: ViewEncapsulation,\n  data: {[kind: string]: any[]}\n}): RendererType2 {\n  return {\n    id: UNDEFINED_RENDERER_TYPE_ID,\n    styles: values.styles,\n    encapsulation: values.encapsulation,\n    data: values.data\n  };\n}\n\nlet _renderCompCount = 0;\n\nexport function resolveRendererType2(type?: RendererType2 | null): RendererType2|null {\n  if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {\n    // first time we see this RendererType2. Initialize it...\n    const isFilled =\n        ((type.encapsulation != null && type.encapsulation !== ViewEncapsulation.None) ||\n         type.styles.length || Object.keys(type.data).length);\n    if (isFilled) {\n      type.id = `c${_renderCompCount++}`;\n    } else {\n      type.id = EMPTY_RENDERER_TYPE_ID;\n    }\n  }\n  if (type && type.id === EMPTY_RENDERER_TYPE_ID) {\n    type = null;\n  }\n  return type || null;\n}\n\nexport function checkBinding(\n    view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean {\n  const oldValues = view.oldValues;\n  if ((view.state & ViewState.FirstCheck) ||\n      !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function checkAndUpdateBinding(\n    view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean {\n  if (checkBinding(view, def, bindingIdx, value)) {\n    view.oldValues[def.bindingIndex + bindingIdx] = value;\n    return true;\n  }\n  return false;\n}\n\nexport function checkBindingNoChanges(\n    view: ViewData, def: NodeDef, bindingIdx: number, value: any) {\n  const oldValue = view.oldValues[def.bindingIndex + bindingIdx];\n  if ((view.state & ViewState.BeforeFirstCheck) || !devModeEqual(oldValue, value)) {\n    const bindingName = def.bindings[bindingIdx].name;\n    throw expressionChangedAfterItHasBeenCheckedError(\n        Services.createDebugContext(view, def.nodeIndex), `${bindingName}: ${oldValue}`,\n        `${bindingName}: ${value}`, (view.state & ViewState.BeforeFirstCheck) !== 0);\n  }\n}\n\nexport function markParentViewsForCheck(view: ViewData) {\n  let currView: ViewData|null = view;\n  while (currView) {\n    if (currView.def.flags & ViewFlags.OnPush) {\n      currView.state |= ViewState.ChecksEnabled;\n    }\n    currView = currView.viewContainerParent || currView.parent;\n  }\n}\n\nexport function markParentViewsForCheckProjectedViews(view: ViewData, endView: ViewData) {\n  let currView: ViewData|null = view;\n  while (currView && currView !== endView) {\n    currView.state |= ViewState.CheckProjectedViews;\n    currView = currView.viewContainerParent || currView.parent;\n  }\n}\n\nexport function dispatchEvent(\n    view: ViewData, nodeIndex: number, eventName: string, event: any): boolean|undefined {\n  try {\n    const nodeDef = view.def.nodes[nodeIndex];\n    const startView = nodeDef.flags & NodeFlags.ComponentView ?\n        asElementData(view, nodeIndex).componentView :\n        view;\n    markParentViewsForCheck(startView);\n    return Services.handleEvent(view, nodeIndex, eventName, event);\n  } catch (e) {\n    // Attention: Don't rethrow, as it would cancel Observable subscriptions!\n    view.root.errorHandler.handleError(e);\n  }\n}\n\nexport function declaredViewContainer(view: ViewData): ElementData|null {\n  if (view.parent) {\n    const parentView = view.parent;\n    return asElementData(parentView, view.parentNodeDef !.nodeIndex);\n  }\n  return null;\n}\n\n/**\n * for component views, this is the host element.\n * for embedded views, this is the index of the parent node\n * that contains the view container.\n */\nexport function viewParentEl(view: ViewData): NodeDef|null {\n  const parentView = view.parent;\n  if (parentView) {\n    return view.parentNodeDef !.parent;\n  } else {\n    return null;\n  }\n}\n\nexport function renderNode(view: ViewData, def: NodeDef): any {\n  switch (def.flags & NodeFlags.Types) {\n    case NodeFlags.TypeElement:\n      return asElementData(view, def.nodeIndex).renderElement;\n    case NodeFlags.TypeText:\n      return asTextData(view, def.nodeIndex).renderText;\n  }\n}\n\nexport function elementEventFullName(target: string | null, name: string): string {\n  return target ? `${target}:${name}` : name;\n}\n\nexport function isComponentView(view: ViewData): boolean {\n  return !!view.parent && !!(view.parentNodeDef !.flags & NodeFlags.Component);\n}\n\nexport function isEmbeddedView(view: ViewData): boolean {\n  return !!view.parent && !(view.parentNodeDef !.flags & NodeFlags.Component);\n}\n\nexport function filterQueryId(queryId: number): number {\n  return 1 << (queryId % 32);\n}\n\nexport function splitMatchedQueriesDsl(\n    matchedQueriesDsl: [string | number, QueryValueType][] | null): {\n  matchedQueries: {[queryId: string]: QueryValueType},\n  references: {[refId: string]: QueryValueType},\n  matchedQueryIds: number\n} {\n  const matchedQueries: {[queryId: string]: QueryValueType} = {};\n  let matchedQueryIds = 0;\n  const references: {[refId: string]: QueryValueType} = {};\n  if (matchedQueriesDsl) {\n    matchedQueriesDsl.forEach(([queryId, valueType]) => {\n      if (typeof queryId === 'number') {\n        matchedQueries[queryId] = valueType;\n        matchedQueryIds |= filterQueryId(queryId);\n      } else {\n        references[queryId] = valueType;\n      }\n    });\n  }\n  return {matchedQueries, references, matchedQueryIds};\n}\n\nexport function splitDepsDsl(deps: ([DepFlags, any] | any)[], sourceName?: string): DepDef[] {\n  return deps.map(value => {\n    let token: any;\n    let flags: DepFlags;\n    if (Array.isArray(value)) {\n      [flags, token] = value;\n    } else {\n      flags = DepFlags.None;\n      token = value;\n    }\n    if (token && (typeof token === 'function' || typeof token === 'object') && sourceName) {\n      Object.defineProperty(token, SOURCE, {value: sourceName, configurable: true});\n    }\n    return {flags, token, tokenKey: tokenKey(token)};\n  });\n}\n\nexport function getParentRenderElement(view: ViewData, renderHost: any, def: NodeDef): any {\n  let renderParent = def.renderParent;\n  if (renderParent) {\n    if ((renderParent.flags & NodeFlags.TypeElement) === 0 ||\n        (renderParent.flags & NodeFlags.ComponentView) === 0 ||\n        (renderParent.element !.componentRendererType &&\n         renderParent.element !.componentRendererType !.encapsulation ===\n             ViewEncapsulation.Native)) {\n      // only children of non components, or children of components with native encapsulation should\n      // be attached.\n      return asElementData(view, def.renderParent !.nodeIndex).renderElement;\n    }\n  } else {\n    return renderHost;\n  }\n}\n\nconst DEFINITION_CACHE = new WeakMap<any, Definition<any>>();\n\nexport function resolveDefinition<D extends Definition<any>>(factory: DefinitionFactory<D>): D {\n  let value = DEFINITION_CACHE.get(factory) !as D;\n  if (!value) {\n    value = factory(() => NOOP);\n    value.factory = factory;\n    DEFINITION_CACHE.set(factory, value);\n  }\n  return value;\n}\n\nexport function rootRenderNodes(view: ViewData): any[] {\n  const renderNodes: any[] = [];\n  visitRootRenderNodes(view, RenderNodeAction.Collect, undefined, undefined, renderNodes);\n  return renderNodes;\n}\n\nexport const enum RenderNodeAction {Collect, AppendChild, InsertBefore, RemoveChild}\n\nexport function visitRootRenderNodes(\n    view: ViewData, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]) {\n  // We need to re-compute the parent node in case the nodes have been moved around manually\n  if (action === RenderNodeAction.RemoveChild) {\n    parentNode = view.renderer.parentNode(renderNode(view, view.def.lastRenderRootNode !));\n  }\n  visitSiblingRenderNodes(\n      view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);\n}\n\nexport function visitSiblingRenderNodes(\n    view: ViewData, action: RenderNodeAction, startIndex: number, endIndex: number, parentNode: any,\n    nextSibling: any, target?: any[]) {\n  for (let i = startIndex; i <= endIndex; i++) {\n    const nodeDef = view.def.nodes[i];\n    if (nodeDef.flags & (NodeFlags.TypeElement | NodeFlags.TypeText | NodeFlags.TypeNgContent)) {\n      visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);\n    }\n    // jump to next sibling\n    i += nodeDef.childCount;\n  }\n}\n\nexport function visitProjectedRenderNodes(\n    view: ViewData, ngContentIndex: number, action: RenderNodeAction, parentNode: any,\n    nextSibling: any, target?: any[]) {\n  let compView: ViewData|null = view;\n  while (compView && !isComponentView(compView)) {\n    compView = compView.parent;\n  }\n  const hostView = compView !.parent;\n  const hostElDef = viewParentEl(compView !);\n  const startIndex = hostElDef !.nodeIndex + 1;\n  const endIndex = hostElDef !.nodeIndex + hostElDef !.childCount;\n  for (let i = startIndex; i <= endIndex; i++) {\n    const nodeDef = hostView !.def.nodes[i];\n    if (nodeDef.ngContentIndex === ngContentIndex) {\n      visitRenderNode(hostView !, nodeDef, action, parentNode, nextSibling, target);\n    }\n    // jump to next sibling\n    i += nodeDef.childCount;\n  }\n  if (!hostView !.parent) {\n    // a root view\n    const projectedNodes = view.root.projectableNodes[ngContentIndex];\n    if (projectedNodes) {\n      for (let i = 0; i < projectedNodes.length; i++) {\n        execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);\n      }\n    }\n  }\n}\n\nfunction visitRenderNode(\n    view: ViewData, nodeDef: NodeDef, action: RenderNodeAction, parentNode: any, nextSibling: any,\n    target?: any[]) {\n  if (nodeDef.flags & NodeFlags.TypeNgContent) {\n    visitProjectedRenderNodes(\n        view, nodeDef.ngContent !.index, action, parentNode, nextSibling, target);\n  } else {\n    const rn = renderNode(view, nodeDef);\n    if (action === RenderNodeAction.RemoveChild && (nodeDef.flags & NodeFlags.ComponentView) &&\n        (nodeDef.bindingFlags & BindingFlags.CatSyntheticProperty)) {\n      // Note: we might need to do both actions.\n      if (nodeDef.bindingFlags & (BindingFlags.SyntheticProperty)) {\n        execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);\n      }\n      if (nodeDef.bindingFlags & (BindingFlags.SyntheticHostProperty)) {\n        const compView = asElementData(view, nodeDef.nodeIndex).componentView;\n        execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);\n      }\n    } else {\n      execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);\n    }\n    if (nodeDef.flags & NodeFlags.EmbeddedViews) {\n      const embeddedViews = asElementData(view, nodeDef.nodeIndex).viewContainer !._embeddedViews;\n      for (let k = 0; k < embeddedViews.length; k++) {\n        visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);\n      }\n    }\n    if (nodeDef.flags & NodeFlags.TypeElement && !nodeDef.element !.name) {\n      visitSiblingRenderNodes(\n          view, action, nodeDef.nodeIndex + 1, nodeDef.nodeIndex + nodeDef.childCount, parentNode,\n          nextSibling, target);\n    }\n  }\n}\n\nfunction execRenderNodeAction(\n    view: ViewData, renderNode: any, action: RenderNodeAction, parentNode: any, nextSibling: any,\n    target?: any[]) {\n  const renderer = view.renderer;\n  switch (action) {\n    case RenderNodeAction.AppendChild:\n      renderer.appendChild(parentNode, renderNode);\n      break;\n    case RenderNodeAction.InsertBefore:\n      renderer.insertBefore(parentNode, renderNode, nextSibling);\n      break;\n    case RenderNodeAction.RemoveChild:\n      renderer.removeChild(parentNode, renderNode);\n      break;\n    case RenderNodeAction.Collect:\n      target !.push(renderNode);\n      break;\n  }\n}\n\nconst NS_PREFIX_RE = /^:([^:]+):(.+)$/;\n\nexport function splitNamespace(name: string): string[] {\n  if (name[0] === ':') {\n    const match = name.match(NS_PREFIX_RE) !;\n    return [match[1], match[2]];\n  }\n  return ['', name];\n}\n\nexport function calcBindingFlags(bindings: BindingDef[]): BindingFlags {\n  let flags = 0;\n  for (let i = 0; i < bindings.length; i++) {\n    flags |= bindings[i].flags;\n  }\n  return flags;\n}\n\nexport function interpolate(valueCount: number, constAndInterp: string[]): string {\n  let result = '';\n  for (let i = 0; i < valueCount * 2; i = i + 2) {\n    result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);\n  }\n  return result + constAndInterp[valueCount * 2];\n}\n\nexport function inlineInterpolate(\n    valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any,\n    c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any,\n    c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string {\n  switch (valueCount) {\n    case 1:\n      return c0 + _toStringWithNull(a1) + c1;\n    case 2:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;\n    case 3:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3;\n    case 4:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3 + _toStringWithNull(a4) + c4;\n    case 5:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;\n    case 6:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;\n    case 7:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n          c6 + _toStringWithNull(a7) + c7;\n    case 8:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n          c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;\n    case 9:\n      return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n          c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n          c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;\n    default:\n      throw new Error(`Does not support more than 9 expressions`);\n  }\n}\n\nfunction _toStringWithNull(v: any): string {\n  return v != null ? v.toString() : '';\n}\n\nexport const EMPTY_ARRAY: any[] = [];\nexport const EMPTY_MAP: {[key: string]: any} = {};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../metadata/view';\nimport {RendererType2} from '../render/api';\nimport {SecurityContext} from '../sanitization/security';\n\nimport {BindingDef, BindingFlags, ElementData, ElementHandleEventFn, NodeDef, NodeFlags, OutputDef, OutputType, QueryValueType, ViewData, ViewDefinitionFactory, asElementData} from './types';\nimport {NOOP, calcBindingFlags, checkAndUpdateBinding, dispatchEvent, elementEventFullName, getParentRenderElement, resolveDefinition, resolveRendererType2, splitMatchedQueriesDsl, splitNamespace} from './util';\n\nexport function anchorDef(\n    flags: NodeFlags, matchedQueriesDsl: null | [string | number, QueryValueType][],\n    ngContentIndex: null | number, childCount: number, handleEvent?: null | ElementHandleEventFn,\n    templateFactory?: ViewDefinitionFactory): NodeDef {\n  flags |= NodeFlags.TypeElement;\n  const {matchedQueries, references, matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);\n  const template = templateFactory ? resolveDefinition(templateFactory) : null;\n\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    flags,\n    checkIndex: -1,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0, matchedQueries, matchedQueryIds, references, ngContentIndex, childCount,\n    bindings: [],\n    bindingFlags: 0,\n    outputs: [],\n    element: {\n      ns: null,\n      name: null,\n      attrs: null, template,\n      componentProvider: null,\n      componentView: null,\n      componentRendererType: null,\n      publicProviders: null,\n      allProviders: null,\n      handleEvent: handleEvent || NOOP\n    },\n    provider: null,\n    text: null,\n    query: null,\n    ngContent: null\n  };\n}\n\nexport function elementDef(\n    checkIndex: number, flags: NodeFlags,\n    matchedQueriesDsl: null | [string | number, QueryValueType][], ngContentIndex: null | number,\n    childCount: number, namespaceAndName: string | null, fixedAttrs: null | [string, string][] = [],\n    bindings?: null | [BindingFlags, string, string | SecurityContext | null][],\n    outputs?: null | ([string, string])[], handleEvent?: null | ElementHandleEventFn,\n    componentView?: null | ViewDefinitionFactory,\n    componentRendererType?: RendererType2 | null): NodeDef {\n  if (!handleEvent) {\n    handleEvent = NOOP;\n  }\n  const {matchedQueries, references, matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);\n  let ns: string = null !;\n  let name: string = null !;\n  if (namespaceAndName) {\n    [ns, name] = splitNamespace(namespaceAndName);\n  }\n  bindings = bindings || [];\n  const bindingDefs: BindingDef[] = new Array(bindings.length);\n  for (let i = 0; i < bindings.length; i++) {\n    const [bindingFlags, namespaceAndName, suffixOrSecurityContext] = bindings[i];\n\n    const [ns, name] = splitNamespace(namespaceAndName);\n    let securityContext: SecurityContext = undefined !;\n    let suffix: string = undefined !;\n    switch (bindingFlags & BindingFlags.Types) {\n      case BindingFlags.TypeElementStyle:\n        suffix = <string>suffixOrSecurityContext;\n        break;\n      case BindingFlags.TypeElementAttribute:\n      case BindingFlags.TypeProperty:\n        securityContext = <SecurityContext>suffixOrSecurityContext;\n        break;\n    }\n    bindingDefs[i] =\n        {flags: bindingFlags, ns, name, nonMinifiedName: name, securityContext, suffix};\n  }\n  outputs = outputs || [];\n  const outputDefs: OutputDef[] = new Array(outputs.length);\n  for (let i = 0; i < outputs.length; i++) {\n    const [target, eventName] = outputs[i];\n    outputDefs[i] = {\n      type: OutputType.ElementOutput,\n      target: <any>target, eventName,\n      propName: null\n    };\n  }\n  fixedAttrs = fixedAttrs || [];\n  const attrs = <[string, string, string][]>fixedAttrs.map(([namespaceAndName, value]) => {\n    const [ns, name] = splitNamespace(namespaceAndName);\n    return [ns, name, value];\n  });\n  componentRendererType = resolveRendererType2(componentRendererType);\n  if (componentView) {\n    flags |= NodeFlags.ComponentView;\n  }\n  flags |= NodeFlags.TypeElement;\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    checkIndex,\n    flags,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0, matchedQueries, matchedQueryIds, references, ngContentIndex, childCount,\n    bindings: bindingDefs,\n    bindingFlags: calcBindingFlags(bindingDefs),\n    outputs: outputDefs,\n    element: {\n      ns,\n      name,\n      attrs,\n      template: null,\n      // will bet set by the view definition\n      componentProvider: null,\n      componentView: componentView || null,\n      componentRendererType: componentRendererType,\n      publicProviders: null,\n      allProviders: null,\n      handleEvent: handleEvent || NOOP,\n    },\n    provider: null,\n    text: null,\n    query: null,\n    ngContent: null\n  };\n}\n\nexport function createElement(view: ViewData, renderHost: any, def: NodeDef): ElementData {\n  const elDef = def.element !;\n  const rootSelectorOrNode = view.root.selectorOrNode;\n  const renderer = view.renderer;\n  let el: any;\n  if (view.parent || !rootSelectorOrNode) {\n    if (elDef.name) {\n      el = renderer.createElement(elDef.name, elDef.ns);\n    } else {\n      el = renderer.createComment('');\n    }\n    const parentEl = getParentRenderElement(view, renderHost, def);\n    if (parentEl) {\n      renderer.appendChild(parentEl, el);\n    }\n  } else {\n    // when using native Shadow DOM, do not clear the root element contents to allow slot projection\n    const preserveContent =\n        (!!elDef.componentRendererType &&\n         elDef.componentRendererType.encapsulation === ViewEncapsulation.ShadowDom);\n    el = renderer.selectRootElement(rootSelectorOrNode, preserveContent);\n  }\n  if (elDef.attrs) {\n    for (let i = 0; i < elDef.attrs.length; i++) {\n      const [ns, name, value] = elDef.attrs[i];\n      renderer.setAttribute(el, name, value, ns);\n    }\n  }\n  return el;\n}\n\nexport function listenToElementOutputs(view: ViewData, compView: ViewData, def: NodeDef, el: any) {\n  for (let i = 0; i < def.outputs.length; i++) {\n    const output = def.outputs[i];\n    const handleEventClosure = renderEventHandlerClosure(\n        view, def.nodeIndex, elementEventFullName(output.target, output.eventName));\n    let listenTarget: 'window'|'document'|'body'|'component'|null = output.target;\n    let listenerView = view;\n    if (output.target === 'component') {\n      listenTarget = null;\n      listenerView = compView;\n    }\n    const disposable =\n        <any>listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure);\n    view.disposables ![def.outputIndex + i] = disposable;\n  }\n}\n\nfunction renderEventHandlerClosure(view: ViewData, index: number, eventName: string) {\n  return (event: any) => dispatchEvent(view, index, eventName, event);\n}\n\n\nexport function checkAndUpdateElementInline(\n    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,\n    v7: any, v8: any, v9: any): boolean {\n  const bindLen = def.bindings.length;\n  let changed = false;\n  if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0)) changed = true;\n  if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1)) changed = true;\n  if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2)) changed = true;\n  if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3)) changed = true;\n  if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4)) changed = true;\n  if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5)) changed = true;\n  if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6)) changed = true;\n  if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7)) changed = true;\n  if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8)) changed = true;\n  if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9)) changed = true;\n  return changed;\n}\n\nexport function checkAndUpdateElementDynamic(view: ViewData, def: NodeDef, values: any[]): boolean {\n  let changed = false;\n  for (let i = 0; i < values.length; i++) {\n    if (checkAndUpdateElementValue(view, def, i, values[i])) changed = true;\n  }\n  return changed;\n}\n\nfunction checkAndUpdateElementValue(view: ViewData, def: NodeDef, bindingIdx: number, value: any) {\n  if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {\n    return false;\n  }\n  const binding = def.bindings[bindingIdx];\n  const elData = asElementData(view, def.nodeIndex);\n  const renderNode = elData.renderElement;\n  const name = binding.name !;\n  switch (binding.flags & BindingFlags.Types) {\n    case BindingFlags.TypeElementAttribute:\n      setElementAttribute(view, binding, renderNode, binding.ns, name, value);\n      break;\n    case BindingFlags.TypeElementClass:\n      setElementClass(view, renderNode, name, value);\n      break;\n    case BindingFlags.TypeElementStyle:\n      setElementStyle(view, binding, renderNode, name, value);\n      break;\n    case BindingFlags.TypeProperty:\n      const bindView = (def.flags & NodeFlags.ComponentView &&\n                        binding.flags & BindingFlags.SyntheticHostProperty) ?\n          elData.componentView :\n          view;\n      setElementProperty(bindView, binding, renderNode, name, value);\n      break;\n  }\n  return true;\n}\n\nfunction setElementAttribute(\n    view: ViewData, binding: BindingDef, renderNode: any, ns: string | null, name: string,\n    value: any) {\n  const securityContext = binding.securityContext;\n  let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;\n  renderValue = renderValue != null ? renderValue.toString() : null;\n  const renderer = view.renderer;\n  if (value != null) {\n    renderer.setAttribute(renderNode, name, renderValue, ns);\n  } else {\n    renderer.removeAttribute(renderNode, name, ns);\n  }\n}\n\nfunction setElementClass(view: ViewData, renderNode: any, name: string, value: boolean) {\n  const renderer = view.renderer;\n  if (value) {\n    renderer.addClass(renderNode, name);\n  } else {\n    renderer.removeClass(renderNode, name);\n  }\n}\n\nfunction setElementStyle(\n    view: ViewData, binding: BindingDef, renderNode: any, name: string, value: any) {\n  let renderValue: string|null =\n      view.root.sanitizer.sanitize(SecurityContext.STYLE, value as{} | string);\n  if (renderValue != null) {\n    renderValue = renderValue.toString();\n    const unit = binding.suffix;\n    if (unit != null) {\n      renderValue = renderValue + unit;\n    }\n  } else {\n    renderValue = null;\n  }\n  const renderer = view.renderer;\n  if (renderValue != null) {\n    renderer.setStyle(renderNode, name, renderValue);\n  } else {\n    renderer.removeStyle(renderNode, name);\n  }\n}\n\nfunction setElementProperty(\n    view: ViewData, binding: BindingDef, renderNode: any, name: string, value: any) {\n  const securityContext = binding.securityContext;\n  let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;\n  view.renderer.setProperty(renderNode, name, renderValue);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectableDef, getInjectableDef} from '../di/defs';\nimport {resolveForwardRef} from '../di/forward_ref';\nimport {INJECTOR, Injector} from '../di/injector';\nimport {setCurrentInjector} from '../di/injector_compatibility';\nimport {APP_ROOT} from '../di/scope';\nimport {NgModuleRef} from '../linker/ng_module_factory';\nimport {stringify} from '../util';\n\nimport {DepDef, DepFlags, NgModuleData, NgModuleDefinition, NgModuleProviderDef, NodeFlags} from './types';\nimport {splitDepsDsl, tokenKey} from './util';\n\nconst UNDEFINED_VALUE = new Object();\n\nconst InjectorRefTokenKey = tokenKey(Injector);\nconst INJECTORRefTokenKey = tokenKey(INJECTOR);\nconst NgModuleRefTokenKey = tokenKey(NgModuleRef);\n\nexport function moduleProvideDef(\n    flags: NodeFlags, token: any, value: any,\n    deps: ([DepFlags, any] | any)[]): NgModuleProviderDef {\n  // Need to resolve forwardRefs as e.g. for `useValue` we\n  // lowered the expression and then stopped evaluating it,\n  // i.e. also didn't unwrap it.\n  value = resolveForwardRef(value);\n  const depDefs = splitDepsDsl(deps, stringify(token));\n  return {\n    // will bet set by the module definition\n    index: -1,\n    deps: depDefs, flags, token, value\n  };\n}\n\nexport function moduleDef(providers: NgModuleProviderDef[]): NgModuleDefinition {\n  const providersByKey: {[key: string]: NgModuleProviderDef} = {};\n  const modules = [];\n  let isRoot: boolean = false;\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    if (provider.token === APP_ROOT && provider.value === true) {\n      isRoot = true;\n    }\n    if (provider.flags & NodeFlags.TypeNgModule) {\n      modules.push(provider.token);\n    }\n    provider.index = i;\n    providersByKey[tokenKey(provider.token)] = provider;\n  }\n  return {\n    // Will be filled later...\n    factory: null,\n    providersByKey,\n    providers,\n    modules,\n    isRoot,\n  };\n}\n\nexport function initNgModule(data: NgModuleData) {\n  const def = data._def;\n  const providers = data._providers = new Array(def.providers.length);\n  for (let i = 0; i < def.providers.length; i++) {\n    const provDef = def.providers[i];\n    if (!(provDef.flags & NodeFlags.LazyProvider)) {\n      // Make sure the provider has not been already initialized outside this loop.\n      if (providers[i] === undefined) {\n        providers[i] = _createProviderInstance(data, provDef);\n      }\n    }\n  }\n}\n\nexport function resolveNgModuleDep(\n    data: NgModuleData, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n  const former = setCurrentInjector(data);\n  try {\n    if (depDef.flags & DepFlags.Value) {\n      return depDef.token;\n    }\n    if (depDef.flags & DepFlags.Optional) {\n      notFoundValue = null;\n    }\n    if (depDef.flags & DepFlags.SkipSelf) {\n      return data._parent.get(depDef.token, notFoundValue);\n    }\n    const tokenKey = depDef.tokenKey;\n    switch (tokenKey) {\n      case InjectorRefTokenKey:\n      case INJECTORRefTokenKey:\n      case NgModuleRefTokenKey:\n        return data;\n    }\n    const providerDef = data._def.providersByKey[tokenKey];\n    let injectableDef: InjectableDef<any>|null;\n    if (providerDef) {\n      let providerInstance = data._providers[providerDef.index];\n      if (providerInstance === undefined) {\n        providerInstance = data._providers[providerDef.index] =\n            _createProviderInstance(data, providerDef);\n      }\n      return providerInstance === UNDEFINED_VALUE ? undefined : providerInstance;\n    } else if (\n        (injectableDef = getInjectableDef(depDef.token)) && targetsModule(data, injectableDef)) {\n      const index = data._providers.length;\n      data._def.providersByKey[depDef.tokenKey] = {\n        flags: NodeFlags.TypeFactoryProvider | NodeFlags.LazyProvider,\n        value: injectableDef.factory,\n        deps: [], index,\n        token: depDef.token,\n      };\n      data._providers[index] = UNDEFINED_VALUE;\n      return (\n          data._providers[index] =\n              _createProviderInstance(data, data._def.providersByKey[depDef.tokenKey]));\n    } else if (depDef.flags & DepFlags.Self) {\n      return notFoundValue;\n    }\n    return data._parent.get(depDef.token, notFoundValue);\n  } finally {\n    setCurrentInjector(former);\n  }\n}\n\nfunction moduleTransitivelyPresent(ngModule: NgModuleData, scope: any): boolean {\n  return ngModule._def.modules.indexOf(scope) > -1;\n}\n\nfunction targetsModule(ngModule: NgModuleData, def: InjectableDef<any>): boolean {\n  return def.providedIn != null && (moduleTransitivelyPresent(ngModule, def.providedIn) ||\n                                    def.providedIn === 'root' && ngModule._def.isRoot);\n}\n\nfunction _createProviderInstance(ngModule: NgModuleData, providerDef: NgModuleProviderDef): any {\n  let injectable: any;\n  switch (providerDef.flags & NodeFlags.Types) {\n    case NodeFlags.TypeClassProvider:\n      injectable = _createClass(ngModule, providerDef.value, providerDef.deps);\n      break;\n    case NodeFlags.TypeFactoryProvider:\n      injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);\n      break;\n    case NodeFlags.TypeUseExistingProvider:\n      injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);\n      break;\n    case NodeFlags.TypeValueProvider:\n      injectable = providerDef.value;\n      break;\n  }\n\n  // The read of `ngOnDestroy` here is slightly expensive as it's megamorphic, so it should be\n  // avoided if possible. The sequence of checks here determines whether ngOnDestroy needs to be\n  // checked. It might not if the `injectable` isn't an object or if NodeFlags.OnDestroy is already\n  // set (ngOnDestroy was detected statically).\n  if (injectable !== UNDEFINED_VALUE && injectable != null && typeof injectable === 'object' &&\n      !(providerDef.flags & NodeFlags.OnDestroy) && typeof injectable.ngOnDestroy === 'function') {\n    providerDef.flags |= NodeFlags.OnDestroy;\n  }\n  return injectable === undefined ? UNDEFINED_VALUE : injectable;\n}\n\nfunction _createClass(ngModule: NgModuleData, ctor: any, deps: DepDef[]): any {\n  const len = deps.length;\n  switch (len) {\n    case 0:\n      return new ctor();\n    case 1:\n      return new ctor(resolveNgModuleDep(ngModule, deps[0]));\n    case 2:\n      return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));\n    case 3:\n      return new ctor(\n          resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]),\n          resolveNgModuleDep(ngModule, deps[2]));\n    default:\n      const depValues = new Array(len);\n      for (let i = 0; i < len; i++) {\n        depValues[i] = resolveNgModuleDep(ngModule, deps[i]);\n      }\n      return new ctor(...depValues);\n  }\n}\n\nfunction _callFactory(ngModule: NgModuleData, factory: any, deps: DepDef[]): any {\n  const len = deps.length;\n  switch (len) {\n    case 0:\n      return factory();\n    case 1:\n      return factory(resolveNgModuleDep(ngModule, deps[0]));\n    case 2:\n      return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));\n    case 3:\n      return factory(\n          resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]),\n          resolveNgModuleDep(ngModule, deps[2]));\n    default:\n      const depValues = Array(len);\n      for (let i = 0; i < len; i++) {\n        depValues[i] = resolveNgModuleDep(ngModule, deps[i]);\n      }\n      return factory(...depValues);\n  }\n}\n\nexport function callNgModuleLifecycle(ngModule: NgModuleData, lifecycles: NodeFlags) {\n  const def = ngModule._def;\n  const destroyed = new Set<any>();\n  for (let i = 0; i < def.providers.length; i++) {\n    const provDef = def.providers[i];\n    if (provDef.flags & NodeFlags.OnDestroy) {\n      const instance = ngModule._providers[i];\n      if (instance && instance !== UNDEFINED_VALUE) {\n        const onDestroy: Function|undefined = instance.ngOnDestroy;\n        if (typeof onDestroy === 'function' && !destroyed.has(instance)) {\n          onDestroy.apply(instance);\n          destroyed.add(instance);\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementData, NodeDef, NodeFlags, Services, ViewData, ViewDefinition, ViewState} from './types';\nimport {RenderNodeAction, declaredViewContainer, isComponentView, renderNode, visitRootRenderNodes} from './util';\n\nexport function attachEmbeddedView(\n    parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null,\n    view: ViewData) {\n  let embeddedViews = elementData.viewContainer !._embeddedViews;\n  if (viewIndex === null || viewIndex === undefined) {\n    viewIndex = embeddedViews.length;\n  }\n  view.viewContainerParent = parentView;\n  addToArray(embeddedViews, viewIndex !, view);\n  attachProjectedView(elementData, view);\n\n  Services.dirtyParentQueries(view);\n\n  const prevView = viewIndex ! > 0 ? embeddedViews[viewIndex ! - 1] : null;\n  renderAttachEmbeddedView(elementData, prevView, view);\n}\n\nfunction attachProjectedView(vcElementData: ElementData, view: ViewData) {\n  const dvcElementData = declaredViewContainer(view);\n  if (!dvcElementData || dvcElementData === vcElementData ||\n      view.state & ViewState.IsProjectedView) {\n    return;\n  }\n  // Note: For performance reasons, we\n  // - add a view to template._projectedViews only 1x throughout its lifetime,\n  //   and remove it not until the view is destroyed.\n  //   (hard, as when a parent view is attached/detached we would need to attach/detach all\n  //    nested projected views as well, even across component boundaries).\n  // - don't track the insertion order of views in the projected views array\n  //   (hard, as when the views of the same template are inserted different view containers)\n  view.state |= ViewState.IsProjectedView;\n  let projectedViews = dvcElementData.template._projectedViews;\n  if (!projectedViews) {\n    projectedViews = dvcElementData.template._projectedViews = [];\n  }\n  projectedViews.push(view);\n  // Note: we are changing the NodeDef here as we cannot calculate\n  // the fact whether a template is used for projection during compilation.\n  markNodeAsProjectedTemplate(view.parent !.def, view.parentNodeDef !);\n}\n\nfunction markNodeAsProjectedTemplate(viewDef: ViewDefinition, nodeDef: NodeDef) {\n  if (nodeDef.flags & NodeFlags.ProjectedTemplate) {\n    return;\n  }\n  viewDef.nodeFlags |= NodeFlags.ProjectedTemplate;\n  nodeDef.flags |= NodeFlags.ProjectedTemplate;\n  let parentNodeDef = nodeDef.parent;\n  while (parentNodeDef) {\n    parentNodeDef.childFlags |= NodeFlags.ProjectedTemplate;\n    parentNodeDef = parentNodeDef.parent;\n  }\n}\n\nexport function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData|null {\n  const embeddedViews = elementData.viewContainer !._embeddedViews;\n  if (viewIndex == null || viewIndex >= embeddedViews.length) {\n    viewIndex = embeddedViews.length - 1;\n  }\n  if (viewIndex < 0) {\n    return null;\n  }\n  const view = embeddedViews[viewIndex];\n  view.viewContainerParent = null;\n  removeFromArray(embeddedViews, viewIndex);\n\n  // See attachProjectedView for why we don't update projectedViews here.\n  Services.dirtyParentQueries(view);\n\n  renderDetachView(view);\n\n  return view;\n}\n\nexport function detachProjectedView(view: ViewData) {\n  if (!(view.state & ViewState.IsProjectedView)) {\n    return;\n  }\n  const dvcElementData = declaredViewContainer(view);\n  if (dvcElementData) {\n    const projectedViews = dvcElementData.template._projectedViews;\n    if (projectedViews) {\n      removeFromArray(projectedViews, projectedViews.indexOf(view));\n      Services.dirtyParentQueries(view);\n    }\n  }\n}\n\nexport function moveEmbeddedView(\n    elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData {\n  const embeddedViews = elementData.viewContainer !._embeddedViews;\n  const view = embeddedViews[oldViewIndex];\n  removeFromArray(embeddedViews, oldViewIndex);\n  if (newViewIndex == null) {\n    newViewIndex = embeddedViews.length;\n  }\n  addToArray(embeddedViews, newViewIndex, view);\n\n  // Note: Don't need to change projectedViews as the order in there\n  // as always invalid...\n\n  Services.dirtyParentQueries(view);\n\n  renderDetachView(view);\n  const prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;\n  renderAttachEmbeddedView(elementData, prevView, view);\n\n  return view;\n}\n\nfunction renderAttachEmbeddedView(\n    elementData: ElementData, prevView: ViewData | null, view: ViewData) {\n  const prevRenderNode = prevView ? renderNode(prevView, prevView.def.lastRenderRootNode !) :\n                                    elementData.renderElement;\n  const parentNode = view.renderer.parentNode(prevRenderNode);\n  const nextSibling = view.renderer.nextSibling(prevRenderNode);\n  // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!\n  // However, browsers automatically do `appendChild` when there is no `nextSibling`.\n  visitRootRenderNodes(view, RenderNodeAction.InsertBefore, parentNode, nextSibling, undefined);\n}\n\nexport function renderDetachView(view: ViewData) {\n  visitRootRenderNodes(view, RenderNodeAction.RemoveChild, null, null, undefined);\n}\n\nfunction addToArray(arr: any[], index: number, value: any) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nfunction removeFromArray(arr: any[], index: number) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    arr.pop();\n  } else {\n    arr.splice(index, 1);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {ChangeDetectorRef} from '../change_detection/change_detection';\nimport {Injector} from '../di/injector';\nimport {InjectFlags} from '../di/injector_compatibility';\nimport {ComponentFactory, ComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryBoundToModule, ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {ElementRef} from '../linker/element_ref';\nimport {InternalNgModuleRef, NgModuleRef} from '../linker/ng_module_factory';\nimport {TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef, InternalViewRef, ViewRef} from '../linker/view_ref';\nimport {Renderer as RendererV1, Renderer2} from '../render/api';\nimport {Type} from '../type';\nimport {stringify} from '../util';\nimport {VERSION} from '../version';\n\nimport {callNgModuleLifecycle, initNgModule, resolveNgModuleDep} from './ng_module';\nimport {DepFlags, ElementData, NgModuleData, NgModuleDefinition, NodeDef, NodeFlags, Services, TemplateData, ViewContainerData, ViewData, ViewDefinitionFactory, ViewState, asElementData, asProviderData, asTextData} from './types';\nimport {markParentViewsForCheck, resolveDefinition, rootRenderNodes, splitNamespace, tokenKey, viewParentEl} from './util';\nimport {attachEmbeddedView, detachEmbeddedView, moveEmbeddedView, renderDetachView} from './view_attach';\n\nconst EMPTY_CONTEXT = new Object();\n\n// Attention: this function is called as top level function.\n// Putting any logic in here will destroy closure tree shaking!\nexport function createComponentFactory(\n    selector: string, componentType: Type<any>, viewDefFactory: ViewDefinitionFactory,\n    inputs: {[propName: string]: string} | null, outputs: {[propName: string]: string},\n    ngContentSelectors: string[]): ComponentFactory<any> {\n  return new ComponentFactory_(\n      selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);\n}\n\nexport function getComponentViewDefinitionFactory(componentFactory: ComponentFactory<any>):\n    ViewDefinitionFactory {\n  return (componentFactory as ComponentFactory_).viewDefFactory;\n}\n\nclass ComponentFactory_ extends ComponentFactory<any> {\n  /**\n   * @internal\n   */\n  viewDefFactory: ViewDefinitionFactory;\n\n  constructor(\n      public selector: string, public componentType: Type<any>,\n      viewDefFactory: ViewDefinitionFactory, private _inputs: {[propName: string]: string}|null,\n      private _outputs: {[propName: string]: string}, public ngContentSelectors: string[]) {\n    // Attention: this ctor is called as top level function.\n    // Putting any logic in here will destroy closure tree shaking!\n    super();\n    this.viewDefFactory = viewDefFactory;\n  }\n\n  get inputs() {\n    const inputsArr: {propName: string, templateName: string}[] = [];\n    const inputs = this._inputs !;\n    for (let propName in inputs) {\n      const templateName = inputs[propName];\n      inputsArr.push({propName, templateName});\n    }\n    return inputsArr;\n  }\n\n  get outputs() {\n    const outputsArr: {propName: string, templateName: string}[] = [];\n    for (let propName in this._outputs) {\n      const templateName = this._outputs[propName];\n      outputsArr.push({propName, templateName});\n    }\n    return outputsArr;\n  }\n\n  /**\n   * Creates a new component.\n   */\n  create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<any> {\n    if (!ngModule) {\n      throw new Error('ngModule should be provided');\n    }\n    const viewDef = resolveDefinition(this.viewDefFactory);\n    const componentNodeIndex = viewDef.nodes[0].element !.componentProvider !.nodeIndex;\n    const view = Services.createRootView(\n        injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);\n    const component = asProviderData(view, componentNodeIndex).instance;\n    if (rootSelectorOrNode) {\n      view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);\n    }\n\n    return new ComponentRef_(view, new ViewRef_(view), component);\n  }\n}\n\nclass ComponentRef_ extends ComponentRef<any> {\n  public readonly hostView: ViewRef;\n  public readonly instance: any;\n  public readonly changeDetectorRef: ChangeDetectorRef;\n  private _elDef: NodeDef;\n  constructor(private _view: ViewData, private _viewRef: ViewRef, private _component: any) {\n    super();\n    this._elDef = this._view.def.nodes[0];\n    this.hostView = _viewRef;\n    this.changeDetectorRef = _viewRef;\n    this.instance = _component;\n  }\n  get location(): ElementRef {\n    return new ElementRef(asElementData(this._view, this._elDef.nodeIndex).renderElement);\n  }\n  get injector(): Injector { return new Injector_(this._view, this._elDef); }\n  get componentType(): Type<any> { return <any>this._component.constructor; }\n\n  destroy(): void { this._viewRef.destroy(); }\n  onDestroy(callback: Function): void { this._viewRef.onDestroy(callback); }\n}\n\nexport function createViewContainerData(\n    view: ViewData, elDef: NodeDef, elData: ElementData): ViewContainerData {\n  return new ViewContainerRef_(view, elDef, elData);\n}\n\nclass ViewContainerRef_ implements ViewContainerData {\n  /**\n   * @internal\n   */\n  _embeddedViews: ViewData[] = [];\n  constructor(private _view: ViewData, private _elDef: NodeDef, private _data: ElementData) {}\n\n  get element(): ElementRef { return new ElementRef(this._data.renderElement); }\n\n  get injector(): Injector { return new Injector_(this._view, this._elDef); }\n\n  /** @deprecated No replacement */\n  get parentInjector(): Injector {\n    let view = this._view;\n    let elDef = this._elDef.parent;\n    while (!elDef && view) {\n      elDef = viewParentEl(view);\n      view = view.parent !;\n    }\n\n    return view ? new Injector_(view, elDef) : new Injector_(this._view, null);\n  }\n\n  clear(): void {\n    const len = this._embeddedViews.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const view = detachEmbeddedView(this._data, i) !;\n      Services.destroyView(view);\n    }\n  }\n\n  get(index: number): ViewRef|null {\n    const view = this._embeddedViews[index];\n    if (view) {\n      const ref = new ViewRef_(view);\n      ref.attachToViewContainerRef(this);\n      return ref;\n    }\n    return null;\n  }\n\n  get length(): number { return this._embeddedViews.length; }\n\n  createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n      EmbeddedViewRef<C> {\n    const viewRef = templateRef.createEmbeddedView(context || <any>{});\n    this.insert(viewRef, index);\n    return viewRef;\n  }\n\n  createComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][], ngModuleRef?: NgModuleRef<any>): ComponentRef<C> {\n    const contextInjector = injector || this.parentInjector;\n    if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {\n      ngModuleRef = contextInjector.get(NgModuleRef);\n    }\n    const componentRef =\n        componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n\n  insert(viewRef: ViewRef, index?: number): ViewRef {\n    if (viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n    const viewRef_ = <ViewRef_>viewRef;\n    const viewData = viewRef_._view;\n    attachEmbeddedView(this._view, this._data, index, viewData);\n    viewRef_.attachToViewContainerRef(this);\n    return viewRef;\n  }\n\n  move(viewRef: ViewRef_, currentIndex: number): ViewRef {\n    if (viewRef.destroyed) {\n      throw new Error('Cannot move a destroyed View in a ViewContainer!');\n    }\n    const previousIndex = this._embeddedViews.indexOf(viewRef._view);\n    moveEmbeddedView(this._data, previousIndex, currentIndex);\n    return viewRef;\n  }\n\n  indexOf(viewRef: ViewRef): number {\n    return this._embeddedViews.indexOf((<ViewRef_>viewRef)._view);\n  }\n\n  remove(index?: number): void {\n    const viewData = detachEmbeddedView(this._data, index);\n    if (viewData) {\n      Services.destroyView(viewData);\n    }\n  }\n\n  detach(index?: number): ViewRef|null {\n    const view = detachEmbeddedView(this._data, index);\n    return view ? new ViewRef_(view) : null;\n  }\n}\n\nexport function createChangeDetectorRef(view: ViewData): ChangeDetectorRef {\n  return new ViewRef_(view);\n}\n\nexport class ViewRef_ implements EmbeddedViewRef<any>, InternalViewRef {\n  /** @internal */\n  _view: ViewData;\n  private _viewContainerRef: ViewContainerRef|null;\n  private _appRef: ApplicationRef|null;\n\n  constructor(_view: ViewData) {\n    this._view = _view;\n    this._viewContainerRef = null;\n    this._appRef = null;\n  }\n\n  get rootNodes(): any[] { return rootRenderNodes(this._view); }\n\n  get context() { return this._view.context; }\n\n  get destroyed(): boolean { return (this._view.state & ViewState.Destroyed) !== 0; }\n\n  markForCheck(): void { markParentViewsForCheck(this._view); }\n  detach(): void { this._view.state &= ~ViewState.Attached; }\n  detectChanges(): void {\n    const fs = this._view.root.rendererFactory;\n    if (fs.begin) {\n      fs.begin();\n    }\n    try {\n      Services.checkAndUpdateView(this._view);\n    } finally {\n      if (fs.end) {\n        fs.end();\n      }\n    }\n  }\n  checkNoChanges(): void { Services.checkNoChangesView(this._view); }\n\n  reattach(): void { this._view.state |= ViewState.Attached; }\n  onDestroy(callback: Function) {\n    if (!this._view.disposables) {\n      this._view.disposables = [];\n    }\n    this._view.disposables.push(<any>callback);\n  }\n\n  destroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef) {\n      this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\n    }\n    Services.destroyView(this._view);\n  }\n\n  detachFromAppRef() {\n    this._appRef = null;\n    renderDetachView(this._view);\n    Services.dirtyParentQueries(this._view);\n  }\n\n  attachToAppRef(appRef: ApplicationRef) {\n    if (this._viewContainerRef) {\n      throw new Error('This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n\n  attachToViewContainerRef(vcRef: ViewContainerRef) {\n    if (this._appRef) {\n      throw new Error('This view is already attached directly to the ApplicationRef!');\n    }\n    this._viewContainerRef = vcRef;\n  }\n}\n\nexport function createTemplateData(view: ViewData, def: NodeDef): TemplateData {\n  return new TemplateRef_(view, def);\n}\n\nclass TemplateRef_ extends TemplateRef<any> implements TemplateData {\n  /**\n   * @internal\n   */\n  // TODO(issue/24571): remove '!'.\n  _projectedViews !: ViewData[];\n\n  constructor(private _parentView: ViewData, private _def: NodeDef) { super(); }\n\n  createEmbeddedView(context: any): EmbeddedViewRef<any> {\n    return new ViewRef_(Services.createEmbeddedView(\n        this._parentView, this._def, this._def.element !.template !, context));\n  }\n\n  get elementRef(): ElementRef {\n    return new ElementRef(asElementData(this._parentView, this._def.nodeIndex).renderElement);\n  }\n}\n\nexport function createInjector(view: ViewData, elDef: NodeDef): Injector {\n  return new Injector_(view, elDef);\n}\n\nclass Injector_ implements Injector {\n  constructor(private view: ViewData, private elDef: NodeDef|null) {}\n  get(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n    const allowPrivateServices =\n        this.elDef ? (this.elDef.flags & NodeFlags.ComponentView) !== 0 : false;\n    return Services.resolveDep(\n        this.view, this.elDef, allowPrivateServices,\n        {flags: DepFlags.None, token, tokenKey: tokenKey(token)}, notFoundValue);\n  }\n}\n\nexport function nodeValue(view: ViewData, index: number): any {\n  const def = view.def.nodes[index];\n  if (def.flags & NodeFlags.TypeElement) {\n    const elData = asElementData(view, def.nodeIndex);\n    return def.element !.template ? elData.template : elData.renderElement;\n  } else if (def.flags & NodeFlags.TypeText) {\n    return asTextData(view, def.nodeIndex).renderText;\n  } else if (def.flags & (NodeFlags.CatProvider | NodeFlags.TypePipe)) {\n    return asProviderData(view, def.nodeIndex).instance;\n  }\n  throw new Error(`Illegal state: read nodeValue for node index ${index}`);\n}\n\nexport function createRendererV1(view: ViewData): RendererV1 {\n  return new RendererAdapter(view.renderer);\n}\n\nclass RendererAdapter implements RendererV1 {\n  constructor(private delegate: Renderer2) {}\n  selectRootElement(selectorOrNode: string|Element): Element {\n    return this.delegate.selectRootElement(selectorOrNode);\n  }\n\n  createElement(parent: Element|DocumentFragment, namespaceAndName: string): Element {\n    const [ns, name] = splitNamespace(namespaceAndName);\n    const el = this.delegate.createElement(name, ns);\n    if (parent) {\n      this.delegate.appendChild(parent, el);\n    }\n    return el;\n  }\n\n  createViewRoot(hostElement: Element): Element|DocumentFragment { return hostElement; }\n\n  createTemplateAnchor(parentElement: Element|DocumentFragment): Comment {\n    const comment = this.delegate.createComment('');\n    if (parentElement) {\n      this.delegate.appendChild(parentElement, comment);\n    }\n    return comment;\n  }\n\n  createText(parentElement: Element|DocumentFragment, value: string): any {\n    const node = this.delegate.createText(value);\n    if (parentElement) {\n      this.delegate.appendChild(parentElement, node);\n    }\n    return node;\n  }\n\n  projectNodes(parentElement: Element|DocumentFragment, nodes: Node[]) {\n    for (let i = 0; i < nodes.length; i++) {\n      this.delegate.appendChild(parentElement, nodes[i]);\n    }\n  }\n\n  attachViewAfter(node: Node, viewRootNodes: Node[]) {\n    const parentElement = this.delegate.parentNode(node);\n    const nextSibling = this.delegate.nextSibling(node);\n    for (let i = 0; i < viewRootNodes.length; i++) {\n      this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);\n    }\n  }\n\n  detachView(viewRootNodes: (Element|Text|Comment)[]) {\n    for (let i = 0; i < viewRootNodes.length; i++) {\n      const node = viewRootNodes[i];\n      const parentElement = this.delegate.parentNode(node);\n      this.delegate.removeChild(parentElement, node);\n    }\n  }\n\n  destroyView(hostElement: Element|DocumentFragment, viewAllNodes: Node[]) {\n    for (let i = 0; i < viewAllNodes.length; i++) {\n      this.delegate.destroyNode !(viewAllNodes[i]);\n    }\n  }\n\n  listen(renderElement: any, name: string, callback: Function): Function {\n    return this.delegate.listen(renderElement, name, <any>callback);\n  }\n\n  listenGlobal(target: string, name: string, callback: Function): Function {\n    return this.delegate.listen(target, name, <any>callback);\n  }\n\n  setElementProperty(\n      renderElement: Element|DocumentFragment, propertyName: string, propertyValue: any): void {\n    this.delegate.setProperty(renderElement, propertyName, propertyValue);\n  }\n\n  setElementAttribute(renderElement: Element, namespaceAndName: string, attributeValue?: string):\n      void {\n    const [ns, name] = splitNamespace(namespaceAndName);\n    if (attributeValue != null) {\n      this.delegate.setAttribute(renderElement, name, attributeValue, ns);\n    } else {\n      this.delegate.removeAttribute(renderElement, name, ns);\n    }\n  }\n\n  setBindingDebugInfo(renderElement: Element, propertyName: string, propertyValue: string): void {}\n\n  setElementClass(renderElement: Element, className: string, isAdd: boolean): void {\n    if (isAdd) {\n      this.delegate.addClass(renderElement, className);\n    } else {\n      this.delegate.removeClass(renderElement, className);\n    }\n  }\n\n  setElementStyle(renderElement: HTMLElement, styleName: string, styleValue?: string): void {\n    if (styleValue != null) {\n      this.delegate.setStyle(renderElement, styleName, styleValue);\n    } else {\n      this.delegate.removeStyle(renderElement, styleName);\n    }\n  }\n\n  invokeElementMethod(renderElement: Element, methodName: string, args: any[]): void {\n    (renderElement as any)[methodName].apply(renderElement, args);\n  }\n\n  setText(renderNode: Text, text: string): void { this.delegate.setValue(renderNode, text); }\n\n  animate(): any { throw new Error('Renderer.animate is no longer supported!'); }\n}\n\n\nexport function createNgModuleRef(\n    moduleType: Type<any>, parent: Injector, bootstrapComponents: Type<any>[],\n    def: NgModuleDefinition): NgModuleRef<any> {\n  return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);\n}\n\nclass NgModuleRef_ implements NgModuleData, InternalNgModuleRef<any> {\n  private _destroyListeners: (() => void)[] = [];\n  private _destroyed: boolean = false;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _providers !: any[];\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _modules !: any[];\n\n  readonly injector: Injector = this;\n\n  constructor(\n      private _moduleType: Type<any>, public _parent: Injector,\n      public _bootstrapComponents: Type<any>[], public _def: NgModuleDefinition) {\n    initNgModule(this);\n  }\n\n  get(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND,\n      injectFlags: InjectFlags = InjectFlags.Default): any {\n    let flags = DepFlags.None;\n    if (injectFlags & InjectFlags.SkipSelf) {\n      flags |= DepFlags.SkipSelf;\n    } else if (injectFlags & InjectFlags.Self) {\n      flags |= DepFlags.Self;\n    }\n    return resolveNgModuleDep(\n        this, {token: token, tokenKey: tokenKey(token), flags: flags}, notFoundValue);\n  }\n\n  get instance() { return this.get(this._moduleType); }\n\n  get componentFactoryResolver() { return this.get(ComponentFactoryResolver); }\n\n  destroy(): void {\n    if (this._destroyed) {\n      throw new Error(\n          `The ng module ${stringify(this.instance.constructor)} has already been destroyed.`);\n    }\n    this._destroyed = true;\n    callNgModuleLifecycle(this, NodeFlags.OnDestroy);\n    this._destroyListeners.forEach((listener) => listener());\n  }\n\n  onDestroy(callback: () => void): void { this._destroyListeners.push(callback); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, SimpleChange, SimpleChanges, WrappedValue} from '../change_detection/change_detection';\nimport {INJECTOR, Injector, resolveForwardRef} from '../di';\nimport {ElementRef} from '../linker/element_ref';\nimport {TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef} from '../linker/view_container_ref';\nimport {Renderer as RendererV1, Renderer2} from '../render/api';\nimport {stringify} from '../util';\nimport {isObservable} from '../util/lang';\n\nimport {createChangeDetectorRef, createInjector, createRendererV1} from './refs';\nimport {BindingDef, BindingFlags, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, OutputType, ProviderData, QueryValueType, Services, ViewData, ViewFlags, ViewState, asElementData, asProviderData, shouldCallLifecycleInitHook} from './types';\nimport {calcBindingFlags, checkBinding, dispatchEvent, isComponentView, splitDepsDsl, splitMatchedQueriesDsl, tokenKey, viewParentEl} from './util';\n\nconst RendererV1TokenKey = tokenKey(RendererV1);\nconst Renderer2TokenKey = tokenKey(Renderer2);\nconst ElementRefTokenKey = tokenKey(ElementRef);\nconst ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\nconst TemplateRefTokenKey = tokenKey(TemplateRef);\nconst ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\nconst InjectorRefTokenKey = tokenKey(Injector);\nconst INJECTORRefTokenKey = tokenKey(INJECTOR);\n\nexport function directiveDef(\n    checkIndex: number, flags: NodeFlags,\n    matchedQueries: null | [string | number, QueryValueType][], childCount: number, ctor: any,\n    deps: ([DepFlags, any] | any)[], props?: null | {[name: string]: [number, string]},\n    outputs?: null | {[name: string]: string}): NodeDef {\n  const bindings: BindingDef[] = [];\n  if (props) {\n    for (let prop in props) {\n      const [bindingIndex, nonMinifiedName] = props[prop];\n      bindings[bindingIndex] = {\n        flags: BindingFlags.TypeProperty,\n        name: prop, nonMinifiedName,\n        ns: null,\n        securityContext: null,\n        suffix: null\n      };\n    }\n  }\n  const outputDefs: OutputDef[] = [];\n  if (outputs) {\n    for (let propName in outputs) {\n      outputDefs.push(\n          {type: OutputType.DirectiveOutput, propName, target: null, eventName: outputs[propName]});\n    }\n  }\n  flags |= NodeFlags.TypeDirective;\n  return _def(\n      checkIndex, flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);\n}\n\nexport function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef {\n  flags |= NodeFlags.TypePipe;\n  return _def(-1, flags, null, 0, ctor, ctor, deps);\n}\n\nexport function providerDef(\n    flags: NodeFlags, matchedQueries: null | [string | number, QueryValueType][], token: any,\n    value: any, deps: ([DepFlags, any] | any)[]): NodeDef {\n  return _def(-1, flags, matchedQueries, 0, token, value, deps);\n}\n\nexport function _def(\n    checkIndex: number, flags: NodeFlags,\n    matchedQueriesDsl: [string | number, QueryValueType][] | null, childCount: number, token: any,\n    value: any, deps: ([DepFlags, any] | any)[], bindings?: BindingDef[],\n    outputs?: OutputDef[]): NodeDef {\n  const {matchedQueries, references, matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);\n  if (!outputs) {\n    outputs = [];\n  }\n  if (!bindings) {\n    bindings = [];\n  }\n  // Need to resolve forwardRefs as e.g. for `useValue` we\n  // lowered the expression and then stopped evaluating it,\n  // i.e. also didn't unwrap it.\n  value = resolveForwardRef(value);\n\n  const depDefs = splitDepsDsl(deps, stringify(token));\n\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    checkIndex,\n    flags,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0, matchedQueries, matchedQueryIds, references,\n    ngContentIndex: -1, childCount, bindings,\n    bindingFlags: calcBindingFlags(bindings), outputs,\n    element: null,\n    provider: {token, value, deps: depDefs},\n    text: null,\n    query: null,\n    ngContent: null\n  };\n}\n\nexport function createProviderInstance(view: ViewData, def: NodeDef): any {\n  return _createProviderInstance(view, def);\n}\n\nexport function createPipeInstance(view: ViewData, def: NodeDef): any {\n  // deps are looked up from component.\n  let compView = view;\n  while (compView.parent && !isComponentView(compView)) {\n    compView = compView.parent;\n  }\n  // pipes can see the private services of the component\n  const allowPrivateServices = true;\n  // pipes are always eager and classes!\n  return createClass(\n      compView.parent !, viewParentEl(compView) !, allowPrivateServices, def.provider !.value,\n      def.provider !.deps);\n}\n\nexport function createDirectiveInstance(view: ViewData, def: NodeDef): any {\n  // components can see other private services, other directives can't.\n  const allowPrivateServices = (def.flags & NodeFlags.Component) > 0;\n  // directives are always eager and classes!\n  const instance = createClass(\n      view, def.parent !, allowPrivateServices, def.provider !.value, def.provider !.deps);\n  if (def.outputs.length) {\n    for (let i = 0; i < def.outputs.length; i++) {\n      const output = def.outputs[i];\n      const outputObservable = instance[output.propName !];\n      if (isObservable(outputObservable)) {\n        const subscription = outputObservable.subscribe(\n            eventHandlerClosure(view, def.parent !.nodeIndex, output.eventName));\n        view.disposables ![def.outputIndex + i] = subscription.unsubscribe.bind(subscription);\n      } else {\n        throw new Error(\n            `@Output ${output.propName} not initialized in '${instance.constructor.name}'.`);\n      }\n    }\n  }\n  return instance;\n}\n\nfunction eventHandlerClosure(view: ViewData, index: number, eventName: string) {\n  return (event: any) => dispatchEvent(view, index, eventName, event);\n}\n\nexport function checkAndUpdateDirectiveInline(\n    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,\n    v7: any, v8: any, v9: any): boolean {\n  const providerData = asProviderData(view, def.nodeIndex);\n  const directive = providerData.instance;\n  let changed = false;\n  let changes: SimpleChanges = undefined !;\n  const bindLen = def.bindings.length;\n  if (bindLen > 0 && checkBinding(view, def, 0, v0)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 0, v0, changes);\n  }\n  if (bindLen > 1 && checkBinding(view, def, 1, v1)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 1, v1, changes);\n  }\n  if (bindLen > 2 && checkBinding(view, def, 2, v2)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 2, v2, changes);\n  }\n  if (bindLen > 3 && checkBinding(view, def, 3, v3)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 3, v3, changes);\n  }\n  if (bindLen > 4 && checkBinding(view, def, 4, v4)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 4, v4, changes);\n  }\n  if (bindLen > 5 && checkBinding(view, def, 5, v5)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 5, v5, changes);\n  }\n  if (bindLen > 6 && checkBinding(view, def, 6, v6)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 6, v6, changes);\n  }\n  if (bindLen > 7 && checkBinding(view, def, 7, v7)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 7, v7, changes);\n  }\n  if (bindLen > 8 && checkBinding(view, def, 8, v8)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 8, v8, changes);\n  }\n  if (bindLen > 9 && checkBinding(view, def, 9, v9)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 9, v9, changes);\n  }\n  if (changes) {\n    directive.ngOnChanges(changes);\n  }\n  if ((def.flags & NodeFlags.OnInit) &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingOnInit, def.nodeIndex)) {\n    directive.ngOnInit();\n  }\n  if (def.flags & NodeFlags.DoCheck) {\n    directive.ngDoCheck();\n  }\n  return changed;\n}\n\nexport function checkAndUpdateDirectiveDynamic(\n    view: ViewData, def: NodeDef, values: any[]): boolean {\n  const providerData = asProviderData(view, def.nodeIndex);\n  const directive = providerData.instance;\n  let changed = false;\n  let changes: SimpleChanges = undefined !;\n  for (let i = 0; i < values.length; i++) {\n    if (checkBinding(view, def, i, values[i])) {\n      changed = true;\n      changes = updateProp(view, providerData, def, i, values[i], changes);\n    }\n  }\n  if (changes) {\n    directive.ngOnChanges(changes);\n  }\n  if ((def.flags & NodeFlags.OnInit) &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingOnInit, def.nodeIndex)) {\n    directive.ngOnInit();\n  }\n  if (def.flags & NodeFlags.DoCheck) {\n    directive.ngDoCheck();\n  }\n  return changed;\n}\n\nfunction _createProviderInstance(view: ViewData, def: NodeDef): any {\n  // private services can see other private services\n  const allowPrivateServices = (def.flags & NodeFlags.PrivateProvider) > 0;\n  const providerDef = def.provider;\n  switch (def.flags & NodeFlags.Types) {\n    case NodeFlags.TypeClassProvider:\n      return createClass(\n          view, def.parent !, allowPrivateServices, providerDef !.value, providerDef !.deps);\n    case NodeFlags.TypeFactoryProvider:\n      return callFactory(\n          view, def.parent !, allowPrivateServices, providerDef !.value, providerDef !.deps);\n    case NodeFlags.TypeUseExistingProvider:\n      return resolveDep(view, def.parent !, allowPrivateServices, providerDef !.deps[0]);\n    case NodeFlags.TypeValueProvider:\n      return providerDef !.value;\n  }\n}\n\nfunction createClass(\n    view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, ctor: any, deps: DepDef[]): any {\n  const len = deps.length;\n  switch (len) {\n    case 0:\n      return new ctor();\n    case 1:\n      return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));\n    case 2:\n      return new ctor(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]));\n    case 3:\n      return new ctor(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]),\n          resolveDep(view, elDef, allowPrivateServices, deps[2]));\n    default:\n      const depValues = new Array(len);\n      for (let i = 0; i < len; i++) {\n        depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);\n      }\n      return new ctor(...depValues);\n  }\n}\n\nfunction callFactory(\n    view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, factory: any,\n    deps: DepDef[]): any {\n  const len = deps.length;\n  switch (len) {\n    case 0:\n      return factory();\n    case 1:\n      return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));\n    case 2:\n      return factory(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]));\n    case 3:\n      return factory(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]),\n          resolveDep(view, elDef, allowPrivateServices, deps[2]));\n    default:\n      const depValues = Array(len);\n      for (let i = 0; i < len; i++) {\n        depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);\n      }\n      return factory(...depValues);\n  }\n}\n\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nexport const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\nexport function resolveDep(\n    view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef,\n    notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n  if (depDef.flags & DepFlags.Value) {\n    return depDef.token;\n  }\n  const startView = view;\n  if (depDef.flags & DepFlags.Optional) {\n    notFoundValue = null;\n  }\n  const tokenKey = depDef.tokenKey;\n\n  if (tokenKey === ChangeDetectorRefTokenKey) {\n    // directives on the same element as a component should be able to control the change detector\n    // of that component as well.\n    allowPrivateServices = !!(elDef && elDef.element !.componentView);\n  }\n\n  if (elDef && (depDef.flags & DepFlags.SkipSelf)) {\n    allowPrivateServices = false;\n    elDef = elDef.parent !;\n  }\n\n  let searchView: ViewData|null = view;\n  while (searchView) {\n    if (elDef) {\n      switch (tokenKey) {\n        case RendererV1TokenKey: {\n          const compView = findCompView(searchView, elDef, allowPrivateServices);\n          return createRendererV1(compView);\n        }\n        case Renderer2TokenKey: {\n          const compView = findCompView(searchView, elDef, allowPrivateServices);\n          return compView.renderer;\n        }\n        case ElementRefTokenKey:\n          return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);\n        case ViewContainerRefTokenKey:\n          return asElementData(searchView, elDef.nodeIndex).viewContainer;\n        case TemplateRefTokenKey: {\n          if (elDef.element !.template) {\n            return asElementData(searchView, elDef.nodeIndex).template;\n          }\n          break;\n        }\n        case ChangeDetectorRefTokenKey: {\n          let cdView = findCompView(searchView, elDef, allowPrivateServices);\n          return createChangeDetectorRef(cdView);\n        }\n        case InjectorRefTokenKey:\n        case INJECTORRefTokenKey:\n          return createInjector(searchView, elDef);\n        default:\n          const providerDef =\n              (allowPrivateServices ? elDef.element !.allProviders :\n                                      elDef.element !.publicProviders) ![tokenKey];\n          if (providerDef) {\n            let providerData = asProviderData(searchView, providerDef.nodeIndex);\n            if (!providerData) {\n              providerData = {instance: _createProviderInstance(searchView, providerDef)};\n              searchView.nodes[providerDef.nodeIndex] = providerData as any;\n            }\n            return providerData.instance;\n          }\n      }\n    }\n\n    allowPrivateServices = isComponentView(searchView);\n    elDef = viewParentEl(searchView) !;\n    searchView = searchView.parent !;\n\n    if (depDef.flags & DepFlags.Self) {\n      searchView = null;\n    }\n  }\n\n  const value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);\n\n  if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n      notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n    // Return the value from the root element injector when\n    // - it provides it\n    //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n    // - the module injector should not be checked\n    //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n    return value;\n  }\n\n  return startView.root.ngModule.injector.get(depDef.token, notFoundValue);\n}\n\nfunction findCompView(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean) {\n  let compView: ViewData;\n  if (allowPrivateServices) {\n    compView = asElementData(view, elDef.nodeIndex).componentView;\n  } else {\n    compView = view;\n    while (compView.parent && !isComponentView(compView)) {\n      compView = compView.parent;\n    }\n  }\n  return compView;\n}\n\nfunction updateProp(\n    view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any,\n    changes: SimpleChanges): SimpleChanges {\n  if (def.flags & NodeFlags.Component) {\n    const compView = asElementData(view, def.parent !.nodeIndex).componentView;\n    if (compView.def.flags & ViewFlags.OnPush) {\n      compView.state |= ViewState.ChecksEnabled;\n    }\n  }\n  const binding = def.bindings[bindingIdx];\n  const propName = binding.name !;\n  // Note: This is still safe with Closure Compiler as\n  // the user passed in the property name as an object has to `providerDef`,\n  // so Closure Compiler will have renamed the property correctly already.\n  providerData.instance[propName] = value;\n  if (def.flags & NodeFlags.OnChanges) {\n    changes = changes || {};\n    const oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);\n    const binding = def.bindings[bindingIdx];\n    changes[binding.nonMinifiedName !] =\n        new SimpleChange(oldValue, value, (view.state & ViewState.FirstCheck) !== 0);\n  }\n  view.oldValues[def.bindingIndex + bindingIdx] = value;\n  return changes;\n}\n\n// This function calls the ngAfterContentCheck, ngAfterContentInit,\n// ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node\n// flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are\n// called during a pre-order traversal of the view tree (that is calling the\n// parent hooks before the child hooks) these events are sent in using a\n// post-order traversal of the tree (children before parents). This changes the\n// meaning of initIndex in the view state. For ngOnInit, initIndex tracks the\n// expected nodeIndex which a ngOnInit should be called. When sending\n// ngAfterContentInit and ngAfterViewInit it is the expected count of\n// ngAfterContentInit or ngAfterViewInit methods that have been called. This\n// ensure that despite being called recursively or after picking up after an\n// exception, the ngAfterContentInit or ngAfterViewInit will be called on the\n// correct nodes. Consider for example, the following (where E is an element\n// and D is a directive)\n//  Tree:       pre-order index  post-order index\n//    E1        0                6\n//      E2      1                1\n//       D3     2                0\n//      E4      3                5\n//       E5     4                4\n//        E6    5                2\n//        E7    6                3\n// As can be seen, the post-order index has an unclear relationship to the\n// pre-order index (postOrderIndex === preOrderIndex - parentCount +\n// childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit\n// are stable (will be the same for the same view regardless of exceptions or\n// recursion) we just need to count them which will roughly correspond to the\n// post-order index (it skips elements and directives that do not have\n// lifecycle hooks).\n//\n// For example, if an exception is raised in the E6.onAfterViewInit() the\n// initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to\n// initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will\n// not have their ngAfterViewInit() called but, starting with E7, the rest of\n// the view will begin getting ngAfterViewInit() called until a check and\n// pass is complete.\n//\n// This algorthim also handles recursion. Consider if E4's ngAfterViewInit()\n// indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected\n// initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.\n// D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.\n// When the recursion returns the initIndex will be 7 so E1 is skipped as it\n// has already been called in the recursively called checkAnUpdateView().\nexport function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags) {\n  if (!(view.def.nodeFlags & lifecycles)) {\n    return;\n  }\n  const nodes = view.def.nodes;\n  let initIndex = 0;\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeDef = nodes[i];\n    let parent = nodeDef.parent;\n    if (!parent && nodeDef.flags & lifecycles) {\n      // matching root node (e.g. a pipe)\n      callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\n    }\n    if ((nodeDef.childFlags & lifecycles) === 0) {\n      // no child matches one of the lifecycles\n      i += nodeDef.childCount;\n    }\n    while (parent && (parent.flags & NodeFlags.TypeElement) &&\n           i === parent.nodeIndex + parent.childCount) {\n      // last child of an element\n      if (parent.directChildFlags & lifecycles) {\n        initIndex = callElementProvidersLifecycles(view, parent, lifecycles, initIndex);\n      }\n      parent = parent.parent;\n    }\n  }\n}\n\nfunction callElementProvidersLifecycles(\n    view: ViewData, elDef: NodeDef, lifecycles: NodeFlags, initIndex: number): number {\n  for (let i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {\n    const nodeDef = view.def.nodes[i];\n    if (nodeDef.flags & lifecycles) {\n      callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\n    }\n    // only visit direct children\n    i += nodeDef.childCount;\n  }\n  return initIndex;\n}\n\nfunction callProviderLifecycles(\n    view: ViewData, index: number, lifecycles: NodeFlags, initIndex: number) {\n  const providerData = asProviderData(view, index);\n  if (!providerData) {\n    return;\n  }\n  const provider = providerData.instance;\n  if (!provider) {\n    return;\n  }\n  Services.setCurrentNode(view, index);\n  if (lifecycles & NodeFlags.AfterContentInit &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingAfterContentInit, initIndex)) {\n    provider.ngAfterContentInit();\n  }\n  if (lifecycles & NodeFlags.AfterContentChecked) {\n    provider.ngAfterContentChecked();\n  }\n  if (lifecycles & NodeFlags.AfterViewInit &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingAfterViewInit, initIndex)) {\n    provider.ngAfterViewInit();\n  }\n  if (lifecycles & NodeFlags.AfterViewChecked) {\n    provider.ngAfterViewChecked();\n  }\n  if (lifecycles & NodeFlags.OnDestroy) {\n    provider.ngOnDestroy();\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementRef} from '../linker/element_ref';\nimport {QueryList} from '../linker/query_list';\n\nimport {NodeDef, NodeFlags, QueryBindingDef, QueryBindingType, QueryDef, QueryValueType, ViewData, asElementData, asProviderData, asQueryList} from './types';\nimport {declaredViewContainer, filterQueryId, isEmbeddedView} from './util';\n\nexport function queryDef(\n    flags: NodeFlags, id: number, bindings: {[propName: string]: QueryBindingType}): NodeDef {\n  let bindingDefs: QueryBindingDef[] = [];\n  for (let propName in bindings) {\n    const bindingType = bindings[propName];\n    bindingDefs.push({propName, bindingType});\n  }\n\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    // TODO(vicb): check\n    checkIndex: -1, flags,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0,\n    ngContentIndex: -1,\n    matchedQueries: {},\n    matchedQueryIds: 0,\n    references: {},\n    childCount: 0,\n    bindings: [],\n    bindingFlags: 0,\n    outputs: [],\n    element: null,\n    provider: null,\n    text: null,\n    query: {id, filterId: filterQueryId(id), bindings: bindingDefs},\n    ngContent: null\n  };\n}\n\nexport function createQuery(): QueryList<any> {\n  return new QueryList();\n}\n\nexport function dirtyParentQueries(view: ViewData) {\n  const queryIds = view.def.nodeMatchedQueries;\n  while (view.parent && isEmbeddedView(view)) {\n    let tplDef = view.parentNodeDef !;\n    view = view.parent;\n    // content queries\n    const end = tplDef.nodeIndex + tplDef.childCount;\n    for (let i = 0; i <= end; i++) {\n      const nodeDef = view.def.nodes[i];\n      if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&\n          (nodeDef.flags & NodeFlags.DynamicQuery) &&\n          (nodeDef.query !.filterId & queryIds) === nodeDef.query !.filterId) {\n        asQueryList(view, i).setDirty();\n      }\n      if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef.childCount < tplDef.nodeIndex) ||\n          !(nodeDef.childFlags & NodeFlags.TypeContentQuery) ||\n          !(nodeDef.childFlags & NodeFlags.DynamicQuery)) {\n        // skip elements that don't contain the template element or no query.\n        i += nodeDef.childCount;\n      }\n    }\n  }\n\n  // view queries\n  if (view.def.nodeFlags & NodeFlags.TypeViewQuery) {\n    for (let i = 0; i < view.def.nodes.length; i++) {\n      const nodeDef = view.def.nodes[i];\n      if ((nodeDef.flags & NodeFlags.TypeViewQuery) && (nodeDef.flags & NodeFlags.DynamicQuery)) {\n        asQueryList(view, i).setDirty();\n      }\n      // only visit the root nodes\n      i += nodeDef.childCount;\n    }\n  }\n}\n\nexport function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef) {\n  const queryList = asQueryList(view, nodeDef.nodeIndex);\n  if (!queryList.dirty) {\n    return;\n  }\n  let directiveInstance: any;\n  let newValues: any[] = undefined !;\n  if (nodeDef.flags & NodeFlags.TypeContentQuery) {\n    const elementDef = nodeDef.parent !.parent !;\n    newValues = calcQueryValues(\n        view, elementDef.nodeIndex, elementDef.nodeIndex + elementDef.childCount, nodeDef.query !,\n        []);\n    directiveInstance = asProviderData(view, nodeDef.parent !.nodeIndex).instance;\n  } else if (nodeDef.flags & NodeFlags.TypeViewQuery) {\n    newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, nodeDef.query !, []);\n    directiveInstance = view.component;\n  }\n  queryList.reset(newValues);\n  const bindings = nodeDef.query !.bindings;\n  let notify = false;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    let boundValue: any;\n    switch (binding.bindingType) {\n      case QueryBindingType.First:\n        boundValue = queryList.first;\n        break;\n      case QueryBindingType.All:\n        boundValue = queryList;\n        notify = true;\n        break;\n    }\n    directiveInstance[binding.propName] = boundValue;\n  }\n  if (notify) {\n    queryList.notifyOnChanges();\n  }\n}\n\nfunction calcQueryValues(\n    view: ViewData, startIndex: number, endIndex: number, queryDef: QueryDef,\n    values: any[]): any[] {\n  for (let i = startIndex; i <= endIndex; i++) {\n    const nodeDef = view.def.nodes[i];\n    const valueType = nodeDef.matchedQueries[queryDef.id];\n    if (valueType != null) {\n      values.push(getQueryValue(view, nodeDef, valueType));\n    }\n    if (nodeDef.flags & NodeFlags.TypeElement && nodeDef.element !.template &&\n        (nodeDef.element !.template !.nodeMatchedQueries & queryDef.filterId) ===\n            queryDef.filterId) {\n      const elementData = asElementData(view, i);\n      // check embedded views that were attached at the place of their template,\n      // but process child nodes first if some match the query (see issue #16568)\n      if ((nodeDef.childMatchedQueries & queryDef.filterId) === queryDef.filterId) {\n        calcQueryValues(view, i + 1, i + nodeDef.childCount, queryDef, values);\n        i += nodeDef.childCount;\n      }\n      if (nodeDef.flags & NodeFlags.EmbeddedViews) {\n        const embeddedViews = elementData.viewContainer !._embeddedViews;\n        for (let k = 0; k < embeddedViews.length; k++) {\n          const embeddedView = embeddedViews[k];\n          const dvc = declaredViewContainer(embeddedView);\n          if (dvc && dvc === elementData) {\n            calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);\n          }\n        }\n      }\n      const projectedViews = elementData.template._projectedViews;\n      if (projectedViews) {\n        for (let k = 0; k < projectedViews.length; k++) {\n          const projectedView = projectedViews[k];\n          calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);\n        }\n      }\n    }\n    if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {\n      // if no child matches the query, skip the children.\n      i += nodeDef.childCount;\n    }\n  }\n  return values;\n}\n\nexport function getQueryValue(\n    view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any {\n  if (queryValueType != null) {\n    // a match\n    switch (queryValueType) {\n      case QueryValueType.RenderElement:\n        return asElementData(view, nodeDef.nodeIndex).renderElement;\n      case QueryValueType.ElementRef:\n        return new ElementRef(asElementData(view, nodeDef.nodeIndex).renderElement);\n      case QueryValueType.TemplateRef:\n        return asElementData(view, nodeDef.nodeIndex).template;\n      case QueryValueType.ViewContainerRef:\n        return asElementData(view, nodeDef.nodeIndex).viewContainer;\n      case QueryValueType.Provider:\n        return asProviderData(view, nodeDef.nodeIndex).instance;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NodeDef, NodeFlags, ViewData} from './types';\nimport {RenderNodeAction, getParentRenderElement, visitProjectedRenderNodes} from './util';\n\nexport function ngContentDef(ngContentIndex: null | number, index: number): NodeDef {\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    checkIndex: -1,\n    flags: NodeFlags.TypeNgContent,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0,\n    matchedQueries: {},\n    matchedQueryIds: 0,\n    references: {}, ngContentIndex,\n    childCount: 0,\n    bindings: [],\n    bindingFlags: 0,\n    outputs: [],\n    element: null,\n    provider: null,\n    text: null,\n    query: null,\n    ngContent: {index}\n  };\n}\n\nexport function appendNgContent(view: ViewData, renderHost: any, def: NodeDef) {\n  const parentEl = getParentRenderElement(view, renderHost, def);\n  if (!parentEl) {\n    // Nothing to do if there is no parent element.\n    return;\n  }\n  const ngContentIndex = def.ngContent !.index;\n  visitProjectedRenderNodes(\n      view, ngContentIndex, RenderNodeAction.AppendChild, parentEl, null, undefined);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BindingDef, BindingFlags, NodeDef, NodeFlags, TextData, ViewData, asTextData} from './types';\nimport {checkAndUpdateBinding, getParentRenderElement} from './util';\n\nexport function textDef(\n    checkIndex: number, ngContentIndex: number | null, staticText: string[]): NodeDef {\n  const bindings: BindingDef[] = new Array(staticText.length - 1);\n  for (let i = 1; i < staticText.length; i++) {\n    bindings[i - 1] = {\n      flags: BindingFlags.TypeProperty,\n      name: null,\n      ns: null,\n      nonMinifiedName: null,\n      securityContext: null,\n      suffix: staticText[i],\n    };\n  }\n\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    checkIndex,\n    flags: NodeFlags.TypeText,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0,\n    matchedQueries: {},\n    matchedQueryIds: 0,\n    references: {}, ngContentIndex,\n    childCount: 0, bindings,\n    bindingFlags: BindingFlags.TypeProperty,\n    outputs: [],\n    element: null,\n    provider: null,\n    text: {prefix: staticText[0]},\n    query: null,\n    ngContent: null,\n  };\n}\n\nexport function createText(view: ViewData, renderHost: any, def: NodeDef): TextData {\n  let renderNode: any;\n  const renderer = view.renderer;\n  renderNode = renderer.createText(def.text !.prefix);\n  const parentEl = getParentRenderElement(view, renderHost, def);\n  if (parentEl) {\n    renderer.appendChild(parentEl, renderNode);\n  }\n  return {renderText: renderNode};\n}\n\nexport function checkAndUpdateTextInline(\n    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,\n    v7: any, v8: any, v9: any): boolean {\n  let changed = false;\n  const bindings = def.bindings;\n  const bindLen = bindings.length;\n  if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0)) changed = true;\n  if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1)) changed = true;\n  if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2)) changed = true;\n  if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3)) changed = true;\n  if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4)) changed = true;\n  if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5)) changed = true;\n  if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6)) changed = true;\n  if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7)) changed = true;\n  if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8)) changed = true;\n  if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9)) changed = true;\n\n  if (changed) {\n    let value = def.text !.prefix;\n    if (bindLen > 0) value += _addInterpolationPart(v0, bindings[0]);\n    if (bindLen > 1) value += _addInterpolationPart(v1, bindings[1]);\n    if (bindLen > 2) value += _addInterpolationPart(v2, bindings[2]);\n    if (bindLen > 3) value += _addInterpolationPart(v3, bindings[3]);\n    if (bindLen > 4) value += _addInterpolationPart(v4, bindings[4]);\n    if (bindLen > 5) value += _addInterpolationPart(v5, bindings[5]);\n    if (bindLen > 6) value += _addInterpolationPart(v6, bindings[6]);\n    if (bindLen > 7) value += _addInterpolationPart(v7, bindings[7]);\n    if (bindLen > 8) value += _addInterpolationPart(v8, bindings[8]);\n    if (bindLen > 9) value += _addInterpolationPart(v9, bindings[9]);\n    const renderNode = asTextData(view, def.nodeIndex).renderText;\n    view.renderer.setValue(renderNode, value);\n  }\n  return changed;\n}\n\nexport function checkAndUpdateTextDynamic(view: ViewData, def: NodeDef, values: any[]): boolean {\n  const bindings = def.bindings;\n  let changed = false;\n  for (let i = 0; i < values.length; i++) {\n    // Note: We need to loop over all values, so that\n    // the old values are updates as well!\n    if (checkAndUpdateBinding(view, def, i, values[i])) {\n      changed = true;\n    }\n  }\n  if (changed) {\n    let value = '';\n    for (let i = 0; i < values.length; i++) {\n      value = value + _addInterpolationPart(values[i], bindings[i]);\n    }\n    value = def.text !.prefix + value;\n    const renderNode = asTextData(view, def.nodeIndex).renderText;\n    view.renderer.setValue(renderNode, value);\n  }\n  return changed;\n}\n\nfunction _addInterpolationPart(value: any, binding: BindingDef): string {\n  const valueStr = value != null ? value.toString() : '';\n  return valueStr + binding.suffix;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Renderer2} from '../render/api';\n\nimport {checkAndUpdateElementDynamic, checkAndUpdateElementInline, createElement, listenToElementOutputs} from './element';\nimport {expressionChangedAfterItHasBeenCheckedError} from './errors';\nimport {appendNgContent} from './ng_content';\nimport {callLifecycleHooksChildrenFirst, checkAndUpdateDirectiveDynamic, checkAndUpdateDirectiveInline, createDirectiveInstance, createPipeInstance, createProviderInstance} from './provider';\nimport {checkAndUpdatePureExpressionDynamic, checkAndUpdatePureExpressionInline, createPureExpression} from './pure_expression';\nimport {checkAndUpdateQuery, createQuery} from './query';\nimport {createTemplateData, createViewContainerData} from './refs';\nimport {checkAndUpdateTextDynamic, checkAndUpdateTextInline, createText} from './text';\nimport {ArgumentType, CheckType, ElementData, NodeData, NodeDef, NodeFlags, ProviderData, RootData, Services, ViewData, ViewDefinition, ViewFlags, ViewHandleEventFn, ViewState, ViewUpdateFn, asElementData, asQueryList, asTextData, shiftInitState} from './types';\nimport {NOOP, checkBindingNoChanges, isComponentView, markParentViewsForCheckProjectedViews, resolveDefinition, tokenKey} from './util';\nimport {detachProjectedView} from './view_attach';\n\nexport function viewDef(\n    flags: ViewFlags, nodes: NodeDef[], updateDirectives?: null | ViewUpdateFn,\n    updateRenderer?: null | ViewUpdateFn): ViewDefinition {\n  // clone nodes and set auto calculated values\n  let viewBindingCount = 0;\n  let viewDisposableCount = 0;\n  let viewNodeFlags = 0;\n  let viewRootNodeFlags = 0;\n  let viewMatchedQueries = 0;\n  let currentParent: NodeDef|null = null;\n  let currentRenderParent: NodeDef|null = null;\n  let currentElementHasPublicProviders = false;\n  let currentElementHasPrivateProviders = false;\n  let lastRenderRootNode: NodeDef|null = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    node.nodeIndex = i;\n    node.parent = currentParent;\n    node.bindingIndex = viewBindingCount;\n    node.outputIndex = viewDisposableCount;\n    node.renderParent = currentRenderParent;\n\n    viewNodeFlags |= node.flags;\n    viewMatchedQueries |= node.matchedQueryIds;\n\n    if (node.element) {\n      const elDef = node.element;\n      elDef.publicProviders =\n          currentParent ? currentParent.element !.publicProviders : Object.create(null);\n      elDef.allProviders = elDef.publicProviders;\n      // Note: We assume that all providers of an element are before any child element!\n      currentElementHasPublicProviders = false;\n      currentElementHasPrivateProviders = false;\n\n      if (node.element.template) {\n        viewMatchedQueries |= node.element.template.nodeMatchedQueries;\n      }\n    }\n    validateNode(currentParent, node, nodes.length);\n\n\n    viewBindingCount += node.bindings.length;\n    viewDisposableCount += node.outputs.length;\n\n    if (!currentRenderParent && (node.flags & NodeFlags.CatRenderNode)) {\n      lastRenderRootNode = node;\n    }\n\n    if (node.flags & NodeFlags.CatProvider) {\n      if (!currentElementHasPublicProviders) {\n        currentElementHasPublicProviders = true;\n        // Use prototypical inheritance to not get O(n^2) complexity...\n        currentParent !.element !.publicProviders =\n            Object.create(currentParent !.element !.publicProviders);\n        currentParent !.element !.allProviders = currentParent !.element !.publicProviders;\n      }\n      const isPrivateService = (node.flags & NodeFlags.PrivateProvider) !== 0;\n      const isComponent = (node.flags & NodeFlags.Component) !== 0;\n      if (!isPrivateService || isComponent) {\n        currentParent !.element !.publicProviders ![tokenKey(node.provider !.token)] = node;\n      } else {\n        if (!currentElementHasPrivateProviders) {\n          currentElementHasPrivateProviders = true;\n          // Use prototypical inheritance to not get O(n^2) complexity...\n          currentParent !.element !.allProviders =\n              Object.create(currentParent !.element !.publicProviders);\n        }\n        currentParent !.element !.allProviders ![tokenKey(node.provider !.token)] = node;\n      }\n      if (isComponent) {\n        currentParent !.element !.componentProvider = node;\n      }\n    }\n\n    if (currentParent) {\n      currentParent.childFlags |= node.flags;\n      currentParent.directChildFlags |= node.flags;\n      currentParent.childMatchedQueries |= node.matchedQueryIds;\n      if (node.element && node.element.template) {\n        currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;\n      }\n    } else {\n      viewRootNodeFlags |= node.flags;\n    }\n\n    if (node.childCount > 0) {\n      currentParent = node;\n\n      if (!isNgContainer(node)) {\n        currentRenderParent = node;\n      }\n    } else {\n      // When the current node has no children, check if it is the last children of its parent.\n      // When it is, propagate the flags up.\n      // The loop is required because an element could be the last transitive children of several\n      // elements. We loop to either the root or the highest opened element (= with remaining\n      // children)\n      while (currentParent && i === currentParent.nodeIndex + currentParent.childCount) {\n        const newParent: NodeDef|null = currentParent.parent;\n        if (newParent) {\n          newParent.childFlags |= currentParent.childFlags;\n          newParent.childMatchedQueries |= currentParent.childMatchedQueries;\n        }\n        currentParent = newParent;\n        // We also need to update the render parent & account for ng-container\n        if (currentParent && isNgContainer(currentParent)) {\n          currentRenderParent = currentParent.renderParent;\n        } else {\n          currentRenderParent = currentParent;\n        }\n      }\n    }\n  }\n\n  const handleEvent: ViewHandleEventFn = (view, nodeIndex, eventName, event) =>\n      nodes[nodeIndex].element !.handleEvent !(view, eventName, event);\n\n  return {\n    // Will be filled later...\n    factory: null,\n    nodeFlags: viewNodeFlags,\n    rootNodeFlags: viewRootNodeFlags,\n    nodeMatchedQueries: viewMatchedQueries, flags,\n    nodes: nodes,\n    updateDirectives: updateDirectives || NOOP,\n    updateRenderer: updateRenderer || NOOP, handleEvent,\n    bindingCount: viewBindingCount,\n    outputCount: viewDisposableCount, lastRenderRootNode\n  };\n}\n\nfunction isNgContainer(node: NodeDef): boolean {\n  return (node.flags & NodeFlags.TypeElement) !== 0 && node.element !.name === null;\n}\n\nfunction validateNode(parent: NodeDef | null, node: NodeDef, nodeCount: number) {\n  const template = node.element && node.element.template;\n  if (template) {\n    if (!template.lastRenderRootNode) {\n      throw new Error(`Illegal State: Embedded templates without nodes are not allowed!`);\n    }\n    if (template.lastRenderRootNode &&\n        template.lastRenderRootNode.flags & NodeFlags.EmbeddedViews) {\n      throw new Error(\n          `Illegal State: Last root node of a template can't have embedded views, at index ${node.nodeIndex}!`);\n    }\n  }\n  if (node.flags & NodeFlags.CatProvider) {\n    const parentFlags = parent ? parent.flags : 0;\n    if ((parentFlags & NodeFlags.TypeElement) === 0) {\n      throw new Error(\n          `Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ${node.nodeIndex}!`);\n    }\n  }\n  if (node.query) {\n    if (node.flags & NodeFlags.TypeContentQuery &&\n        (!parent || (parent.flags & NodeFlags.TypeDirective) === 0)) {\n      throw new Error(\n          `Illegal State: Content Query nodes need to be children of directives, at index ${node.nodeIndex}!`);\n    }\n    if (node.flags & NodeFlags.TypeViewQuery && parent) {\n      throw new Error(\n          `Illegal State: View Query nodes have to be top level nodes, at index ${node.nodeIndex}!`);\n    }\n  }\n  if (node.childCount) {\n    const parentEnd = parent ? parent.nodeIndex + parent.childCount : nodeCount - 1;\n    if (node.nodeIndex <= parentEnd && node.nodeIndex + node.childCount > parentEnd) {\n      throw new Error(\n          `Illegal State: childCount of node leads outside of parent, at index ${node.nodeIndex}!`);\n    }\n  }\n}\n\nexport function createEmbeddedView(\n    parent: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData {\n  // embedded views are seen as siblings to the anchor, so we need\n  // to get the parent of the anchor and use it as parentIndex.\n  const view = createView(parent.root, parent.renderer, parent, anchorDef, viewDef);\n  initView(view, parent.component, context);\n  createViewNodes(view);\n  return view;\n}\n\nexport function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData {\n  const view = createView(root, root.renderer, null, null, def);\n  initView(view, context, context);\n  createViewNodes(view);\n  return view;\n}\n\nexport function createComponentView(\n    parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData {\n  const rendererType = nodeDef.element !.componentRendererType;\n  let compRenderer: Renderer2;\n  if (!rendererType) {\n    compRenderer = parentView.root.renderer;\n  } else {\n    compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);\n  }\n  return createView(\n      parentView.root, compRenderer, parentView, nodeDef.element !.componentProvider, viewDef);\n}\n\nfunction createView(\n    root: RootData, renderer: Renderer2, parent: ViewData | null, parentNodeDef: NodeDef | null,\n    def: ViewDefinition): ViewData {\n  const nodes: NodeData[] = new Array(def.nodes.length);\n  const disposables = def.outputCount ? new Array(def.outputCount) : null;\n  const view: ViewData = {\n    def,\n    parent,\n    viewContainerParent: null, parentNodeDef,\n    context: null,\n    component: null, nodes,\n    state: ViewState.CatInit, root, renderer,\n    oldValues: new Array(def.bindingCount), disposables,\n    initIndex: -1\n  };\n  return view;\n}\n\nfunction initView(view: ViewData, component: any, context: any) {\n  view.component = component;\n  view.context = context;\n}\n\nfunction createViewNodes(view: ViewData) {\n  let renderHost: any;\n  if (isComponentView(view)) {\n    const hostDef = view.parentNodeDef;\n    renderHost = asElementData(view.parent !, hostDef !.parent !.nodeIndex).renderElement;\n  }\n  const def = view.def;\n  const nodes = view.nodes;\n  for (let i = 0; i < def.nodes.length; i++) {\n    const nodeDef = def.nodes[i];\n    Services.setCurrentNode(view, i);\n    let nodeData: any;\n    switch (nodeDef.flags & NodeFlags.Types) {\n      case NodeFlags.TypeElement:\n        const el = createElement(view, renderHost, nodeDef) as any;\n        let componentView: ViewData = undefined !;\n        if (nodeDef.flags & NodeFlags.ComponentView) {\n          const compViewDef = resolveDefinition(nodeDef.element !.componentView !);\n          componentView = Services.createComponentView(view, nodeDef, compViewDef, el);\n        }\n        listenToElementOutputs(view, componentView, nodeDef, el);\n        nodeData = <ElementData>{\n          renderElement: el,\n          componentView,\n          viewContainer: null,\n          template: nodeDef.element !.template ? createTemplateData(view, nodeDef) : undefined\n        };\n        if (nodeDef.flags & NodeFlags.EmbeddedViews) {\n          nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);\n        }\n        break;\n      case NodeFlags.TypeText:\n        nodeData = createText(view, renderHost, nodeDef) as any;\n        break;\n      case NodeFlags.TypeClassProvider:\n      case NodeFlags.TypeFactoryProvider:\n      case NodeFlags.TypeUseExistingProvider:\n      case NodeFlags.TypeValueProvider: {\n        nodeData = nodes[i];\n        if (!nodeData && !(nodeDef.flags & NodeFlags.LazyProvider)) {\n          const instance = createProviderInstance(view, nodeDef);\n          nodeData = <ProviderData>{instance};\n        }\n        break;\n      }\n      case NodeFlags.TypePipe: {\n        const instance = createPipeInstance(view, nodeDef);\n        nodeData = <ProviderData>{instance};\n        break;\n      }\n      case NodeFlags.TypeDirective: {\n        nodeData = nodes[i];\n        if (!nodeData) {\n          const instance = createDirectiveInstance(view, nodeDef);\n          nodeData = <ProviderData>{instance};\n        }\n        if (nodeDef.flags & NodeFlags.Component) {\n          const compView = asElementData(view, nodeDef.parent !.nodeIndex).componentView;\n          initView(compView, nodeData.instance, nodeData.instance);\n        }\n        break;\n      }\n      case NodeFlags.TypePureArray:\n      case NodeFlags.TypePureObject:\n      case NodeFlags.TypePurePipe:\n        nodeData = createPureExpression(view, nodeDef) as any;\n        break;\n      case NodeFlags.TypeContentQuery:\n      case NodeFlags.TypeViewQuery:\n        nodeData = createQuery() as any;\n        break;\n      case NodeFlags.TypeNgContent:\n        appendNgContent(view, renderHost, nodeDef);\n        // no runtime data needed for NgContent...\n        nodeData = undefined;\n        break;\n    }\n    nodes[i] = nodeData;\n  }\n  // Create the ViewData.nodes of component views after we created everything else,\n  // so that e.g. ng-content works\n  execComponentViewsAction(view, ViewAction.CreateViewNodes);\n\n  // fill static content and view queries\n  execQueriesAction(\n      view, NodeFlags.TypeContentQuery | NodeFlags.TypeViewQuery, NodeFlags.StaticQuery,\n      CheckType.CheckAndUpdate);\n}\n\nexport function checkNoChangesView(view: ViewData) {\n  markProjectedViewsForCheck(view);\n  Services.updateDirectives(view, CheckType.CheckNoChanges);\n  execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);\n  Services.updateRenderer(view, CheckType.CheckNoChanges);\n  execComponentViewsAction(view, ViewAction.CheckNoChanges);\n  // Note: We don't check queries for changes as we didn't do this in v2.x.\n  // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.\n  view.state &= ~(ViewState.CheckProjectedViews | ViewState.CheckProjectedView);\n}\n\nexport function checkAndUpdateView(view: ViewData) {\n  if (view.state & ViewState.BeforeFirstCheck) {\n    view.state &= ~ViewState.BeforeFirstCheck;\n    view.state |= ViewState.FirstCheck;\n  } else {\n    view.state &= ~ViewState.FirstCheck;\n  }\n  shiftInitState(view, ViewState.InitState_BeforeInit, ViewState.InitState_CallingOnInit);\n  markProjectedViewsForCheck(view);\n  Services.updateDirectives(view, CheckType.CheckAndUpdate);\n  execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);\n  execQueriesAction(\n      view, NodeFlags.TypeContentQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate);\n  let callInit = shiftInitState(\n      view, ViewState.InitState_CallingOnInit, ViewState.InitState_CallingAfterContentInit);\n  callLifecycleHooksChildrenFirst(\n      view, NodeFlags.AfterContentChecked | (callInit ? NodeFlags.AfterContentInit : 0));\n\n  Services.updateRenderer(view, CheckType.CheckAndUpdate);\n\n  execComponentViewsAction(view, ViewAction.CheckAndUpdate);\n  execQueriesAction(\n      view, NodeFlags.TypeViewQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate);\n  callInit = shiftInitState(\n      view, ViewState.InitState_CallingAfterContentInit, ViewState.InitState_CallingAfterViewInit);\n  callLifecycleHooksChildrenFirst(\n      view, NodeFlags.AfterViewChecked | (callInit ? NodeFlags.AfterViewInit : 0));\n\n  if (view.def.flags & ViewFlags.OnPush) {\n    view.state &= ~ViewState.ChecksEnabled;\n  }\n  view.state &= ~(ViewState.CheckProjectedViews | ViewState.CheckProjectedView);\n  shiftInitState(view, ViewState.InitState_CallingAfterViewInit, ViewState.InitState_AfterInit);\n}\n\nexport function checkAndUpdateNode(\n    view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any,\n    v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): boolean {\n  if (argStyle === ArgumentType.Inline) {\n    return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n  } else {\n    return checkAndUpdateNodeDynamic(view, nodeDef, v0);\n  }\n}\n\nfunction markProjectedViewsForCheck(view: ViewData) {\n  const def = view.def;\n  if (!(def.nodeFlags & NodeFlags.ProjectedTemplate)) {\n    return;\n  }\n  for (let i = 0; i < def.nodes.length; i++) {\n    const nodeDef = def.nodes[i];\n    if (nodeDef.flags & NodeFlags.ProjectedTemplate) {\n      const projectedViews = asElementData(view, i).template._projectedViews;\n      if (projectedViews) {\n        for (let i = 0; i < projectedViews.length; i++) {\n          const projectedView = projectedViews[i];\n          projectedView.state |= ViewState.CheckProjectedView;\n          markParentViewsForCheckProjectedViews(projectedView, view);\n        }\n      }\n    } else if ((nodeDef.childFlags & NodeFlags.ProjectedTemplate) === 0) {\n      // a parent with leafs\n      // no child is a component,\n      // then skip the children\n      i += nodeDef.childCount;\n    }\n  }\n}\n\nfunction checkAndUpdateNodeInline(\n    view: ViewData, nodeDef: NodeDef, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any,\n    v6?: any, v7?: any, v8?: any, v9?: any): boolean {\n  switch (nodeDef.flags & NodeFlags.Types) {\n    case NodeFlags.TypeElement:\n      return checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n    case NodeFlags.TypeText:\n      return checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n    case NodeFlags.TypeDirective:\n      return checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n    case NodeFlags.TypePureArray:\n    case NodeFlags.TypePureObject:\n    case NodeFlags.TypePurePipe:\n      return checkAndUpdatePureExpressionInline(\n          view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n    default:\n      throw 'unreachable';\n  }\n}\n\nfunction checkAndUpdateNodeDynamic(view: ViewData, nodeDef: NodeDef, values: any[]): boolean {\n  switch (nodeDef.flags & NodeFlags.Types) {\n    case NodeFlags.TypeElement:\n      return checkAndUpdateElementDynamic(view, nodeDef, values);\n    case NodeFlags.TypeText:\n      return checkAndUpdateTextDynamic(view, nodeDef, values);\n    case NodeFlags.TypeDirective:\n      return checkAndUpdateDirectiveDynamic(view, nodeDef, values);\n    case NodeFlags.TypePureArray:\n    case NodeFlags.TypePureObject:\n    case NodeFlags.TypePurePipe:\n      return checkAndUpdatePureExpressionDynamic(view, nodeDef, values);\n    default:\n      throw 'unreachable';\n  }\n}\n\nexport function checkNoChangesNode(\n    view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any,\n    v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any {\n  if (argStyle === ArgumentType.Inline) {\n    checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n  } else {\n    checkNoChangesNodeDynamic(view, nodeDef, v0);\n  }\n  // Returning false is ok here as we would have thrown in case of a change.\n  return false;\n}\n\nfunction checkNoChangesNodeInline(\n    view: ViewData, nodeDef: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,\n    v7: any, v8: any, v9: any): void {\n  const bindLen = nodeDef.bindings.length;\n  if (bindLen > 0) checkBindingNoChanges(view, nodeDef, 0, v0);\n  if (bindLen > 1) checkBindingNoChanges(view, nodeDef, 1, v1);\n  if (bindLen > 2) checkBindingNoChanges(view, nodeDef, 2, v2);\n  if (bindLen > 3) checkBindingNoChanges(view, nodeDef, 3, v3);\n  if (bindLen > 4) checkBindingNoChanges(view, nodeDef, 4, v4);\n  if (bindLen > 5) checkBindingNoChanges(view, nodeDef, 5, v5);\n  if (bindLen > 6) checkBindingNoChanges(view, nodeDef, 6, v6);\n  if (bindLen > 7) checkBindingNoChanges(view, nodeDef, 7, v7);\n  if (bindLen > 8) checkBindingNoChanges(view, nodeDef, 8, v8);\n  if (bindLen > 9) checkBindingNoChanges(view, nodeDef, 9, v9);\n}\n\nfunction checkNoChangesNodeDynamic(view: ViewData, nodeDef: NodeDef, values: any[]): void {\n  for (let i = 0; i < values.length; i++) {\n    checkBindingNoChanges(view, nodeDef, i, values[i]);\n  }\n}\n\n/**\n * Workaround https://github.com/angular/tsickle/issues/497\n * @suppress {misplacedTypeAnnotation}\n */\nfunction checkNoChangesQuery(view: ViewData, nodeDef: NodeDef) {\n  const queryList = asQueryList(view, nodeDef.nodeIndex);\n  if (queryList.dirty) {\n    throw expressionChangedAfterItHasBeenCheckedError(\n        Services.createDebugContext(view, nodeDef.nodeIndex),\n        `Query ${nodeDef.query!.id} not dirty`, `Query ${nodeDef.query!.id} dirty`,\n        (view.state & ViewState.BeforeFirstCheck) !== 0);\n  }\n}\n\nexport function destroyView(view: ViewData) {\n  if (view.state & ViewState.Destroyed) {\n    return;\n  }\n  execEmbeddedViewsAction(view, ViewAction.Destroy);\n  execComponentViewsAction(view, ViewAction.Destroy);\n  callLifecycleHooksChildrenFirst(view, NodeFlags.OnDestroy);\n  if (view.disposables) {\n    for (let i = 0; i < view.disposables.length; i++) {\n      view.disposables[i]();\n    }\n  }\n  detachProjectedView(view);\n  if (view.renderer.destroyNode) {\n    destroyViewNodes(view);\n  }\n  if (isComponentView(view)) {\n    view.renderer.destroy();\n  }\n  view.state |= ViewState.Destroyed;\n}\n\nfunction destroyViewNodes(view: ViewData) {\n  const len = view.def.nodes.length;\n  for (let i = 0; i < len; i++) {\n    const def = view.def.nodes[i];\n    if (def.flags & NodeFlags.TypeElement) {\n      view.renderer.destroyNode !(asElementData(view, i).renderElement);\n    } else if (def.flags & NodeFlags.TypeText) {\n      view.renderer.destroyNode !(asTextData(view, i).renderText);\n    } else if (def.flags & NodeFlags.TypeContentQuery || def.flags & NodeFlags.TypeViewQuery) {\n      asQueryList(view, i).destroy();\n    }\n  }\n}\n\nenum ViewAction {\n  CreateViewNodes,\n  CheckNoChanges,\n  CheckNoChangesProjectedViews,\n  CheckAndUpdate,\n  CheckAndUpdateProjectedViews,\n  Destroy\n}\n\nfunction execComponentViewsAction(view: ViewData, action: ViewAction) {\n  const def = view.def;\n  if (!(def.nodeFlags & NodeFlags.ComponentView)) {\n    return;\n  }\n  for (let i = 0; i < def.nodes.length; i++) {\n    const nodeDef = def.nodes[i];\n    if (nodeDef.flags & NodeFlags.ComponentView) {\n      // a leaf\n      callViewAction(asElementData(view, i).componentView, action);\n    } else if ((nodeDef.childFlags & NodeFlags.ComponentView) === 0) {\n      // a parent with leafs\n      // no child is a component,\n      // then skip the children\n      i += nodeDef.childCount;\n    }\n  }\n}\n\nfunction execEmbeddedViewsAction(view: ViewData, action: ViewAction) {\n  const def = view.def;\n  if (!(def.nodeFlags & NodeFlags.EmbeddedViews)) {\n    return;\n  }\n  for (let i = 0; i < def.nodes.length; i++) {\n    const nodeDef = def.nodes[i];\n    if (nodeDef.flags & NodeFlags.EmbeddedViews) {\n      // a leaf\n      const embeddedViews = asElementData(view, i).viewContainer !._embeddedViews;\n      for (let k = 0; k < embeddedViews.length; k++) {\n        callViewAction(embeddedViews[k], action);\n      }\n    } else if ((nodeDef.childFlags & NodeFlags.EmbeddedViews) === 0) {\n      // a parent with leafs\n      // no child is a component,\n      // then skip the children\n      i += nodeDef.childCount;\n    }\n  }\n}\n\nfunction callViewAction(view: ViewData, action: ViewAction) {\n  const viewState = view.state;\n  switch (action) {\n    case ViewAction.CheckNoChanges:\n      if ((viewState & ViewState.Destroyed) === 0) {\n        if ((viewState & ViewState.CatDetectChanges) === ViewState.CatDetectChanges) {\n          checkNoChangesView(view);\n        } else if (viewState & ViewState.CheckProjectedViews) {\n          execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);\n        }\n      }\n      break;\n    case ViewAction.CheckNoChangesProjectedViews:\n      if ((viewState & ViewState.Destroyed) === 0) {\n        if (viewState & ViewState.CheckProjectedView) {\n          checkNoChangesView(view);\n        } else if (viewState & ViewState.CheckProjectedViews) {\n          execProjectedViewsAction(view, action);\n        }\n      }\n      break;\n    case ViewAction.CheckAndUpdate:\n      if ((viewState & ViewState.Destroyed) === 0) {\n        if ((viewState & ViewState.CatDetectChanges) === ViewState.CatDetectChanges) {\n          checkAndUpdateView(view);\n        } else if (viewState & ViewState.CheckProjectedViews) {\n          execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);\n        }\n      }\n      break;\n    case ViewAction.CheckAndUpdateProjectedViews:\n      if ((viewState & ViewState.Destroyed) === 0) {\n        if (viewState & ViewState.CheckProjectedView) {\n          checkAndUpdateView(view);\n        } else if (viewState & ViewState.CheckProjectedViews) {\n          execProjectedViewsAction(view, action);\n        }\n      }\n      break;\n    case ViewAction.Destroy:\n      // Note: destroyView recurses over all views,\n      // so we don't need to special case projected views here.\n      destroyView(view);\n      break;\n    case ViewAction.CreateViewNodes:\n      createViewNodes(view);\n      break;\n  }\n}\n\nfunction execProjectedViewsAction(view: ViewData, action: ViewAction) {\n  execEmbeddedViewsAction(view, action);\n  execComponentViewsAction(view, action);\n}\n\nfunction execQueriesAction(\n    view: ViewData, queryFlags: NodeFlags, staticDynamicQueryFlag: NodeFlags,\n    checkType: CheckType) {\n  if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {\n    return;\n  }\n  const nodeCount = view.def.nodes.length;\n  for (let i = 0; i < nodeCount; i++) {\n    const nodeDef = view.def.nodes[i];\n    if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {\n      Services.setCurrentNode(view, nodeDef.nodeIndex);\n      switch (checkType) {\n        case CheckType.CheckAndUpdate:\n          checkAndUpdateQuery(view, nodeDef);\n          break;\n        case CheckType.CheckNoChanges:\n          checkNoChangesQuery(view, nodeDef);\n          break;\n      }\n    }\n    if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {\n      // no child has a matching query\n      // then skip the children\n      i += nodeDef.childCount;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BindingDef, BindingFlags, NodeDef, NodeFlags, PureExpressionData, ViewData, asPureExpressionData} from './types';\nimport {calcBindingFlags, checkAndUpdateBinding} from './util';\n\nexport function purePipeDef(checkIndex: number, argCount: number): NodeDef {\n  // argCount + 1 to include the pipe as first arg\n  return _pureExpressionDef(NodeFlags.TypePurePipe, checkIndex, new Array(argCount + 1));\n}\n\nexport function pureArrayDef(checkIndex: number, argCount: number): NodeDef {\n  return _pureExpressionDef(NodeFlags.TypePureArray, checkIndex, new Array(argCount));\n}\n\nexport function pureObjectDef(checkIndex: number, propToIndex: {[p: string]: number}): NodeDef {\n  const keys = Object.keys(propToIndex);\n  const nbKeys = keys.length;\n  const propertyNames = new Array(nbKeys);\n  for (let i = 0; i < nbKeys; i++) {\n    const key = keys[i];\n    const index = propToIndex[key];\n    propertyNames[index] = key;\n  }\n\n  return _pureExpressionDef(NodeFlags.TypePureObject, checkIndex, propertyNames);\n}\n\nfunction _pureExpressionDef(\n    flags: NodeFlags, checkIndex: number, propertyNames: string[]): NodeDef {\n  const bindings: BindingDef[] = new Array(propertyNames.length);\n  for (let i = 0; i < propertyNames.length; i++) {\n    const prop = propertyNames[i];\n    bindings[i] = {\n      flags: BindingFlags.TypeProperty,\n      name: prop,\n      ns: null,\n      nonMinifiedName: prop,\n      securityContext: null,\n      suffix: null\n    };\n  }\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    checkIndex,\n    flags,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0,\n    matchedQueries: {},\n    matchedQueryIds: 0,\n    references: {},\n    ngContentIndex: -1,\n    childCount: 0, bindings,\n    bindingFlags: calcBindingFlags(bindings),\n    outputs: [],\n    element: null,\n    provider: null,\n    text: null,\n    query: null,\n    ngContent: null\n  };\n}\n\nexport function createPureExpression(view: ViewData, def: NodeDef): PureExpressionData {\n  return {value: undefined};\n}\n\nexport function checkAndUpdatePureExpressionInline(\n    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,\n    v7: any, v8: any, v9: any): boolean {\n  const bindings = def.bindings;\n  let changed = false;\n  const bindLen = bindings.length;\n  if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0)) changed = true;\n  if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1)) changed = true;\n  if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2)) changed = true;\n  if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3)) changed = true;\n  if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4)) changed = true;\n  if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5)) changed = true;\n  if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6)) changed = true;\n  if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7)) changed = true;\n  if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8)) changed = true;\n  if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9)) changed = true;\n\n  if (changed) {\n    const data = asPureExpressionData(view, def.nodeIndex);\n    let value: any;\n    switch (def.flags & NodeFlags.Types) {\n      case NodeFlags.TypePureArray:\n        value = new Array(bindings.length);\n        if (bindLen > 0) value[0] = v0;\n        if (bindLen > 1) value[1] = v1;\n        if (bindLen > 2) value[2] = v2;\n        if (bindLen > 3) value[3] = v3;\n        if (bindLen > 4) value[4] = v4;\n        if (bindLen > 5) value[5] = v5;\n        if (bindLen > 6) value[6] = v6;\n        if (bindLen > 7) value[7] = v7;\n        if (bindLen > 8) value[8] = v8;\n        if (bindLen > 9) value[9] = v9;\n        break;\n      case NodeFlags.TypePureObject:\n        value = {};\n        if (bindLen > 0) value[bindings[0].name !] = v0;\n        if (bindLen > 1) value[bindings[1].name !] = v1;\n        if (bindLen > 2) value[bindings[2].name !] = v2;\n        if (bindLen > 3) value[bindings[3].name !] = v3;\n        if (bindLen > 4) value[bindings[4].name !] = v4;\n        if (bindLen > 5) value[bindings[5].name !] = v5;\n        if (bindLen > 6) value[bindings[6].name !] = v6;\n        if (bindLen > 7) value[bindings[7].name !] = v7;\n        if (bindLen > 8) value[bindings[8].name !] = v8;\n        if (bindLen > 9) value[bindings[9].name !] = v9;\n        break;\n      case NodeFlags.TypePurePipe:\n        const pipe = v0;\n        switch (bindLen) {\n          case 1:\n            value = pipe.transform(v0);\n            break;\n          case 2:\n            value = pipe.transform(v1);\n            break;\n          case 3:\n            value = pipe.transform(v1, v2);\n            break;\n          case 4:\n            value = pipe.transform(v1, v2, v3);\n            break;\n          case 5:\n            value = pipe.transform(v1, v2, v3, v4);\n            break;\n          case 6:\n            value = pipe.transform(v1, v2, v3, v4, v5);\n            break;\n          case 7:\n            value = pipe.transform(v1, v2, v3, v4, v5, v6);\n            break;\n          case 8:\n            value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);\n            break;\n          case 9:\n            value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);\n            break;\n          case 10:\n            value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);\n            break;\n        }\n        break;\n    }\n    data.value = value;\n  }\n  return changed;\n}\n\nexport function checkAndUpdatePureExpressionDynamic(\n    view: ViewData, def: NodeDef, values: any[]): boolean {\n  const bindings = def.bindings;\n  let changed = false;\n  for (let i = 0; i < values.length; i++) {\n    // Note: We need to loop over all values, so that\n    // the old values are updates as well!\n    if (checkAndUpdateBinding(view, def, i, values[i])) {\n      changed = true;\n    }\n  }\n  if (changed) {\n    const data = asPureExpressionData(view, def.nodeIndex);\n    let value: any;\n    switch (def.flags & NodeFlags.Types) {\n      case NodeFlags.TypePureArray:\n        value = values;\n        break;\n      case NodeFlags.TypePureObject:\n        value = {};\n        for (let i = 0; i < values.length; i++) {\n          value[bindings[i].name !] = values[i];\n        }\n        break;\n      case NodeFlags.TypePurePipe:\n        const pipe = values[0];\n        const params = values.slice(1);\n        value = (<any>pipe.transform)(...params);\n        break;\n    }\n    data.value = value;\n  }\n  return changed;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DebugElement__PRE_R3__, DebugNode__PRE_R3__, EventListener, getDebugNode, indexDebugNode, removeDebugNodeFromIndex} from '../debug/debug_node';\nimport {Injector} from '../di';\nimport {InjectableDef, getInjectableDef} from '../di/defs';\nimport {InjectableType} from '../di/injectable';\nimport {ErrorHandler} from '../error_handler';\nimport {isDevMode} from '../is_dev_mode';\nimport {ComponentFactory} from '../linker/component_factory';\nimport {NgModuleRef} from '../linker/ng_module_factory';\nimport {Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2} from '../render/api';\nimport {Sanitizer} from '../sanitization/security';\nimport {Type} from '../type';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../util/ng_reflect';\nimport {isViewDebugError, viewDestroyedError, viewWrappedDebugError} from './errors';\nimport {resolveDep} from './provider';\nimport {dirtyParentQueries, getQueryValue} from './query';\nimport {createInjector, createNgModuleRef, getComponentViewDefinitionFactory} from './refs';\nimport {ArgumentType, BindingFlags, CheckType, DebugContext, ElementData, NgModuleDefinition, NodeDef, NodeFlags, NodeLogger, ProviderOverride, RootData, Services, ViewData, ViewDefinition, ViewState, asElementData, asPureExpressionData} from './types';\nimport {NOOP, isComponentView, renderNode, resolveDefinition, splitDepsDsl, tokenKey, viewParentEl} from './util';\nimport {checkAndUpdateNode, checkAndUpdateView, checkNoChangesNode, checkNoChangesView, createComponentView, createEmbeddedView, createRootView, destroyView} from './view';\n\n\nlet initialized = false;\n\nexport function initServicesIfNeeded() {\n  if (initialized) {\n    return;\n  }\n  initialized = true;\n  const services = isDevMode() ? createDebugServices() : createProdServices();\n  Services.setCurrentNode = services.setCurrentNode;\n  Services.createRootView = services.createRootView;\n  Services.createEmbeddedView = services.createEmbeddedView;\n  Services.createComponentView = services.createComponentView;\n  Services.createNgModuleRef = services.createNgModuleRef;\n  Services.overrideProvider = services.overrideProvider;\n  Services.overrideComponentView = services.overrideComponentView;\n  Services.clearOverrides = services.clearOverrides;\n  Services.checkAndUpdateView = services.checkAndUpdateView;\n  Services.checkNoChangesView = services.checkNoChangesView;\n  Services.destroyView = services.destroyView;\n  Services.resolveDep = resolveDep;\n  Services.createDebugContext = services.createDebugContext;\n  Services.handleEvent = services.handleEvent;\n  Services.updateDirectives = services.updateDirectives;\n  Services.updateRenderer = services.updateRenderer;\n  Services.dirtyParentQueries = dirtyParentQueries;\n}\n\nfunction createProdServices() {\n  return {\n    setCurrentNode: () => {},\n    createRootView: createProdRootView,\n    createEmbeddedView: createEmbeddedView,\n    createComponentView: createComponentView,\n    createNgModuleRef: createNgModuleRef,\n    overrideProvider: NOOP,\n    overrideComponentView: NOOP,\n    clearOverrides: NOOP,\n    checkAndUpdateView: checkAndUpdateView,\n    checkNoChangesView: checkNoChangesView,\n    destroyView: destroyView,\n    createDebugContext: (view: ViewData, nodeIndex: number) => new DebugContext_(view, nodeIndex),\n    handleEvent: (view: ViewData, nodeIndex: number, eventName: string, event: any) =>\n                     view.def.handleEvent(view, nodeIndex, eventName, event),\n    updateDirectives: (view: ViewData, checkType: CheckType) => view.def.updateDirectives(\n                          checkType === CheckType.CheckAndUpdate ? prodCheckAndUpdateNode :\n                                                                   prodCheckNoChangesNode,\n                          view),\n    updateRenderer: (view: ViewData, checkType: CheckType) => view.def.updateRenderer(\n                        checkType === CheckType.CheckAndUpdate ? prodCheckAndUpdateNode :\n                                                                 prodCheckNoChangesNode,\n                        view),\n  };\n}\n\nfunction createDebugServices() {\n  return {\n    setCurrentNode: debugSetCurrentNode,\n    createRootView: debugCreateRootView,\n    createEmbeddedView: debugCreateEmbeddedView,\n    createComponentView: debugCreateComponentView,\n    createNgModuleRef: debugCreateNgModuleRef,\n    overrideProvider: debugOverrideProvider,\n    overrideComponentView: debugOverrideComponentView,\n    clearOverrides: debugClearOverrides,\n    checkAndUpdateView: debugCheckAndUpdateView,\n    checkNoChangesView: debugCheckNoChangesView,\n    destroyView: debugDestroyView,\n    createDebugContext: (view: ViewData, nodeIndex: number) => new DebugContext_(view, nodeIndex),\n    handleEvent: debugHandleEvent,\n    updateDirectives: debugUpdateDirectives,\n    updateRenderer: debugUpdateRenderer,\n  };\n}\n\nfunction createProdRootView(\n    elInjector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any,\n    def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData {\n  const rendererFactory: RendererFactory2 = ngModule.injector.get(RendererFactory2);\n  return createRootView(\n      createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode),\n      def, context);\n}\n\nfunction debugCreateRootView(\n    elInjector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any,\n    def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData {\n  const rendererFactory: RendererFactory2 = ngModule.injector.get(RendererFactory2);\n  const root = createRootData(\n      elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes,\n      rootSelectorOrNode);\n  const defWithOverride = applyProviderOverridesToView(def);\n  return callWithDebugContext(\n      DebugAction.create, createRootView, null, [root, defWithOverride, context]);\n}\n\nfunction createRootData(\n    elInjector: Injector, ngModule: NgModuleRef<any>, rendererFactory: RendererFactory2,\n    projectableNodes: any[][], rootSelectorOrNode: any): RootData {\n  const sanitizer = ngModule.injector.get(Sanitizer);\n  const errorHandler = ngModule.injector.get(ErrorHandler);\n  const renderer = rendererFactory.createRenderer(null, null);\n  return {\n    ngModule,\n    injector: elInjector, projectableNodes,\n    selectorOrNode: rootSelectorOrNode, sanitizer, rendererFactory, renderer, errorHandler\n  };\n}\n\nfunction debugCreateEmbeddedView(\n    parentView: ViewData, anchorDef: NodeDef, viewDef: ViewDefinition, context?: any): ViewData {\n  const defWithOverride = applyProviderOverridesToView(viewDef);\n  return callWithDebugContext(\n      DebugAction.create, createEmbeddedView, null,\n      [parentView, anchorDef, defWithOverride, context]);\n}\n\nfunction debugCreateComponentView(\n    parentView: ViewData, nodeDef: NodeDef, viewDef: ViewDefinition, hostElement: any): ViewData {\n  const overrideComponentView =\n      viewDefOverrides.get(nodeDef.element !.componentProvider !.provider !.token);\n  if (overrideComponentView) {\n    viewDef = overrideComponentView;\n  } else {\n    viewDef = applyProviderOverridesToView(viewDef);\n  }\n  return callWithDebugContext(\n      DebugAction.create, createComponentView, null, [parentView, nodeDef, viewDef, hostElement]);\n}\n\nfunction debugCreateNgModuleRef(\n    moduleType: Type<any>, parentInjector: Injector, bootstrapComponents: Type<any>[],\n    def: NgModuleDefinition): NgModuleRef<any> {\n  const defWithOverride = applyProviderOverridesToNgModule(def);\n  return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);\n}\n\nconst providerOverrides = new Map<any, ProviderOverride>();\nconst providerOverridesWithScope = new Map<InjectableType<any>, ProviderOverride>();\nconst viewDefOverrides = new Map<any, ViewDefinition>();\n\nfunction debugOverrideProvider(override: ProviderOverride) {\n  providerOverrides.set(override.token, override);\n  let injectableDef: InjectableDef<any>|null;\n  if (typeof override.token === 'function' && (injectableDef = getInjectableDef(override.token)) &&\n      typeof injectableDef.providedIn === 'function') {\n    providerOverridesWithScope.set(override.token as InjectableType<any>, override);\n  }\n}\n\nfunction debugOverrideComponentView(comp: any, compFactory: ComponentFactory<any>) {\n  const hostViewDef = resolveDefinition(getComponentViewDefinitionFactory(compFactory));\n  const compViewDef = resolveDefinition(hostViewDef.nodes[0].element !.componentView !);\n  viewDefOverrides.set(comp, compViewDef);\n}\n\nfunction debugClearOverrides() {\n  providerOverrides.clear();\n  providerOverridesWithScope.clear();\n  viewDefOverrides.clear();\n}\n\n// Notes about the algorithm:\n// 1) Locate the providers of an element and check if one of them was overwritten\n// 2) Change the providers of that element\n//\n// We only create new datastructures if we need to, to keep perf impact\n// reasonable.\nfunction applyProviderOverridesToView(def: ViewDefinition): ViewDefinition {\n  if (providerOverrides.size === 0) {\n    return def;\n  }\n  const elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);\n  if (elementIndicesWithOverwrittenProviders.length === 0) {\n    return def;\n  }\n  // clone the whole view definition,\n  // as it maintains references between the nodes that are hard to update.\n  def = def.factory !(() => NOOP);\n  for (let i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {\n    applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);\n  }\n  return def;\n\n  function findElementIndicesWithOverwrittenProviders(def: ViewDefinition): number[] {\n    const elIndicesWithOverwrittenProviders: number[] = [];\n    let lastElementDef: NodeDef|null = null;\n    for (let i = 0; i < def.nodes.length; i++) {\n      const nodeDef = def.nodes[i];\n      if (nodeDef.flags & NodeFlags.TypeElement) {\n        lastElementDef = nodeDef;\n      }\n      if (lastElementDef && nodeDef.flags & NodeFlags.CatProviderNoDirective &&\n          providerOverrides.has(nodeDef.provider !.token)) {\n        elIndicesWithOverwrittenProviders.push(lastElementDef !.nodeIndex);\n        lastElementDef = null;\n      }\n    }\n    return elIndicesWithOverwrittenProviders;\n  }\n\n  function applyProviderOverridesToElement(viewDef: ViewDefinition, elIndex: number) {\n    for (let i = elIndex + 1; i < viewDef.nodes.length; i++) {\n      const nodeDef = viewDef.nodes[i];\n      if (nodeDef.flags & NodeFlags.TypeElement) {\n        // stop at the next element\n        return;\n      }\n      if (nodeDef.flags & NodeFlags.CatProviderNoDirective) {\n        const provider = nodeDef.provider !;\n        const override = providerOverrides.get(provider.token);\n        if (override) {\n          nodeDef.flags = (nodeDef.flags & ~NodeFlags.CatProviderNoDirective) | override.flags;\n          provider.deps = splitDepsDsl(override.deps);\n          provider.value = override.value;\n        }\n      }\n    }\n  }\n}\n\n// Notes about the algorithm:\n// We only create new datastructures if we need to, to keep perf impact\n// reasonable.\nfunction applyProviderOverridesToNgModule(def: NgModuleDefinition): NgModuleDefinition {\n  const {hasOverrides, hasDeprecatedOverrides} = calcHasOverrides(def);\n  if (!hasOverrides) {\n    return def;\n  }\n  // clone the whole view definition,\n  // as it maintains references between the nodes that are hard to update.\n  def = def.factory !(() => NOOP);\n  applyProviderOverrides(def);\n  return def;\n\n  function calcHasOverrides(def: NgModuleDefinition):\n      {hasOverrides: boolean, hasDeprecatedOverrides: boolean} {\n    let hasOverrides = false;\n    let hasDeprecatedOverrides = false;\n    if (providerOverrides.size === 0) {\n      return {hasOverrides, hasDeprecatedOverrides};\n    }\n    def.providers.forEach(node => {\n      const override = providerOverrides.get(node.token);\n      if ((node.flags & NodeFlags.CatProviderNoDirective) && override) {\n        hasOverrides = true;\n        hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;\n      }\n    });\n    def.modules.forEach(module => {\n      providerOverridesWithScope.forEach((override, token) => {\n        if (getInjectableDef(token) !.providedIn === module) {\n          hasOverrides = true;\n          hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;\n        }\n      });\n    });\n    return {hasOverrides, hasDeprecatedOverrides};\n  }\n\n  function applyProviderOverrides(def: NgModuleDefinition) {\n    for (let i = 0; i < def.providers.length; i++) {\n      const provider = def.providers[i];\n      if (hasDeprecatedOverrides) {\n        // We had a bug where me made\n        // all providers lazy. Keep this logic behind a flag\n        // for migrating existing users.\n        provider.flags |= NodeFlags.LazyProvider;\n      }\n      const override = providerOverrides.get(provider.token);\n      if (override) {\n        provider.flags = (provider.flags & ~NodeFlags.CatProviderNoDirective) | override.flags;\n        provider.deps = splitDepsDsl(override.deps);\n        provider.value = override.value;\n      }\n    }\n    if (providerOverridesWithScope.size > 0) {\n      let moduleSet = new Set<any>(def.modules);\n      providerOverridesWithScope.forEach((override, token) => {\n        if (moduleSet.has(getInjectableDef(token) !.providedIn)) {\n          let provider = {\n            token: token,\n            flags:\n                override.flags | (hasDeprecatedOverrides ? NodeFlags.LazyProvider : NodeFlags.None),\n            deps: splitDepsDsl(override.deps),\n            value: override.value,\n            index: def.providers.length,\n          };\n          def.providers.push(provider);\n          def.providersByKey[tokenKey(token)] = provider;\n        }\n      });\n    }\n  }\n}\n\nfunction prodCheckAndUpdateNode(\n    view: ViewData, checkIndex: number, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any,\n    v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any {\n  const nodeDef = view.def.nodes[checkIndex];\n  checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n  return (nodeDef.flags & NodeFlags.CatPureExpression) ?\n      asPureExpressionData(view, checkIndex).value :\n      undefined;\n}\n\nfunction prodCheckNoChangesNode(\n    view: ViewData, checkIndex: number, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any,\n    v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any {\n  const nodeDef = view.def.nodes[checkIndex];\n  checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\n  return (nodeDef.flags & NodeFlags.CatPureExpression) ?\n      asPureExpressionData(view, checkIndex).value :\n      undefined;\n}\n\nfunction debugCheckAndUpdateView(view: ViewData) {\n  return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);\n}\n\nfunction debugCheckNoChangesView(view: ViewData) {\n  return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);\n}\n\nfunction debugDestroyView(view: ViewData) {\n  return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);\n}\n\nenum DebugAction {\n  create,\n  detectChanges,\n  checkNoChanges,\n  destroy,\n  handleEvent\n}\n\nlet _currentAction: DebugAction;\nlet _currentView: ViewData;\nlet _currentNodeIndex: number|null;\n\nfunction debugSetCurrentNode(view: ViewData, nodeIndex: number | null) {\n  _currentView = view;\n  _currentNodeIndex = nodeIndex;\n}\n\nfunction debugHandleEvent(view: ViewData, nodeIndex: number, eventName: string, event: any) {\n  debugSetCurrentNode(view, nodeIndex);\n  return callWithDebugContext(\n      DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);\n}\n\nfunction debugUpdateDirectives(view: ViewData, checkType: CheckType) {\n  if (view.state & ViewState.Destroyed) {\n    throw viewDestroyedError(DebugAction[_currentAction]);\n  }\n  debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));\n  return view.def.updateDirectives(debugCheckDirectivesFn, view);\n\n  function debugCheckDirectivesFn(\n      view: ViewData, nodeIndex: number, argStyle: ArgumentType, ...values: any[]) {\n    const nodeDef = view.def.nodes[nodeIndex];\n    if (checkType === CheckType.CheckAndUpdate) {\n      debugCheckAndUpdateNode(view, nodeDef, argStyle, values);\n    } else {\n      debugCheckNoChangesNode(view, nodeDef, argStyle, values);\n    }\n    if (nodeDef.flags & NodeFlags.TypeDirective) {\n      debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));\n    }\n    return (nodeDef.flags & NodeFlags.CatPureExpression) ?\n        asPureExpressionData(view, nodeDef.nodeIndex).value :\n        undefined;\n  }\n}\n\nfunction debugUpdateRenderer(view: ViewData, checkType: CheckType) {\n  if (view.state & ViewState.Destroyed) {\n    throw viewDestroyedError(DebugAction[_currentAction]);\n  }\n  debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));\n  return view.def.updateRenderer(debugCheckRenderNodeFn, view);\n\n  function debugCheckRenderNodeFn(\n      view: ViewData, nodeIndex: number, argStyle: ArgumentType, ...values: any[]) {\n    const nodeDef = view.def.nodes[nodeIndex];\n    if (checkType === CheckType.CheckAndUpdate) {\n      debugCheckAndUpdateNode(view, nodeDef, argStyle, values);\n    } else {\n      debugCheckNoChangesNode(view, nodeDef, argStyle, values);\n    }\n    if (nodeDef.flags & NodeFlags.CatRenderNode) {\n      debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));\n    }\n    return (nodeDef.flags & NodeFlags.CatPureExpression) ?\n        asPureExpressionData(view, nodeDef.nodeIndex).value :\n        undefined;\n  }\n}\n\nfunction debugCheckAndUpdateNode(\n    view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, givenValues: any[]): void {\n  const changed = (<any>checkAndUpdateNode)(view, nodeDef, argStyle, ...givenValues);\n  if (changed) {\n    const values = argStyle === ArgumentType.Dynamic ? givenValues[0] : givenValues;\n    if (nodeDef.flags & NodeFlags.TypeDirective) {\n      const bindingValues: {[key: string]: string} = {};\n      for (let i = 0; i < nodeDef.bindings.length; i++) {\n        const binding = nodeDef.bindings[i];\n        const value = values[i];\n        if (binding.flags & BindingFlags.TypeProperty) {\n          bindingValues[normalizeDebugBindingName(binding.nonMinifiedName !)] =\n              normalizeDebugBindingValue(value);\n        }\n      }\n      const elDef = nodeDef.parent !;\n      const el = asElementData(view, elDef.nodeIndex).renderElement;\n      if (!elDef.element !.name) {\n        // a comment.\n        view.renderer.setValue(el, `bindings=${JSON.stringify(bindingValues, null, 2)}`);\n      } else {\n        // a regular element.\n        for (let attr in bindingValues) {\n          const value = bindingValues[attr];\n          if (value != null) {\n            view.renderer.setAttribute(el, attr, value);\n          } else {\n            view.renderer.removeAttribute(el, attr);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction debugCheckNoChangesNode(\n    view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, values: any[]): void {\n  (<any>checkNoChangesNode)(view, nodeDef, argStyle, ...values);\n}\n\nfunction nextDirectiveWithBinding(view: ViewData, nodeIndex: number): number|null {\n  for (let i = nodeIndex; i < view.def.nodes.length; i++) {\n    const nodeDef = view.def.nodes[i];\n    if (nodeDef.flags & NodeFlags.TypeDirective && nodeDef.bindings && nodeDef.bindings.length) {\n      return i;\n    }\n  }\n  return null;\n}\n\nfunction nextRenderNodeWithBinding(view: ViewData, nodeIndex: number): number|null {\n  for (let i = nodeIndex; i < view.def.nodes.length; i++) {\n    const nodeDef = view.def.nodes[i];\n    if ((nodeDef.flags & NodeFlags.CatRenderNode) && nodeDef.bindings && nodeDef.bindings.length) {\n      return i;\n    }\n  }\n  return null;\n}\n\nclass DebugContext_ implements DebugContext {\n  private nodeDef: NodeDef;\n  private elView: ViewData;\n  private elDef: NodeDef;\n\n  constructor(public view: ViewData, public nodeIndex: number|null) {\n    if (nodeIndex == null) {\n      this.nodeIndex = nodeIndex = 0;\n    }\n    this.nodeDef = view.def.nodes[nodeIndex];\n    let elDef = this.nodeDef;\n    let elView = view;\n    while (elDef && (elDef.flags & NodeFlags.TypeElement) === 0) {\n      elDef = elDef.parent !;\n    }\n    if (!elDef) {\n      while (!elDef && elView) {\n        elDef = viewParentEl(elView) !;\n        elView = elView.parent !;\n      }\n    }\n    this.elDef = elDef;\n    this.elView = elView;\n  }\n\n  private get elOrCompView() {\n    // Has to be done lazily as we use the DebugContext also during creation of elements...\n    return asElementData(this.elView, this.elDef.nodeIndex).componentView || this.view;\n  }\n\n  get injector(): Injector { return createInjector(this.elView, this.elDef); }\n\n  get component(): any { return this.elOrCompView.component; }\n\n  get context(): any { return this.elOrCompView.context; }\n\n  get providerTokens(): any[] {\n    const tokens: any[] = [];\n    if (this.elDef) {\n      for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount;\n           i++) {\n        const childDef = this.elView.def.nodes[i];\n        if (childDef.flags & NodeFlags.CatProvider) {\n          tokens.push(childDef.provider !.token);\n        }\n        i += childDef.childCount;\n      }\n    }\n    return tokens;\n  }\n\n  get references(): {[key: string]: any} {\n    const references: {[key: string]: any} = {};\n    if (this.elDef) {\n      collectReferences(this.elView, this.elDef, references);\n\n      for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount;\n           i++) {\n        const childDef = this.elView.def.nodes[i];\n        if (childDef.flags & NodeFlags.CatProvider) {\n          collectReferences(this.elView, childDef, references);\n        }\n        i += childDef.childCount;\n      }\n    }\n    return references;\n  }\n\n  get componentRenderElement() {\n    const elData = findHostElement(this.elOrCompView);\n    return elData ? elData.renderElement : undefined;\n  }\n\n  get renderNode(): any {\n    return this.nodeDef.flags & NodeFlags.TypeText ? renderNode(this.view, this.nodeDef) :\n                                                     renderNode(this.elView, this.elDef);\n  }\n\n  logError(console: Console, ...values: any[]) {\n    let logViewDef: ViewDefinition;\n    let logNodeIndex: number;\n    if (this.nodeDef.flags & NodeFlags.TypeText) {\n      logViewDef = this.view.def;\n      logNodeIndex = this.nodeDef.nodeIndex;\n    } else {\n      logViewDef = this.elView.def;\n      logNodeIndex = this.elDef.nodeIndex;\n    }\n    // Note: we only generate a log function for text and element nodes\n    // to make the generated code as small as possible.\n    const renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);\n    let currRenderNodeIndex = -1;\n    let nodeLogger: NodeLogger = () => {\n      currRenderNodeIndex++;\n      if (currRenderNodeIndex === renderNodeIndex) {\n        return console.error.bind(console, ...values);\n      } else {\n        return NOOP;\n      }\n    };\n    logViewDef.factory !(nodeLogger);\n    if (currRenderNodeIndex < renderNodeIndex) {\n      console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');\n      (<any>console.error)(...values);\n    }\n  }\n}\n\nfunction getRenderNodeIndex(viewDef: ViewDefinition, nodeIndex: number): number {\n  let renderNodeIndex = -1;\n  for (let i = 0; i <= nodeIndex; i++) {\n    const nodeDef = viewDef.nodes[i];\n    if (nodeDef.flags & NodeFlags.CatRenderNode) {\n      renderNodeIndex++;\n    }\n  }\n  return renderNodeIndex;\n}\n\nfunction findHostElement(view: ViewData): ElementData|null {\n  while (view && !isComponentView(view)) {\n    view = view.parent !;\n  }\n  if (view.parent) {\n    return asElementData(view.parent, viewParentEl(view) !.nodeIndex);\n  }\n  return null;\n}\n\nfunction collectReferences(view: ViewData, nodeDef: NodeDef, references: {[key: string]: any}) {\n  for (let refName in nodeDef.references) {\n    references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);\n  }\n}\n\nfunction callWithDebugContext(action: DebugAction, fn: any, self: any, args: any[]) {\n  const oldAction = _currentAction;\n  const oldView = _currentView;\n  const oldNodeIndex = _currentNodeIndex;\n  try {\n    _currentAction = action;\n    const result = fn.apply(self, args);\n    _currentView = oldView;\n    _currentNodeIndex = oldNodeIndex;\n    _currentAction = oldAction;\n    return result;\n  } catch (e) {\n    if (isViewDebugError(e) || !_currentView) {\n      throw e;\n    }\n    throw viewWrappedDebugError(e, getCurrentDebugContext() !);\n  }\n}\n\nexport function getCurrentDebugContext(): DebugContext|null {\n  return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;\n}\n\nexport class DebugRendererFactory2 implements RendererFactory2 {\n  constructor(private delegate: RendererFactory2) {}\n\n  createRenderer(element: any, renderData: RendererType2|null): Renderer2 {\n    return new DebugRenderer2(this.delegate.createRenderer(element, renderData));\n  }\n\n  begin() {\n    if (this.delegate.begin) {\n      this.delegate.begin();\n    }\n  }\n  end() {\n    if (this.delegate.end) {\n      this.delegate.end();\n    }\n  }\n\n  whenRenderingDone(): Promise<any> {\n    if (this.delegate.whenRenderingDone) {\n      return this.delegate.whenRenderingDone();\n    }\n    return Promise.resolve(null);\n  }\n}\n\nexport class DebugRenderer2 implements Renderer2 {\n  readonly data: {[key: string]: any};\n\n  private createDebugContext(nativeElement: any) { return this.debugContextFactory(nativeElement); }\n\n  /**\n   * Factory function used to create a `DebugContext` when a node is created.\n   *\n   * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.\n   *\n   * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine\n   * or a Render context.\n   */\n  debugContextFactory: (nativeElement?: any) => DebugContext | null = getCurrentDebugContext;\n\n  constructor(private delegate: Renderer2) { this.data = this.delegate.data; }\n\n  destroyNode(node: any) {\n    removeDebugNodeFromIndex(getDebugNode(node) !);\n    if (this.delegate.destroyNode) {\n      this.delegate.destroyNode(node);\n    }\n  }\n\n  destroy() { this.delegate.destroy(); }\n\n  createElement(name: string, namespace?: string): any {\n    const el = this.delegate.createElement(name, namespace);\n    const debugCtx = this.createDebugContext(el);\n    if (debugCtx) {\n      const debugEl = new DebugElement__PRE_R3__(el, null, debugCtx);\n      (debugEl as{name: string}).name = name;\n      indexDebugNode(debugEl);\n    }\n    return el;\n  }\n\n  createComment(value: string): any {\n    const comment = this.delegate.createComment(value);\n    const debugCtx = this.createDebugContext(comment);\n    if (debugCtx) {\n      indexDebugNode(new DebugNode__PRE_R3__(comment, null, debugCtx));\n    }\n    return comment;\n  }\n\n  createText(value: string): any {\n    const text = this.delegate.createText(value);\n    const debugCtx = this.createDebugContext(text);\n    if (debugCtx) {\n      indexDebugNode(new DebugNode__PRE_R3__(text, null, debugCtx));\n    }\n    return text;\n  }\n\n  appendChild(parent: any, newChild: any): void {\n    const debugEl = getDebugNode(parent);\n    const debugChildEl = getDebugNode(newChild);\n    if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.addChild(debugChildEl);\n    }\n    this.delegate.appendChild(parent, newChild);\n  }\n\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    const debugEl = getDebugNode(parent);\n    const debugChildEl = getDebugNode(newChild);\n    const debugRefEl = getDebugNode(refChild) !;\n    if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.insertBefore(debugRefEl, debugChildEl);\n    }\n\n    this.delegate.insertBefore(parent, newChild, refChild);\n  }\n\n  removeChild(parent: any, oldChild: any): void {\n    const debugEl = getDebugNode(parent);\n    const debugChildEl = getDebugNode(oldChild);\n    if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.removeChild(debugChildEl);\n    }\n    this.delegate.removeChild(parent, oldChild);\n  }\n\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): any {\n    const el = this.delegate.selectRootElement(selectorOrNode, preserveContent);\n    const debugCtx = getCurrentDebugContext();\n    if (debugCtx) {\n      indexDebugNode(new DebugElement__PRE_R3__(el, null, debugCtx));\n    }\n    return el;\n  }\n\n  setAttribute(el: any, name: string, value: string, namespace?: string): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      const fullName = namespace ? namespace + ':' + name : name;\n      debugEl.attributes[fullName] = value;\n    }\n    this.delegate.setAttribute(el, name, value, namespace);\n  }\n\n  removeAttribute(el: any, name: string, namespace?: string): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      const fullName = namespace ? namespace + ':' + name : name;\n      debugEl.attributes[fullName] = null;\n    }\n    this.delegate.removeAttribute(el, name, namespace);\n  }\n\n  addClass(el: any, name: string): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.classes[name] = true;\n    }\n    this.delegate.addClass(el, name);\n  }\n\n  removeClass(el: any, name: string): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.classes[name] = false;\n    }\n    this.delegate.removeClass(el, name);\n  }\n\n  setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.styles[style] = value;\n    }\n    this.delegate.setStyle(el, style, value, flags);\n  }\n\n  removeStyle(el: any, style: string, flags: RendererStyleFlags2): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.styles[style] = null;\n    }\n    this.delegate.removeStyle(el, style, flags);\n  }\n\n  setProperty(el: any, name: string, value: any): void {\n    const debugEl = getDebugNode(el);\n    if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\n      debugEl.properties[name] = value;\n    }\n    this.delegate.setProperty(el, name, value);\n  }\n\n  listen(\n      target: 'document'|'windows'|'body'|any, eventName: string,\n      callback: (event: any) => boolean): () => void {\n    if (typeof target !== 'string') {\n      const debugEl = getDebugNode(target);\n      if (debugEl) {\n        debugEl.listeners.push(new EventListener(eventName, callback));\n      }\n    }\n\n    return this.delegate.listen(target, eventName, callback);\n  }\n\n  parentNode(node: any): any { return this.delegate.parentNode(node); }\n  nextSibling(node: any): any { return this.delegate.nextSibling(node); }\n  setValue(node: any, value: string): void { return this.delegate.setValue(node, value); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {ComponentFactory} from '../linker/component_factory';\nimport {NgModuleFactory, NgModuleRef} from '../linker/ng_module_factory';\nimport {Type} from '../type';\n\nimport {initServicesIfNeeded} from './services';\nimport {NgModuleDefinition, NgModuleDefinitionFactory, NgModuleProviderDef, ProviderOverride, Services, ViewDefinition} from './types';\nimport {resolveDefinition} from './util';\n\nexport function overrideProvider(override: ProviderOverride) {\n  initServicesIfNeeded();\n  return Services.overrideProvider(override);\n}\n\nexport function overrideComponentView(comp: Type<any>, componentFactory: ComponentFactory<any>) {\n  initServicesIfNeeded();\n  return Services.overrideComponentView(comp, componentFactory);\n}\n\nexport function clearOverrides() {\n  initServicesIfNeeded();\n  return Services.clearOverrides();\n}\n\n// Attention: this function is called as top level function.\n// Putting any logic in here will destroy closure tree shaking!\nexport function createNgModuleFactory(\n    ngModuleType: Type<any>, bootstrapComponents: Type<any>[],\n    defFactory: NgModuleDefinitionFactory): NgModuleFactory<any> {\n  return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);\n}\n\nfunction cloneNgModuleDefinition(def: NgModuleDefinition): NgModuleDefinition {\n  const providers = Array.from(def.providers);\n  const modules = Array.from(def.modules);\n  const providersByKey: {[tokenKey: string]: NgModuleProviderDef} = {};\n  for (const key in def.providersByKey) {\n    providersByKey[key] = def.providersByKey[key];\n  }\n\n  return {\n    factory: def.factory,\n    isRoot: def.isRoot, providers, modules, providersByKey,\n  };\n}\n\nclass NgModuleFactory_ extends NgModuleFactory<any> {\n  constructor(\n      public readonly moduleType: Type<any>, private _bootstrapComponents: Type<any>[],\n      private _ngModuleDefFactory: NgModuleDefinitionFactory) {\n    // Attention: this ctor is called as top level function.\n    // Putting any logic in here will destroy closure tree shaking!\n    super();\n  }\n\n  create(parentInjector: Injector|null): NgModuleRef<any> {\n    initServicesIfNeeded();\n    // Clone the NgModuleDefinition so that any tree shakeable provider definition\n    // added to this instance of the NgModuleRef doesn't affect the cached copy.\n    // See https://github.com/angular/angular/issues/25018.\n    const def = cloneNgModuleDefinition(resolveDefinition(this._ngModuleDefFactory));\n    return Services.createNgModuleRef(\n        this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n/**\n * This class should not be used directly by an application developer. Instead, use\n * {@link Location}.\n *\n * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform\n * agnostic.\n * This means that we can have different implementation of `PlatformLocation` for the different\n * platforms that angular supports. For example, `@angular/platform-browser` provides an\n * implementation specific to the browser environment, while `@angular/platform-webworker` provides\n * one suitable for use with web workers.\n *\n * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}\n * when they need to interact with the DOM apis like pushState, popState, etc...\n *\n * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly\n * by the {@link Router} in order to navigate between routes. Since all interactions between {@link\n * Router} /\n * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`\n * class they are all platform independent.\n *\n * @publicApi\n */\nexport abstract class PlatformLocation {\n  abstract getBaseHrefFromDOM(): string;\n  abstract onPopState(fn: LocationChangeListener): void;\n  abstract onHashChange(fn: LocationChangeListener): void;\n\n  abstract get pathname(): string;\n  abstract get search(): string;\n  abstract get hash(): string;\n\n  abstract replaceState(state: any, title: string, url: string): void;\n\n  abstract pushState(state: any, title: string, url: string): void;\n\n  abstract forward(): void;\n\n  abstract back(): void;\n}\n\n/**\n * @description\n * Indicates when a location is initialized.\n *\n * @publicApi\n */\nexport const LOCATION_INITIALIZED = new InjectionToken<Promise<any>>('Location Initialized');\n\n/**\n * @description\n * A serializable version of the event from `onPopState` or `onHashChange`\n *\n * @publicApi\n */\nexport interface LocationChangeEvent {\n  type: string;\n  state: any;\n}\n\n/**\n * @publicApi\n */\nexport interface LocationChangeListener { (event: LocationChangeEvent): any; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {NumberFormatStyle} from '../../i18n/locale_data_api';\n\nexport class NumberFormatter {\n  static format(num: number, locale: string, style: NumberFormatStyle, opts: {\n    minimumIntegerDigits?: number,\n    minimumFractionDigits?: number,\n    maximumFractionDigits?: number,\n    currency?: string|null,\n    currencyAsSymbol?: boolean\n  } = {}): string {\n    const {minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, currency,\n           currencyAsSymbol = false} = opts;\n    const options: Intl.NumberFormatOptions = {\n      minimumIntegerDigits,\n      minimumFractionDigits,\n      maximumFractionDigits,\n      style: NumberFormatStyle[style].toLowerCase()\n    };\n\n    if (style == NumberFormatStyle.Currency) {\n      options.currency = typeof currency == 'string' ? currency : undefined;\n      options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';\n    }\n    return new Intl.NumberFormat(locale, options).format(num);\n  }\n}\n\ntype DateFormatterFn = (date: Date, locale: string) => string;\n\nconst DATE_FORMATS_SPLIT =\n    /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;\n\nconst PATTERN_ALIASES: {[format: string]: DateFormatterFn} = {\n  // Keys are quoted so they do not get renamed during closure compilation.\n  'yMMMdjms': datePartGetterFactory(combine([\n    digitCondition('year', 1),\n    nameCondition('month', 3),\n    digitCondition('day', 1),\n    digitCondition('hour', 1),\n    digitCondition('minute', 1),\n    digitCondition('second', 1),\n  ])),\n  'yMdjm': datePartGetterFactory(combine([\n    digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),\n    digitCondition('hour', 1), digitCondition('minute', 1)\n  ])),\n  'yMMMMEEEEd': datePartGetterFactory(combine([\n    digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),\n    digitCondition('day', 1)\n  ])),\n  'yMMMMd': datePartGetterFactory(\n      combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),\n  'yMMMd': datePartGetterFactory(\n      combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),\n  'yMd': datePartGetterFactory(\n      combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),\n  'jms': datePartGetterFactory(combine(\n      [digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),\n  'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))\n};\n\nconst DATE_FORMATS: {[format: string]: DateFormatterFn} = {\n  // Keys are quoted so they do not get renamed.\n  'yyyy': datePartGetterFactory(digitCondition('year', 4)),\n  'yy': datePartGetterFactory(digitCondition('year', 2)),\n  'y': datePartGetterFactory(digitCondition('year', 1)),\n  'MMMM': datePartGetterFactory(nameCondition('month', 4)),\n  'MMM': datePartGetterFactory(nameCondition('month', 3)),\n  'MM': datePartGetterFactory(digitCondition('month', 2)),\n  'M': datePartGetterFactory(digitCondition('month', 1)),\n  'LLLL': datePartGetterFactory(nameCondition('month', 4)),\n  'L': datePartGetterFactory(nameCondition('month', 1)),\n  'dd': datePartGetterFactory(digitCondition('day', 2)),\n  'd': datePartGetterFactory(digitCondition('day', 1)),\n  'HH': digitModifier(\n      hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),\n  'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),\n  'hh': digitModifier(\n      hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),\n  'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),\n  'jj': datePartGetterFactory(digitCondition('hour', 2)),\n  'j': datePartGetterFactory(digitCondition('hour', 1)),\n  'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),\n  'm': datePartGetterFactory(digitCondition('minute', 1)),\n  'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),\n  's': datePartGetterFactory(digitCondition('second', 1)),\n  // while ISO 8601 requires fractions to be prefixed with `.` or `,`\n  // we can be just safely rely on using `sss` since we currently don't support single or two digit\n  // fractions\n  'sss': datePartGetterFactory(digitCondition('second', 3)),\n  'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),\n  'EEE': datePartGetterFactory(nameCondition('weekday', 3)),\n  'EE': datePartGetterFactory(nameCondition('weekday', 2)),\n  'E': datePartGetterFactory(nameCondition('weekday', 1)),\n  'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),\n  'Z': timeZoneGetter('short'),\n  'z': timeZoneGetter('long'),\n  'ww': datePartGetterFactory({}),  // Week of year, padded (00-53). Week 01 is the week with the\n                                    // first Thursday of the year. not support ?\n  'w':\n      datePartGetterFactory({}),  // Week of year (0-53). Week 1 is the week with the first Thursday\n                                  // of the year not support ?\n  'G': datePartGetterFactory(nameCondition('era', 1)),\n  'GG': datePartGetterFactory(nameCondition('era', 2)),\n  'GGG': datePartGetterFactory(nameCondition('era', 3)),\n  'GGGG': datePartGetterFactory(nameCondition('era', 4))\n};\n\n\nfunction digitModifier(inner: DateFormatterFn): DateFormatterFn {\n  return function(date: Date, locale: string): string {\n    const result = inner(date, locale);\n    return result.length == 1 ? '0' + result : result;\n  };\n}\n\nfunction hourClockExtractor(inner: DateFormatterFn): DateFormatterFn {\n  return function(date: Date, locale: string): string { return inner(date, locale).split(' ')[1]; };\n}\n\nfunction hourExtractor(inner: DateFormatterFn): DateFormatterFn {\n  return function(date: Date, locale: string): string { return inner(date, locale).split(' ')[0]; };\n}\n\nfunction intlDateFormat(date: Date, locale: string, options: Intl.DateTimeFormatOptions): string {\n  return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\\u200e\\u200f]/g, '');\n}\n\nfunction timeZoneGetter(timezone: string): DateFormatterFn {\n  // To workaround `Intl` API restriction for single timezone let format with 24 hours\n  const options = {hour: '2-digit', hour12: false, timeZoneName: timezone};\n  return function(date: Date, locale: string): string {\n    const result = intlDateFormat(date, locale, options);\n    // Then extract first 3 letters that related to hours\n    return result ? result.substring(3) : '';\n  };\n}\n\nfunction hour12Modify(\n    options: Intl.DateTimeFormatOptions, value: boolean): Intl.DateTimeFormatOptions {\n  options.hour12 = value;\n  return options;\n}\n\nfunction digitCondition(prop: string, len: number): Intl.DateTimeFormatOptions {\n  const result: {[k: string]: string} = {};\n  result[prop] = len === 2 ? '2-digit' : 'numeric';\n  return result;\n}\n\nfunction nameCondition(prop: string, len: number): Intl.DateTimeFormatOptions {\n  const result: {[k: string]: string} = {};\n  if (len < 4) {\n    result[prop] = len > 1 ? 'short' : 'narrow';\n  } else {\n    result[prop] = 'long';\n  }\n\n  return result;\n}\n\nfunction combine(options: Intl.DateTimeFormatOptions[]): Intl.DateTimeFormatOptions {\n  return options.reduce((merged, opt) => ({...merged, ...opt}), {});\n}\n\nfunction datePartGetterFactory(ret: Intl.DateTimeFormatOptions): DateFormatterFn {\n  return (date: Date, locale: string): string => intlDateFormat(date, locale, ret);\n}\n\nconst DATE_FORMATTER_CACHE = new Map<string, string[]>();\n\nfunction dateFormatter(format: string, date: Date, locale: string): string {\n  const fn = PATTERN_ALIASES[format];\n\n  if (fn) return fn(date, locale);\n\n  const cacheKey = format;\n  let parts = DATE_FORMATTER_CACHE.get(cacheKey);\n\n  if (!parts) {\n    parts = [];\n    let match: RegExpExecArray|null;\n    DATE_FORMATS_SPLIT.exec(format);\n\n    let _format: string|null = format;\n    while (_format) {\n      match = DATE_FORMATS_SPLIT.exec(_format);\n      if (match) {\n        parts = parts.concat(match.slice(1));\n        _format = parts.pop() !;\n      } else {\n        parts.push(_format);\n        _format = null;\n      }\n    }\n\n    DATE_FORMATTER_CACHE.set(cacheKey, parts);\n  }\n\n  return parts.reduce((text, part) => {\n    const fn = DATE_FORMATS[part];\n    return text + (fn ? fn(date, locale) : partToTime(part));\n  }, '');\n}\n\nfunction partToTime(part: string): string {\n  return part === '\\'\\'' ? '\\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\\'');\n}\n\nexport class DateFormatter {\n  static format(date: Date, locale: string, pattern: string): string {\n    return dateFormatter(pattern, date, locale);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport {LocationChangeListener} from './platform_location';\n\n/**\n * `LocationStrategy` is responsible for representing and reading route state\n * from the browser's URL. Angular provides two strategies:\n * {@link HashLocationStrategy} and {@link PathLocationStrategy}.\n *\n * This is used under the hood of the {@link Location} service.\n *\n * Applications should use the {@link Router} or {@link Location} services to\n * interact with application route state.\n *\n * For instance, {@link HashLocationStrategy} produces URLs like\n * `http://example.com#/foo`, and {@link PathLocationStrategy} produces\n * `http://example.com/foo` as an equivalent URL.\n *\n * See these two classes for more.\n *\n * @publicApi\n */\nexport abstract class LocationStrategy {\n  abstract path(includeHash?: boolean): string;\n  abstract prepareExternalUrl(internal: string): string;\n  abstract pushState(state: any, title: string, url: string, queryParams: string): void;\n  abstract replaceState(state: any, title: string, url: string, queryParams: string): void;\n  abstract forward(): void;\n  abstract back(): void;\n  abstract onPopState(fn: LocationChangeListener): void;\n  abstract getBaseHref(): string;\n}\n\n\n/**\n * The `APP_BASE_HREF` token represents the base href to be used with the\n * {@link PathLocationStrategy}.\n *\n * If you're using {@link PathLocationStrategy}, you must provide a provider to a string\n * representing the URL prefix that should be preserved when generating and recognizing\n * URLs.\n *\n * @usageNotes\n *\n * ### Example\n *\n * ```typescript\n * import {Component, NgModule} from '@angular/core';\n * import {APP_BASE_HREF} from '@angular/common';\n *\n * @NgModule({\n *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport const APP_BASE_HREF = new InjectionToken<string>('appBaseHref');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, InjectionToken, LOCALE_ID, Optional} from '@angular/core';\nimport {Plural, getLocalePluralCase} from './locale_data_api';\n\n\n/**\n * @deprecated from v5\n */\nexport const DEPRECATED_PLURAL_FN = new InjectionToken<boolean>('UseV4Plurals');\n\n/**\n * @publicApi\n */\nexport abstract class NgLocalization {\n  abstract getPluralCategory(value: any, locale?: string): string;\n}\n\n\n/**\n * Returns the plural category for a given value.\n * - \"=value\" when the case exists,\n * - the plural category otherwise\n */\nexport function getPluralCategory(\n    value: number, cases: string[], ngLocalization: NgLocalization, locale?: string): string {\n  let key = `=${value}`;\n\n  if (cases.indexOf(key) > -1) {\n    return key;\n  }\n\n  key = ngLocalization.getPluralCategory(value, locale);\n\n  if (cases.indexOf(key) > -1) {\n    return key;\n  }\n\n  if (cases.indexOf('other') > -1) {\n    return 'other';\n  }\n\n  throw new Error(`No plural message found for value \"${value}\"`);\n}\n\n/**\n * Returns the plural case based on the locale\n *\n * @publicApi\n */\n@Injectable()\nexport class NgLocaleLocalization extends NgLocalization {\n  constructor(\n      @Inject(LOCALE_ID) protected locale: string,\n      /** @deprecated from v5 */\n      @Optional() @Inject(DEPRECATED_PLURAL_FN) protected deprecatedPluralFn?:\n          ((locale: string, value: number|string) => Plural)|null) {\n    super();\n  }\n\n  getPluralCategory(value: any, locale?: string): string {\n    const plural = this.deprecatedPluralFn ? this.deprecatedPluralFn(locale || this.locale, value) :\n                                             getLocalePluralCase(locale || this.locale)(value);\n\n    switch (plural) {\n      case Plural.Zero:\n        return 'zero';\n      case Plural.One:\n        return 'one';\n      case Plural.Two:\n        return 'two';\n      case Plural.Few:\n        return 'few';\n      case Plural.Many:\n        return 'many';\n      default:\n        return 'other';\n    }\n  }\n}\n\n/**\n * Returns the plural case based on the locale\n *\n * @deprecated from v5 the plural case function is in locale data files common/locales/*.ts\n * @publicApi\n */\nexport function getPluralCase(locale: string, nLike: number | string): Plural {\n  // TODO(vicb): lazy compute\n  if (typeof nLike === 'string') {\n    nLike = parseInt(<string>nLike, 10);\n  }\n  const n: number = nLike as number;\n  const nDecimal = n.toString().replace(/^[^.]*\\.?/, '');\n  const i = Math.floor(Math.abs(n));\n  const v = nDecimal.length;\n  const f = parseInt(nDecimal, 10);\n  const t = parseInt(n.toString().replace(/^[^.]*\\.?|0+$/g, ''), 10) || 0;\n\n  const lang = locale.split('-')[0].toLowerCase();\n\n  switch (lang) {\n    case 'af':\n    case 'asa':\n    case 'az':\n    case 'bem':\n    case 'bez':\n    case 'bg':\n    case 'brx':\n    case 'ce':\n    case 'cgg':\n    case 'chr':\n    case 'ckb':\n    case 'ee':\n    case 'el':\n    case 'eo':\n    case 'es':\n    case 'eu':\n    case 'fo':\n    case 'fur':\n    case 'gsw':\n    case 'ha':\n    case 'haw':\n    case 'hu':\n    case 'jgo':\n    case 'jmc':\n    case 'ka':\n    case 'kk':\n    case 'kkj':\n    case 'kl':\n    case 'ks':\n    case 'ksb':\n    case 'ky':\n    case 'lb':\n    case 'lg':\n    case 'mas':\n    case 'mgo':\n    case 'ml':\n    case 'mn':\n    case 'nb':\n    case 'nd':\n    case 'ne':\n    case 'nn':\n    case 'nnh':\n    case 'nyn':\n    case 'om':\n    case 'or':\n    case 'os':\n    case 'ps':\n    case 'rm':\n    case 'rof':\n    case 'rwk':\n    case 'saq':\n    case 'seh':\n    case 'sn':\n    case 'so':\n    case 'sq':\n    case 'ta':\n    case 'te':\n    case 'teo':\n    case 'tk':\n    case 'tr':\n    case 'ug':\n    case 'uz':\n    case 'vo':\n    case 'vun':\n    case 'wae':\n    case 'xog':\n      if (n === 1) return Plural.One;\n      return Plural.Other;\n    case 'ak':\n    case 'ln':\n    case 'mg':\n    case 'pa':\n    case 'ti':\n      if (n === Math.floor(n) && n >= 0 && n <= 1) return Plural.One;\n      return Plural.Other;\n    case 'am':\n    case 'as':\n    case 'bn':\n    case 'fa':\n    case 'gu':\n    case 'hi':\n    case 'kn':\n    case 'mr':\n    case 'zu':\n      if (i === 0 || n === 1) return Plural.One;\n      return Plural.Other;\n    case 'ar':\n      if (n === 0) return Plural.Zero;\n      if (n === 1) return Plural.One;\n      if (n === 2) return Plural.Two;\n      if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10) return Plural.Few;\n      if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99) return Plural.Many;\n      return Plural.Other;\n    case 'ast':\n    case 'ca':\n    case 'de':\n    case 'en':\n    case 'et':\n    case 'fi':\n    case 'fy':\n    case 'gl':\n    case 'it':\n    case 'nl':\n    case 'sv':\n    case 'sw':\n    case 'ur':\n    case 'yi':\n      if (i === 1 && v === 0) return Plural.One;\n      return Plural.Other;\n    case 'be':\n      if (n % 10 === 1 && !(n % 100 === 11)) return Plural.One;\n      if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&\n          !(n % 100 >= 12 && n % 100 <= 14))\n        return Plural.Few;\n      if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||\n          n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)\n        return Plural.Many;\n      return Plural.Other;\n    case 'br':\n      if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91)) return Plural.One;\n      if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92)) return Plural.Two;\n      if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&\n          !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||\n            n % 100 >= 90 && n % 100 <= 99))\n        return Plural.Few;\n      if (!(n === 0) && n % 1e6 === 0) return Plural.Many;\n      return Plural.Other;\n    case 'bs':\n    case 'hr':\n    case 'sr':\n      if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))\n        return Plural.One;\n      if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n              !(i % 100 >= 12 && i % 100 <= 14) ||\n          f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&\n              !(f % 100 >= 12 && f % 100 <= 14))\n        return Plural.Few;\n      return Plural.Other;\n    case 'cs':\n    case 'sk':\n      if (i === 1 && v === 0) return Plural.One;\n      if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0) return Plural.Few;\n      if (!(v === 0)) return Plural.Many;\n      return Plural.Other;\n    case 'cy':\n      if (n === 0) return Plural.Zero;\n      if (n === 1) return Plural.One;\n      if (n === 2) return Plural.Two;\n      if (n === 3) return Plural.Few;\n      if (n === 6) return Plural.Many;\n      return Plural.Other;\n    case 'da':\n      if (n === 1 || !(t === 0) && (i === 0 || i === 1)) return Plural.One;\n      return Plural.Other;\n    case 'dsb':\n    case 'hsb':\n      if (v === 0 && i % 100 === 1 || f % 100 === 1) return Plural.One;\n      if (v === 0 && i % 100 === 2 || f % 100 === 2) return Plural.Two;\n      if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||\n          f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)\n        return Plural.Few;\n      return Plural.Other;\n    case 'ff':\n    case 'fr':\n    case 'hy':\n    case 'kab':\n      if (i === 0 || i === 1) return Plural.One;\n      return Plural.Other;\n    case 'fil':\n      if (v === 0 && (i === 1 || i === 2 || i === 3) ||\n          v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||\n          !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))\n        return Plural.One;\n      return Plural.Other;\n    case 'ga':\n      if (n === 1) return Plural.One;\n      if (n === 2) return Plural.Two;\n      if (n === Math.floor(n) && n >= 3 && n <= 6) return Plural.Few;\n      if (n === Math.floor(n) && n >= 7 && n <= 10) return Plural.Many;\n      return Plural.Other;\n    case 'gd':\n      if (n === 1 || n === 11) return Plural.One;\n      if (n === 2 || n === 12) return Plural.Two;\n      if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19)) return Plural.Few;\n      return Plural.Other;\n    case 'gv':\n      if (v === 0 && i % 10 === 1) return Plural.One;\n      if (v === 0 && i % 10 === 2) return Plural.Two;\n      if (v === 0 &&\n          (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))\n        return Plural.Few;\n      if (!(v === 0)) return Plural.Many;\n      return Plural.Other;\n    case 'he':\n      if (i === 1 && v === 0) return Plural.One;\n      if (i === 2 && v === 0) return Plural.Two;\n      if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0) return Plural.Many;\n      return Plural.Other;\n    case 'is':\n      if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0)) return Plural.One;\n      return Plural.Other;\n    case 'ksh':\n      if (n === 0) return Plural.Zero;\n      if (n === 1) return Plural.One;\n      return Plural.Other;\n    case 'kw':\n    case 'naq':\n    case 'se':\n    case 'smn':\n      if (n === 1) return Plural.One;\n      if (n === 2) return Plural.Two;\n      return Plural.Other;\n    case 'lag':\n      if (n === 0) return Plural.Zero;\n      if ((i === 0 || i === 1) && !(n === 0)) return Plural.One;\n      return Plural.Other;\n    case 'lt':\n      if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19)) return Plural.One;\n      if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&\n          !(n % 100 >= 11 && n % 100 <= 19))\n        return Plural.Few;\n      if (!(f === 0)) return Plural.Many;\n      return Plural.Other;\n    case 'lv':\n    case 'prg':\n      if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||\n          v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)\n        return Plural.Zero;\n      if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||\n          !(v === 2) && f % 10 === 1)\n        return Plural.One;\n      return Plural.Other;\n    case 'mk':\n      if (v === 0 && i % 10 === 1 || f % 10 === 1) return Plural.One;\n      return Plural.Other;\n    case 'mt':\n      if (n === 1) return Plural.One;\n      if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)\n        return Plural.Few;\n      if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19) return Plural.Many;\n      return Plural.Other;\n    case 'pl':\n      if (i === 1 && v === 0) return Plural.One;\n      if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n          !(i % 100 >= 12 && i % 100 <= 14))\n        return Plural.Few;\n      if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||\n          v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||\n          v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)\n        return Plural.Many;\n      return Plural.Other;\n    case 'pt':\n      if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2)) return Plural.One;\n      return Plural.Other;\n    case 'ro':\n      if (i === 1 && v === 0) return Plural.One;\n      if (!(v === 0) || n === 0 ||\n          !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)\n        return Plural.Few;\n      return Plural.Other;\n    case 'ru':\n    case 'uk':\n      if (v === 0 && i % 10 === 1 && !(i % 100 === 11)) return Plural.One;\n      if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n          !(i % 100 >= 12 && i % 100 <= 14))\n        return Plural.Few;\n      if (v === 0 && i % 10 === 0 ||\n          v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||\n          v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)\n        return Plural.Many;\n      return Plural.Other;\n    case 'shi':\n      if (i === 0 || n === 1) return Plural.One;\n      if (n === Math.floor(n) && n >= 2 && n <= 10) return Plural.Few;\n      return Plural.Other;\n    case 'si':\n      if (n === 0 || n === 1 || i === 0 && f === 1) return Plural.One;\n      return Plural.Other;\n    case 'sl':\n      if (v === 0 && i % 100 === 1) return Plural.One;\n      if (v === 0 && i % 100 === 2) return Plural.Two;\n      if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))\n        return Plural.Few;\n      return Plural.Other;\n    case 'tzm':\n      if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)\n        return Plural.One;\n      return Plural.Other;\n    // When there is no specification, the default is always \"other\"\n    // Spec: http://cldr.unicode.org/index/cldr-spec/plural-rules\n    // > other (requiredâgeneral plural form â also used if the language only has a single form)\n    default:\n      return Plural.Other;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, LOCALE_ID, Pipe, PipeTransform, Type} from '@angular/core';\nimport {NUMBER_FORMAT_REGEXP, parseIntAutoRadix} from '../../i18n/format_number';\nimport {NumberFormatStyle} from '../../i18n/locale_data_api';\nimport {invalidPipeArgumentError} from '../invalid_pipe_argument_error';\nimport {NumberFormatter} from './intl';\n\nfunction formatNumber(\n    pipe: Type<any>, locale: string, value: number | string, style: NumberFormatStyle,\n    digits?: string | null, currency: string | null = null,\n    currencyAsSymbol: boolean = false): string|null {\n  if (value == null) return null;\n\n  // Convert strings to numbers\n  value = typeof value === 'string' && !isNaN(+value - parseFloat(value)) ? +value : value;\n  if (typeof value !== 'number') {\n    throw invalidPipeArgumentError(pipe, value);\n  }\n\n  let minInt: number|undefined;\n  let minFraction: number|undefined;\n  let maxFraction: number|undefined;\n  if (style !== NumberFormatStyle.Currency) {\n    // rely on Intl default for currency\n    minInt = 1;\n    minFraction = 0;\n    maxFraction = 3;\n  }\n\n  if (digits) {\n    const parts = digits.match(NUMBER_FORMAT_REGEXP);\n    if (parts === null) {\n      throw new Error(`${digits} is not a valid digit info for number pipes`);\n    }\n    if (parts[1] != null) {  // min integer digits\n      minInt = parseIntAutoRadix(parts[1]);\n    }\n    if (parts[3] != null) {  // min fraction digits\n      minFraction = parseIntAutoRadix(parts[3]);\n    }\n    if (parts[5] != null) {  // max fraction digits\n      maxFraction = parseIntAutoRadix(parts[5]);\n    }\n  }\n\n  return NumberFormatter.format(value as number, locale, style, {\n    minimumIntegerDigits: minInt,\n    minimumFractionDigits: minFraction,\n    maximumFractionDigits: maxFraction,\n    currency: currency,\n    currencyAsSymbol: currencyAsSymbol,\n  });\n}\n\n/**\n * Formats a number as text. Group sizing and separator and other locale-specific\n * configurations are based on the active locale.\n *\n * where `expression` is a number:\n *  - `digitInfo` is a `string` which has a following format: <br>\n *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>\n *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.\n *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.\n *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.\n *\n * For more information on the acceptable range for each of these numbers and other\n * details see your native internationalization library.\n *\n * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n * and may require a polyfill. See [Browser Support](guide/browser-support) for details.\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example common/pipes/ts/number_pipe.ts region='DeprecatedNumberPipe'}\n *\n * @ngModule CommonModule\n * @publicApi\n */\n@Pipe({name: 'number'})\nexport class DeprecatedDecimalPipe implements PipeTransform {\n  constructor(@Inject(LOCALE_ID) private _locale: string) {}\n\n  transform(value: any, digits?: string): string|null {\n    return formatNumber(\n        DeprecatedDecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n *\n * Formats a number as percentage according to locale rules.\n *\n * - `digitInfo` See {@link DecimalPipe} for detailed description.\n *\n * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n * and may require a polyfill. See [Browser Support](guide/browser-support) for details.\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example common/pipes/ts/percent_pipe.ts region='DeprecatedPercentPipe'}\n *\n * @publicApi\n */\n@Pipe({name: 'percent'})\nexport class DeprecatedPercentPipe implements PipeTransform {\n  constructor(@Inject(LOCALE_ID) private _locale: string) {}\n\n  transform(value: any, digits?: string): string|null {\n    return formatNumber(\n        DeprecatedPercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);\n  }\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as currency using locale rules.\n *\n * Use `currency` to format a number as currency.\n *\n * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such\n *    as `USD` for the US dollar and `EUR` for the euro.\n * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.\n *   - `true`: use symbol (e.g. `$`).\n *   - `false`(default): use code (e.g. `USD`).\n * - `digitInfo` See {@link DecimalPipe} for detailed description.\n *\n * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n * and may require a polyfill. See [Browser Support](guide/browser-support) for details.\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example common/pipes/ts/currency_pipe.ts region='DeprecatedCurrencyPipe'}\n *\n * @publicApi\n */\n@Pipe({name: 'currency'})\nexport class DeprecatedCurrencyPipe implements PipeTransform {\n  constructor(@Inject(LOCALE_ID) private _locale: string) {}\n\n  transform(\n      value: any, currencyCode: string = 'USD', symbolDisplay: boolean = false,\n      digits?: string): string|null {\n    return formatNumber(\n        DeprecatedCurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits,\n        currencyCode, symbolDisplay);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, EventEmitter, OnDestroy, Pipe, PipeTransform, WrappedValue, ÉµisObservable, ÉµisPromise} from '@angular/core';\nimport {Observable, SubscriptionLike} from 'rxjs';\nimport {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n\ninterface SubscriptionStrategy {\n  createSubscription(async: Observable<any>|Promise<any>, updateLatestValue: any): SubscriptionLike\n      |Promise<any>;\n  dispose(subscription: SubscriptionLike|Promise<any>): void;\n  onDestroy(subscription: SubscriptionLike|Promise<any>): void;\n}\n\nclass ObservableStrategy implements SubscriptionStrategy {\n  createSubscription(async: Observable<any>, updateLatestValue: any): SubscriptionLike {\n    return async.subscribe({next: updateLatestValue, error: (e: any) => { throw e; }});\n  }\n\n  dispose(subscription: SubscriptionLike): void { subscription.unsubscribe(); }\n\n  onDestroy(subscription: SubscriptionLike): void { subscription.unsubscribe(); }\n}\n\nclass PromiseStrategy implements SubscriptionStrategy {\n  createSubscription(async: Promise<any>, updateLatestValue: (v: any) => any): Promise<any> {\n    return async.then(updateLatestValue, e => { throw e; });\n  }\n\n  dispose(subscription: Promise<any>): void {}\n\n  onDestroy(subscription: Promise<any>): void {}\n}\n\nconst _promiseStrategy = new PromiseStrategy();\nconst _observableStrategy = new ObservableStrategy();\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Unwraps a value from an asynchronous primitive.\n *\n * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has\n * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for\n * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid\n * potential memory leaks.\n *\n * @usageNotes\n *\n * ### Examples\n *\n * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the\n * promise.\n *\n * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}\n *\n * It's also possible to use `async` with Observables. The example below binds the `time` Observable\n * to the view. The Observable continuously updates the view with the current time.\n *\n * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}\n *\n * @publicApi\n */\n@Pipe({name: 'async', pure: false})\nexport class AsyncPipe implements OnDestroy, PipeTransform {\n  private _latestValue: any = null;\n  private _latestReturnedValue: any = null;\n\n  private _subscription: SubscriptionLike|Promise<any>|null = null;\n  private _obj: Observable<any>|Promise<any>|EventEmitter<any>|null = null;\n  private _strategy: SubscriptionStrategy = null !;\n\n  constructor(private _ref: ChangeDetectorRef) {}\n\n  ngOnDestroy(): void {\n    if (this._subscription) {\n      this._dispose();\n    }\n  }\n\n  transform<T>(obj: null): null;\n  transform<T>(obj: undefined): undefined;\n  transform<T>(obj: Observable<T>|null|undefined): T|null;\n  transform<T>(obj: Promise<T>|null|undefined): T|null;\n  transform(obj: Observable<any>|Promise<any>|null|undefined): any {\n    if (!this._obj) {\n      if (obj) {\n        this._subscribe(obj);\n      }\n      this._latestReturnedValue = this._latestValue;\n      return this._latestValue;\n    }\n\n    if (obj !== this._obj) {\n      this._dispose();\n      return this.transform(obj as any);\n    }\n\n    if (this._latestValue === this._latestReturnedValue) {\n      return this._latestReturnedValue;\n    }\n\n    this._latestReturnedValue = this._latestValue;\n    return WrappedValue.wrap(this._latestValue);\n  }\n\n  private _subscribe(obj: Observable<any>|Promise<any>|EventEmitter<any>): void {\n    this._obj = obj;\n    this._strategy = this._selectStrategy(obj);\n    this._subscription = this._strategy.createSubscription(\n        obj, (value: Object) => this._updateLatestValue(obj, value));\n  }\n\n  private _selectStrategy(obj: Observable<any>|Promise<any>|EventEmitter<any>): any {\n    if (ÉµisPromise(obj)) {\n      return _promiseStrategy;\n    }\n\n    if (ÉµisObservable(obj)) {\n      return _observableStrategy;\n    }\n\n    throw invalidPipeArgumentError(AsyncPipe, obj);\n  }\n\n  private _dispose(): void {\n    this._strategy.dispose(this._subscription !);\n    this._latestValue = null;\n    this._latestReturnedValue = null;\n    this._subscription = null;\n    this._obj = null;\n  }\n\n  private _updateLatestValue(async: any, value: Object): void {\n    if (async === this._obj) {\n      this._latestValue = value;\n      this._ref.markForCheck();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Pipe, PipeTransform} from '@angular/core';\nimport {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Creates a new `Array` or `String` containing a subset (slice) of the elements.\n *\n * @usageNotes\n *\n * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`\n * and `String.prototype.slice()`.\n *\n * When operating on an `Array`, the returned `Array` is always a copy even when all\n * the elements are being returned.\n *\n * When operating on a blank value, the pipe returns the blank value.\n *\n * ### List Example\n *\n * This `ngFor` example:\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}\n *\n * produces the following:\n *\n * ```html\n * <li>b</li>\n * <li>c</li>\n * ```\n *\n * ### String Examples\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}\n *\n * @publicApi\n */\n@Pipe({name: 'slice', pure: false})\nexport class SlicePipe implements PipeTransform {\n  /**\n   * @param value a list or a string to be sliced.\n   * @param start the starting index of the subset to return:\n   *   - **a positive integer**: return the item at `start` index and all items after\n   *     in the list or string expression.\n   *   - **a negative integer**: return the item at `start` index from the end and all items after\n   *     in the list or string expression.\n   *   - **if positive and greater than the size of the expression**: return an empty list or\n   * string.\n   *   - **if negative and greater than the size of the expression**: return entire list or string.\n   * @param end the ending index of the subset to return:\n   *   - **omitted**: return all items until the end.\n   *   - **if positive**: return all items before `end` index of the list or string.\n   *   - **if negative**: return all items before `end` index from the end of the list or string.\n   */\n  transform(value: any, start: number, end?: number): any {\n    if (value == null) return value;\n\n    if (!this.supports(value)) {\n      throw invalidPipeArgumentError(SlicePipe, value);\n    }\n\n    return value.slice(start, end);\n  }\n\n  private supports(obj: any): boolean { return typeof obj === 'string' || Array.isArray(obj); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * A DI Token representing the main rendering context. In a browser this is the DOM Document.\n *\n * Note: Document might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application into a Web Worker).\n *\n * @publicApi\n */\nexport const DOCUMENT = new InjectionToken<Document>('DocumentToken');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n\nimport {Version} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('0.0.0-PLACEHOLDER');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\n\nlet _DOM: DomAdapter = null !;\n\nexport function getDOM() {\n  return _DOM;\n}\n\nexport function setDOM(adapter: DomAdapter) {\n  _DOM = adapter;\n}\n\nexport function setRootDomAdapter(adapter: DomAdapter) {\n  if (!_DOM) {\n    _DOM = adapter;\n  }\n}\n\n/* tslint:disable:requireParameterType */\n/**\n * Provides DOM operations in an environment-agnostic way.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class DomAdapter {\n  public resourceLoaderType: Type<any> = null !;\n  abstract hasProperty(element: any, name: string): boolean;\n  abstract setProperty(el: Element, name: string, value: any): any;\n  abstract getProperty(el: Element, name: string): any;\n  abstract invoke(el: Element, methodName: string, args: any[]): any;\n\n  abstract logError(error: any): any;\n  abstract log(error: any): any;\n  abstract logGroup(error: any): any;\n  abstract logGroupEnd(): any;\n\n  /**\n   * Maps attribute names to their corresponding property names for cases\n   * where attribute name doesn't match property name.\n   */\n  get attrToPropMap(): {[key: string]: string} { return this._attrToPropMap; }\n  set attrToPropMap(value: {[key: string]: string}) { this._attrToPropMap = value; }\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _attrToPropMap !: {[key: string]: string};\n\n  abstract contains(nodeA: any, nodeB: any): boolean;\n  abstract parse(templateHtml: string): any;\n  abstract querySelector(el: any, selector: string): any;\n  abstract querySelectorAll(el: any, selector: string): any[];\n  abstract on(el: any, evt: any, listener: any): any;\n  abstract onAndCancel(el: any, evt: any, listener: any): Function;\n  abstract dispatchEvent(el: any, evt: any): any;\n  abstract createMouseEvent(eventType: any): any;\n  abstract createEvent(eventType: string): any;\n  abstract preventDefault(evt: any): any;\n  abstract isPrevented(evt: any): boolean;\n  abstract getInnerHTML(el: any): string;\n  /** Returns content if el is a <template> element, null otherwise. */\n  abstract getTemplateContent(el: any): any;\n  abstract getOuterHTML(el: any): string;\n  abstract nodeName(node: any): string;\n  abstract nodeValue(node: any): string|null;\n  abstract type(node: any): string;\n  abstract content(node: any): any;\n  abstract firstChild(el: any): Node|null;\n  abstract nextSibling(el: any): Node|null;\n  abstract parentElement(el: any): Node|null;\n  abstract childNodes(el: any): Node[];\n  abstract childNodesAsList(el: any): Node[];\n  abstract clearNodes(el: any): any;\n  abstract appendChild(el: any, node: any): any;\n  abstract removeChild(el: any, node: any): any;\n  abstract replaceChild(el: any, newNode: any, oldNode: any): any;\n  abstract remove(el: any): Node;\n  abstract insertBefore(parent: any, ref: any, node: any): any;\n  abstract insertAllBefore(parent: any, ref: any, nodes: any): any;\n  abstract insertAfter(parent: any, el: any, node: any): any;\n  abstract setInnerHTML(el: any, value: any): any;\n  abstract getText(el: any): string|null;\n  abstract setText(el: any, value: string): any;\n  abstract getValue(el: any): string;\n  abstract setValue(el: any, value: string): any;\n  abstract getChecked(el: any): boolean;\n  abstract setChecked(el: any, value: boolean): any;\n  abstract createComment(text: string): any;\n  abstract createTemplate(html: any): HTMLElement;\n  abstract createElement(tagName: any, doc?: any): HTMLElement;\n  abstract createElementNS(ns: string, tagName: string, doc?: any): Element;\n  abstract createTextNode(text: string, doc?: any): Text;\n  abstract createScriptTag(attrName: string, attrValue: string, doc?: any): HTMLElement;\n  abstract createStyleElement(css: string, doc?: any): HTMLStyleElement;\n  abstract createShadowRoot(el: any): any;\n  abstract getShadowRoot(el: any): any;\n  abstract getHost(el: any): any;\n  abstract getDistributedNodes(el: any): Node[];\n  abstract clone /*<T extends Node>*/ (node: Node /*T*/): Node /*T*/;\n  abstract getElementsByClassName(element: any, name: string): HTMLElement[];\n  abstract getElementsByTagName(element: any, name: string): HTMLElement[];\n  abstract classList(element: any): any[];\n  abstract addClass(element: any, className: string): any;\n  abstract removeClass(element: any, className: string): any;\n  abstract hasClass(element: any, className: string): boolean;\n  abstract setStyle(element: any, styleName: string, styleValue: string): any;\n  abstract removeStyle(element: any, styleName: string): any;\n  abstract getStyle(element: any, styleName: string): string;\n  abstract hasStyle(element: any, styleName: string, styleValue?: string): boolean;\n  abstract tagName(element: any): string;\n  abstract attributeMap(element: any): Map<string, string>;\n  abstract hasAttribute(element: any, attribute: string): boolean;\n  abstract hasAttributeNS(element: any, ns: string, attribute: string): boolean;\n  abstract getAttribute(element: any, attribute: string): string|null;\n  abstract getAttributeNS(element: any, ns: string, attribute: string): string|null;\n  abstract setAttribute(element: any, name: string, value: string): any;\n  abstract setAttributeNS(element: any, ns: string, name: string, value: string): any;\n  abstract removeAttribute(element: any, attribute: string): any;\n  abstract removeAttributeNS(element: any, ns: string, attribute: string): any;\n  abstract templateAwareRoot(el: any): any;\n  abstract createHtmlDocument(): HTMLDocument;\n  abstract getDefaultDocument(): Document;\n  abstract getBoundingClientRect(el: any): any;\n  abstract getTitle(doc: Document): string;\n  abstract setTitle(doc: Document, newTitle: string): any;\n  abstract elementMatches(n: any, selector: string): boolean;\n  abstract isTemplateElement(el: any): boolean;\n  abstract isTextNode(node: any): boolean;\n  abstract isCommentNode(node: any): boolean;\n  abstract isElementNode(node: any): boolean;\n  abstract hasShadowRoot(node: any): boolean;\n  abstract isShadowRoot(node: any): boolean;\n  abstract importIntoDoc /*<T extends Node>*/ (node: Node /*T*/): Node /*T*/;\n  abstract adoptNode /*<T extends Node>*/ (node: Node /*T*/): Node /*T*/;\n  abstract getHref(element: any): string;\n  abstract getEventKey(event: any): string;\n  abstract resolveAndSetHref(element: any, baseUrl: string, href: string): any;\n  abstract supportsDOMEvents(): boolean;\n  abstract supportsNativeShadowDOM(): boolean;\n  abstract getGlobalEventTarget(doc: Document, target: string): any;\n  abstract getHistory(): History;\n  abstract getLocation(): Location;\n  abstract getBaseHref(doc: Document): string|null;\n  abstract resetBaseElement(): void;\n  abstract getUserAgent(): string;\n  abstract setData(element: any, name: string, value: string): any;\n  abstract getComputedStyle(element: any): any;\n  abstract getData(element: any, name: string): string|null;\n  abstract supportsWebAnimation(): boolean;\n  abstract performanceNow(): number;\n  abstract getAnimationPrefix(): string;\n  abstract getTransitionEnd(): string;\n  abstract supportsAnimation(): boolean;\n\n  abstract supportsCookies(): boolean;\n  abstract getCookie(name: string): string|null;\n  abstract setCookie(name: string, value: string): any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ÉµparseCookieValue as parseCookieValue} from '@angular/common';\nimport {Éµglobal as global} from '@angular/core';\n\nimport {setRootDomAdapter} from '../dom/dom_adapter';\n\nimport {GenericBrowserDomAdapter} from './generic_browser_adapter';\n\nconst _attrToPropMap = {\n  'class': 'className',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n};\n\nconst DOM_KEY_LOCATION_NUMPAD = 3;\n\n// Map to convert some key or keyIdentifier values to what will be returned by getEventKey\nconst _keyMap: {[k: string]: string} = {\n  // The following values are here for cross-browser compatibility and to match the W3C standard\n  // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS'\n};\n\n// There is a bug in Chrome for numeric keypad keys:\n// https://code.google.com/p/chromium/issues/detail?id=155654\n// 1, 2, 3 ... are reported as A, B, C ...\nconst _chromeNumKeyPadMap = {\n  'A': '1',\n  'B': '2',\n  'C': '3',\n  'D': '4',\n  'E': '5',\n  'F': '6',\n  'G': '7',\n  'H': '8',\n  'I': '9',\n  'J': '*',\n  'K': '+',\n  'M': '-',\n  'N': '.',\n  'O': '/',\n  '\\x60': '0',\n  '\\x90': 'NumLock'\n};\n\nlet nodeContains: (a: any, b: any) => boolean;\n\nif (global['Node']) {\n  nodeContains = global['Node'].prototype.contains || function(node) {\n    return !!(this.compareDocumentPosition(node) & 16);\n  };\n}\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\n/* tslint:disable:requireParameterType no-console */\nexport class BrowserDomAdapter extends GenericBrowserDomAdapter {\n  parse(templateHtml: string) { throw new Error('parse not implemented'); }\n  static makeCurrent() { setRootDomAdapter(new BrowserDomAdapter()); }\n  hasProperty(element: Node, name: string): boolean { return name in element; }\n  setProperty(el: Node, name: string, value: any) { (<any>el)[name] = value; }\n  getProperty(el: Node, name: string): any { return (<any>el)[name]; }\n  invoke(el: Node, methodName: string, args: any[]): any { (<any>el)[methodName](...args); }\n\n  // TODO(tbosch): move this into a separate environment class once we have it\n  logError(error: string): void {\n    if (window.console) {\n      if (console.error) {\n        console.error(error);\n      } else {\n        console.log(error);\n      }\n    }\n  }\n\n  log(error: string): void {\n    if (window.console) {\n      window.console.log && window.console.log(error);\n    }\n  }\n\n  logGroup(error: string): void {\n    if (window.console) {\n      window.console.group && window.console.group(error);\n    }\n  }\n\n  logGroupEnd(): void {\n    if (window.console) {\n      window.console.groupEnd && window.console.groupEnd();\n    }\n  }\n\n  get attrToPropMap(): any { return _attrToPropMap; }\n\n  contains(nodeA: any, nodeB: any): boolean { return nodeContains.call(nodeA, nodeB); }\n  querySelector(el: HTMLElement, selector: string): any { return el.querySelector(selector); }\n  querySelectorAll(el: any, selector: string): any[] { return el.querySelectorAll(selector); }\n  on(el: Node, evt: any, listener: any) { el.addEventListener(evt, listener, false); }\n  onAndCancel(el: Node, evt: any, listener: any): Function {\n    el.addEventListener(evt, listener, false);\n    // Needed to follow Dart's subscription semantic, until fix of\n    // https://code.google.com/p/dart/issues/detail?id=17406\n    return () => { el.removeEventListener(evt, listener, false); };\n  }\n  dispatchEvent(el: Node, evt: any) { el.dispatchEvent(evt); }\n  createMouseEvent(eventType: string): MouseEvent {\n    const evt: MouseEvent = this.getDefaultDocument().createEvent('MouseEvent');\n    evt.initEvent(eventType, true, true);\n    return evt;\n  }\n  createEvent(eventType: any): Event {\n    const evt: Event = this.getDefaultDocument().createEvent('Event');\n    evt.initEvent(eventType, true, true);\n    return evt;\n  }\n  preventDefault(evt: Event) {\n    evt.preventDefault();\n    evt.returnValue = false;\n  }\n  isPrevented(evt: Event): boolean {\n    return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;\n  }\n  getInnerHTML(el: HTMLElement): string { return el.innerHTML; }\n  getTemplateContent(el: Node): Node|null {\n    return 'content' in el && this.isTemplateElement(el) ? (<any>el).content : null;\n  }\n  getOuterHTML(el: HTMLElement): string { return el.outerHTML; }\n  nodeName(node: Node): string { return node.nodeName; }\n  nodeValue(node: Node): string|null { return node.nodeValue; }\n  type(node: HTMLInputElement): string { return node.type; }\n  content(node: Node): Node {\n    if (this.hasProperty(node, 'content')) {\n      return (<any>node).content;\n    } else {\n      return node;\n    }\n  }\n  firstChild(el: Node): Node|null { return el.firstChild; }\n  nextSibling(el: Node): Node|null { return el.nextSibling; }\n  parentElement(el: Node): Node|null { return el.parentNode; }\n  childNodes(el: any): Node[] { return el.childNodes; }\n  childNodesAsList(el: Node): any[] {\n    const childNodes = el.childNodes;\n    const res = new Array(childNodes.length);\n    for (let i = 0; i < childNodes.length; i++) {\n      res[i] = childNodes[i];\n    }\n    return res;\n  }\n  clearNodes(el: Node) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n  appendChild(el: Node, node: Node) { el.appendChild(node); }\n  removeChild(el: Node, node: Node) { el.removeChild(node); }\n  replaceChild(el: Node, newChild: Node, oldChild: Node) { el.replaceChild(newChild, oldChild); }\n  remove(node: Node): Node {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n    return node;\n  }\n  insertBefore(parent: Node, ref: Node, node: Node) { parent.insertBefore(node, ref); }\n  insertAllBefore(parent: Node, ref: Node, nodes: Node[]) {\n    nodes.forEach((n: any) => parent.insertBefore(n, ref));\n  }\n  insertAfter(parent: Node, ref: Node, node: any) { parent.insertBefore(node, ref.nextSibling); }\n  setInnerHTML(el: Element, value: string) { el.innerHTML = value; }\n  getText(el: Node): string|null { return el.textContent; }\n  setText(el: Node, value: string) { el.textContent = value; }\n  getValue(el: any): string { return el.value; }\n  setValue(el: any, value: string) { el.value = value; }\n  getChecked(el: any): boolean { return el.checked; }\n  setChecked(el: any, value: boolean) { el.checked = value; }\n  createComment(text: string): Comment { return this.getDefaultDocument().createComment(text); }\n  createTemplate(html: any): HTMLElement {\n    const t = this.getDefaultDocument().createElement('template');\n    t.innerHTML = html;\n    return t;\n  }\n  createElement(tagName: string, doc?: Document): HTMLElement {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  createElementNS(ns: string, tagName: string, doc?: Document): Element {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElementNS(ns, tagName);\n  }\n  createTextNode(text: string, doc?: Document): Text {\n    doc = doc || this.getDefaultDocument();\n    return doc.createTextNode(text);\n  }\n  createScriptTag(attrName: string, attrValue: string, doc?: Document): HTMLScriptElement {\n    doc = doc || this.getDefaultDocument();\n    const el = <HTMLScriptElement>doc.createElement('SCRIPT');\n    el.setAttribute(attrName, attrValue);\n    return el;\n  }\n  createStyleElement(css: string, doc?: Document): HTMLStyleElement {\n    doc = doc || this.getDefaultDocument();\n    const style = <HTMLStyleElement>doc.createElement('style');\n    this.appendChild(style, this.createTextNode(css, doc));\n    return style;\n  }\n  createShadowRoot(el: HTMLElement): DocumentFragment { return (<any>el).createShadowRoot(); }\n  getShadowRoot(el: HTMLElement): DocumentFragment { return (<any>el).shadowRoot; }\n  getHost(el: HTMLElement): HTMLElement { return (<any>el).host; }\n  clone(node: Node): Node { return node.cloneNode(true); }\n  getElementsByClassName(element: any, name: string): HTMLElement[] {\n    return element.getElementsByClassName(name);\n  }\n  getElementsByTagName(element: any, name: string): HTMLElement[] {\n    return element.getElementsByTagName(name);\n  }\n  classList(element: any): any[] { return Array.prototype.slice.call(element.classList, 0); }\n  addClass(element: any, className: string) { element.classList.add(className); }\n  removeClass(element: any, className: string) { element.classList.remove(className); }\n  hasClass(element: any, className: string): boolean {\n    return element.classList.contains(className);\n  }\n  setStyle(element: any, styleName: string, styleValue: string) {\n    element.style[styleName] = styleValue;\n  }\n  removeStyle(element: any, stylename: string) {\n    // IE requires '' instead of null\n    // see https://github.com/angular/angular/issues/7916\n    element.style[stylename] = '';\n  }\n  getStyle(element: any, stylename: string): string { return element.style[stylename]; }\n  hasStyle(element: any, styleName: string, styleValue?: string|null): boolean {\n    const value = this.getStyle(element, styleName) || '';\n    return styleValue ? value == styleValue : value.length > 0;\n  }\n  tagName(element: any): string { return element.tagName; }\n  attributeMap(element: any): Map<string, string> {\n    const res = new Map<string, string>();\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const attrib = elAttrs.item(i);\n      res.set(attrib.name, attrib.value);\n    }\n    return res;\n  }\n  hasAttribute(element: Element, attribute: string): boolean {\n    return element.hasAttribute(attribute);\n  }\n  hasAttributeNS(element: Element, ns: string, attribute: string): boolean {\n    return element.hasAttributeNS(ns, attribute);\n  }\n  getAttribute(element: Element, attribute: string): string|null {\n    return element.getAttribute(attribute);\n  }\n  getAttributeNS(element: Element, ns: string, name: string): string|null {\n    return element.getAttributeNS(ns, name);\n  }\n  setAttribute(element: Element, name: string, value: string) { element.setAttribute(name, value); }\n  setAttributeNS(element: Element, ns: string, name: string, value: string) {\n    element.setAttributeNS(ns, name, value);\n  }\n  removeAttribute(element: Element, attribute: string) { element.removeAttribute(attribute); }\n  removeAttributeNS(element: Element, ns: string, name: string) {\n    element.removeAttributeNS(ns, name);\n  }\n  templateAwareRoot(el: Node): any { return this.isTemplateElement(el) ? this.content(el) : el; }\n  createHtmlDocument(): HTMLDocument {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  getDefaultDocument(): Document { return document; }\n  getBoundingClientRect(el: Element): any {\n    try {\n      return el.getBoundingClientRect();\n    } catch {\n      return {top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0};\n    }\n  }\n  getTitle(doc: Document): string { return doc.title; }\n  setTitle(doc: Document, newTitle: string) { doc.title = newTitle || ''; }\n  elementMatches(n: any, selector: string): boolean {\n    if (this.isElementNode(n)) {\n      return n.matches && n.matches(selector) ||\n          n.msMatchesSelector && n.msMatchesSelector(selector) ||\n          n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n    }\n\n    return false;\n  }\n  isTemplateElement(el: Node): boolean {\n    return this.isElementNode(el) && el.nodeName === 'TEMPLATE';\n  }\n  isTextNode(node: Node): boolean { return node.nodeType === Node.TEXT_NODE; }\n  isCommentNode(node: Node): boolean { return node.nodeType === Node.COMMENT_NODE; }\n  isElementNode(node: Node): boolean { return node.nodeType === Node.ELEMENT_NODE; }\n  hasShadowRoot(node: any): boolean {\n    return node.shadowRoot != null && node instanceof HTMLElement;\n  }\n  isShadowRoot(node: any): boolean { return node instanceof DocumentFragment; }\n  importIntoDoc(node: Node): any { return document.importNode(this.templateAwareRoot(node), true); }\n  adoptNode(node: Node): any { return document.adoptNode(node); }\n  getHref(el: Element): string { return el.getAttribute('href') !; }\n\n  getEventKey(event: any): string {\n    let key = event.key;\n    if (key == null) {\n      key = event.keyIdentifier;\n      // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n      // Safari cf\n      // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n      if (key == null) {\n        return 'Unidentified';\n      }\n      if (key.startsWith('U+')) {\n        key = String.fromCharCode(parseInt(key.substring(2), 16));\n        if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n          // There is a bug in Chrome for numeric keypad keys:\n          // https://code.google.com/p/chromium/issues/detail?id=155654\n          // 1, 2, 3 ... are reported as A, B, C ...\n          key = (_chromeNumKeyPadMap as any)[key];\n        }\n      }\n    }\n\n    return _keyMap[key] || key;\n  }\n  getGlobalEventTarget(doc: Document, target: string): EventTarget|null {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  getHistory(): History { return window.history; }\n  getLocation(): Location { return window.location; }\n  getBaseHref(doc: Document): string|null {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  resetBaseElement(): void { baseElement = null; }\n  getUserAgent(): string { return window.navigator.userAgent; }\n  setData(element: Element, name: string, value: string) {\n    this.setAttribute(element, 'data-' + name, value);\n  }\n  getData(element: Element, name: string): string|null {\n    return this.getAttribute(element, 'data-' + name);\n  }\n  getComputedStyle(element: any): any { return getComputedStyle(element); }\n  // TODO(tbosch): move this into a separate environment class once we have it\n  supportsWebAnimation(): boolean {\n    return typeof(<any>Element).prototype['animate'] === 'function';\n  }\n  performanceNow(): number {\n    // performance.now() is not available in all browsers, see\n    // http://caniuse.com/#search=performance.now\n    return window.performance && window.performance.now ? window.performance.now() :\n                                                          new Date().getTime();\n  }\n\n  supportsCookies(): boolean { return true; }\n\n  getCookie(name: string): string|null { return parseCookieValue(document.cookie, name); }\n\n  setCookie(name: string, value: string) {\n    // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does\n    // not clear other cookies.\n    document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n  }\n}\n\nlet baseElement: HTMLElement|null = null;\nfunction getBaseElementHref(): string|null {\n  if (!baseElement) {\n    baseElement = document.querySelector('base') !;\n    if (!baseElement) {\n      return null;\n    }\n  }\n  return baseElement.getAttribute('href');\n}\n\n// based on urlUtils.js in AngularJS 1\nlet urlParsingNode: any;\nfunction relativePath(url: any): string {\n  if (!urlParsingNode) {\n    urlParsingNode = document.createElement('a');\n  }\n  urlParsingNode.setAttribute('href', url);\n  return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :\n                                                       '/' + urlParsingNode.pathname;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function parseCookieValue(cookieStr: string, name: string): string|null {\n  name = encodeURIComponent(name);\n  for (const cookie of cookieStr.split(';')) {\n    const eqIndex = cookie.indexOf('=');\n    const [cookieName, cookieValue]: string[] =\n        eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];\n    if (cookieName.trim() === name) {\n      return decodeURIComponent(cookieValue);\n    }\n  }\n  return null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DomAdapter} from '../dom/dom_adapter';\n\n\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class GenericBrowserDomAdapter extends DomAdapter {\n  private _animationPrefix: string|null = null;\n  private _transitionEnd: string|null = null;\n  constructor() {\n    super();\n    try {\n      const element = this.createElement('div', document);\n      if (this.getStyle(element, 'animationName') != null) {\n        this._animationPrefix = '';\n      } else {\n        const domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n\n        for (let i = 0; i < domPrefixes.length; i++) {\n          if (this.getStyle(element, domPrefixes[i] + 'AnimationName') != null) {\n            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';\n            break;\n          }\n        }\n      }\n\n      const transEndEventNames: {[key: string]: string} = {\n        WebkitTransition: 'webkitTransitionEnd',\n        MozTransition: 'transitionend',\n        OTransition: 'oTransitionEnd otransitionend',\n        transition: 'transitionend'\n      };\n\n      Object.keys(transEndEventNames).forEach((key: string) => {\n        if (this.getStyle(element, key) != null) {\n          this._transitionEnd = transEndEventNames[key];\n        }\n      });\n    } catch {\n      this._animationPrefix = null;\n      this._transitionEnd = null;\n    }\n  }\n\n  getDistributedNodes(el: HTMLElement): Node[] { return (<any>el).getDistributedNodes(); }\n  resolveAndSetHref(el: HTMLAnchorElement, baseUrl: string, href: string) {\n    el.href = href == null ? baseUrl : baseUrl + '/../' + href;\n  }\n  supportsDOMEvents(): boolean { return true; }\n  supportsNativeShadowDOM(): boolean {\n    return typeof(<any>document.body).createShadowRoot === 'function';\n  }\n  getAnimationPrefix(): string { return this._animationPrefix ? this._animationPrefix : ''; }\n  getTransitionEnd(): string { return this._transitionEnd ? this._transitionEnd : ''; }\n  supportsAnimation(): boolean {\n    return this._animationPrefix != null && this._transitionEnd != null;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT as commonDOCUMENT} from '@angular/common';\nimport {InjectionToken} from '@angular/core';\n\n\n/**\n * A DI Token representing the main rendering context. In a browser this is the DOM Document.\n *\n * Note: Document might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application into a Web Worker).\n *\n * @deprecated import from `@angular/common` instead.\n * @publicApi\n */\nexport const DOCUMENT = commonDOCUMENT;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function supportsState(): boolean {\n  return !!window.history.pushState;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LocationChangeListener, PlatformLocation} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\nimport {getDOM} from '../../dom/dom_adapter';\nimport {DOCUMENT} from '../../dom/dom_tokens';\n\nimport {supportsState} from './history';\n\n\n\n/**\n * `PlatformLocation` encapsulates all of the direct calls to platform APIs.\n * This class should not be used directly by an application developer. Instead, use\n * {@link Location}.\n */\n@Injectable()\nexport class BrowserPlatformLocation extends PlatformLocation {\n  // TODO(issue/24571): remove '!'.\n  public readonly location !: Location;\n  // TODO(issue/24571): remove '!'.\n  private _history !: History;\n\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    super();\n    this._init();\n  }\n\n  // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it\n  /** @internal */\n  _init() {\n    (this as{location: Location}).location = getDOM().getLocation();\n    this._history = getDOM().getHistory();\n  }\n\n  getBaseHrefFromDOM(): string { return getDOM().getBaseHref(this._doc) !; }\n\n  onPopState(fn: LocationChangeListener): void {\n    getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);\n  }\n\n  onHashChange(fn: LocationChangeListener): void {\n    getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);\n  }\n\n  get pathname(): string { return this.location.pathname; }\n  get search(): string { return this.location.search; }\n  get hash(): string { return this.location.hash; }\n  set pathname(newPath: string) { this.location.pathname = newPath; }\n\n  pushState(state: any, title: string, url: string): void {\n    if (supportsState()) {\n      this._history.pushState(state, title, url);\n    } else {\n      this.location.hash = url;\n    }\n  }\n\n  replaceState(state: any, title: string, url: string): void {\n    if (supportsState()) {\n      this._history.replaceState(state, title, url);\n    } else {\n      this.location.hash = url;\n    }\n  }\n\n  forward(): void { this._history.forward(); }\n\n  back(): void { this._history.back(); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_INITIALIZER, ApplicationInitStatus, Inject, InjectionToken, Injector, StaticProvider} from '@angular/core';\n\nimport {getDOM} from '../dom/dom_adapter';\nimport {DOCUMENT} from '../dom/dom_tokens';\n\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n */\nexport const TRANSITION_ID = new InjectionToken('TRANSITION_ID');\n\nexport function appInitializerFactory(transitionId: string, document: any, injector: Injector) {\n  return () => {\n    // Wait for all application initializers to be completed before removing the styles set by\n    // the server.\n    injector.get(ApplicationInitStatus).donePromise.then(() => {\n      const dom = getDOM();\n      const styles: any[] =\n          Array.prototype.slice.apply(dom.querySelectorAll(document, `style[ng-transition]`));\n      styles.filter(el => dom.getAttribute(el, 'ng-transition') === transitionId)\n          .forEach(el => dom.remove(el));\n    });\n  };\n}\n\nexport const SERVER_TRANSITION_PROVIDERS: StaticProvider[] = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: appInitializerFactory,\n    deps: [TRANSITION_ID, DOCUMENT, Injector],\n    multi: true\n  },\n];\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {GetTestability, Testability, TestabilityRegistry, setTestabilityGetter, Éµglobal as global} from '@angular/core';\n\nimport {getDOM} from '../dom/dom_adapter';\n\nexport class BrowserGetTestability implements GetTestability {\n  static init() { setTestabilityGetter(new BrowserGetTestability()); }\n\n  addToWindow(registry: TestabilityRegistry): void {\n    global['getAngularTestability'] = (elem: any, findInAncestors: boolean = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new Error('Could not find testability for element.');\n      }\n      return testability;\n    };\n\n    global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n\n    global['getAllAngularRootElements'] = () => registry.getAllRootElements();\n\n    const whenAllStable = (callback: any /** TODO #9100 */) => {\n      const testabilities = global['getAllAngularTestabilities']();\n      let count = testabilities.length;\n      let didWork = false;\n      const decrement = function(didWork_: any /** TODO #9100 */) {\n        didWork = didWork || didWork_;\n        count--;\n        if (count == 0) {\n          callback(didWork);\n        }\n      };\n      testabilities.forEach(function(testability: any /** TODO #9100 */) {\n        testability.whenStable(decrement);\n      });\n    };\n\n    if (!global['frameworkStabilizers']) {\n      global['frameworkStabilizers'] = [];\n    }\n    global['frameworkStabilizers'].push(whenAllStable);\n  }\n\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);\n    }\n    return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as core from '@angular/core';\nimport {exportNgVar} from '../util';\n\nconst CORE_TOKENS = {\n  'ApplicationRef': core.ApplicationRef,\n  'NgZone': core.NgZone,\n};\n\nconst INSPECT_GLOBAL_NAME = 'probe';\nconst CORE_TOKENS_GLOBAL_NAME = 'coreTokens';\n\n/**\n * Returns a {@link DebugElement} for the given native DOM element, or\n * null if the given native element does not have an Angular view associated\n * with it.\n */\nexport function inspectNativeElement(element: any): core.DebugNode|null {\n  return core.getDebugNode(element);\n}\n\nexport function _createNgProbe(coreTokens: core.NgProbeToken[]): any {\n  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);\n  exportNgVar(CORE_TOKENS_GLOBAL_NAME, {...CORE_TOKENS, ..._ngProbeTokensToMap(coreTokens || [])});\n  return () => inspectNativeElement;\n}\n\nfunction _ngProbeTokensToMap(tokens: core.NgProbeToken[]): {[name: string]: any} {\n  return tokens.reduce((prev: any, t: any) => (prev[t.name] = t.token, prev), {});\n}\n\n/**\n * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n */\nexport const ELEMENT_PROBE_PROVIDERS: core.Provider[] = [\n  {\n    provide: core.APP_INITIALIZER,\n    useFactory: _createNgProbe,\n    deps: [\n      [core.NgProbeToken, new core.Optional()],\n    ],\n    multi: true,\n  },\n];\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, InjectionToken, NgZone} from '@angular/core';\n\nimport {getDOM} from '../dom_adapter';\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS =\n    new InjectionToken<EventManagerPlugin[]>('EventManagerPlugins');\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(@Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[], private _zone: NgZone) {\n    plugins.forEach(p => p.manager = this);\n    this._plugins = plugins.slice().reverse();\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler);\n  }\n\n  /**\n   * Registers a global handler for an event in a target view.\n   *\n   * @param target A target for global event notifications. One of \"window\", \"document\", or \"body\".\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns A callback function that can be used to remove the handler.\n   */\n  addGlobalEventListener(target: string, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addGlobalEventListener(target, eventName, handler);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone { return this._zone; }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    const plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    for (let i = 0; i < plugins.length; i++) {\n      const plugin = plugins[i];\n      if (plugin.supports(eventName)) {\n        this._eventNameToPlugin.set(eventName, plugin);\n        return plugin;\n      }\n    }\n    throw new Error(`No event manager plugin found for event ${eventName}`);\n  }\n}\n\nexport abstract class EventManagerPlugin {\n  constructor(private _doc: any) {}\n\n  // TODO(issue/24571): remove '!'.\n  manager !: EventManager;\n\n  abstract supports(eventName: string): boolean;\n\n  abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n\n  addGlobalEventListener(element: string, eventName: string, handler: Function): Function {\n    const target: HTMLElement = getDOM().getGlobalEventTarget(this._doc, element);\n    if (!target) {\n      throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n    }\n    return this.addEventListener(target, eventName, handler);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, ViewEncapsulation} from '@angular/core';\n\nimport {EventManager} from './events/event_manager';\nimport {DomSharedStylesHost} from './shared_styles_host';\n\nexport const NAMESPACE_URIS: {[ns: string]: string} = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/',\n};\n\nconst COMPONENT_REGEX = /%COMP%/g;\nexport const COMPONENT_VARIABLE = '%COMP%';\nexport const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nexport const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\nexport function shimContentAttribute(componentShortId: string): string {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function shimHostAttribute(componentShortId: string): string {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function flattenStyles(\n    compId: string, styles: Array<any|any[]>, target: string[]): string[] {\n  for (let i = 0; i < styles.length; i++) {\n    let style = styles[i];\n\n    if (Array.isArray(style)) {\n      flattenStyles(compId, style, target);\n    } else {\n      style = style.replace(COMPONENT_REGEX, compId);\n      target.push(style);\n    }\n  }\n  return target;\n}\n\nfunction decoratePreventDefault(eventHandler: Function): Function {\n  return (event: any) => {\n    const allowDefaultBehavior = eventHandler(event);\n    if (allowDefaultBehavior === false) {\n      // TODO(tbosch): move preventDefault into event plugins...\n      event.preventDefault();\n      event.returnValue = false;\n    }\n  };\n}\n\n@Injectable()\nexport class DomRendererFactory2 implements RendererFactory2 {\n  private rendererByCompId = new Map<string, Renderer2>();\n  private defaultRenderer: Renderer2;\n\n  constructor(private eventManager: EventManager, private sharedStylesHost: DomSharedStylesHost) {\n    this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n  }\n\n  createRenderer(element: any, type: RendererType2|null): Renderer2 {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    switch (type.encapsulation) {\n      case ViewEncapsulation.Emulated: {\n        let renderer = this.rendererByCompId.get(type.id);\n        if (!renderer) {\n          renderer =\n              new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);\n          this.rendererByCompId.set(type.id, renderer);\n        }\n        (<EmulatedEncapsulationDomRenderer2>renderer).applyToHost(element);\n        return renderer;\n      }\n      case ViewEncapsulation.Native:\n      case ViewEncapsulation.ShadowDom:\n        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n      default: {\n        if (!this.rendererByCompId.has(type.id)) {\n          const styles = flattenStyles(type.id, type.styles, []);\n          this.sharedStylesHost.addStyles(styles);\n          this.rendererByCompId.set(type.id, this.defaultRenderer);\n        }\n        return this.defaultRenderer;\n      }\n    }\n  }\n\n  begin() {}\n  end() {}\n}\n\nclass DefaultDomRenderer2 implements Renderer2 {\n  data: {[key: string]: any} = Object.create(null);\n\n  constructor(private eventManager: EventManager) {}\n\n  destroy(): void {}\n\n  destroyNode: null;\n\n  createElement(name: string, namespace?: string): any {\n    if (namespace) {\n      return document.createElementNS(NAMESPACE_URIS[namespace], name);\n    }\n\n    return document.createElement(name);\n  }\n\n  createComment(value: string): any { return document.createComment(value); }\n\n  createText(value: string): any { return document.createTextNode(value); }\n\n  appendChild(parent: any, newChild: any): void { parent.appendChild(newChild); }\n\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n\n  removeChild(parent: any, oldChild: any): void {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): any {\n    let el: any = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :\n                                                       selectorOrNode;\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n    return el;\n  }\n\n  parentNode(node: any): any { return node.parentNode; }\n\n  nextSibling(node: any): any { return node.nextSibling; }\n\n  setAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      name = `${namespace}:${name}`;\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n\n  removeAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n\n  addClass(el: any, name: string): void { el.classList.add(name); }\n\n  removeClass(el: any, name: string): void { el.classList.remove(name); }\n\n  setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.setProperty(\n          style, value, !!(flags & RendererStyleFlags2.Important) ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n\n  removeStyle(el: any, style: string, flags: RendererStyleFlags2): void {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      el.style[style] = '';\n    }\n  }\n\n  setProperty(el: any, name: string, value: any): void {\n    checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n\n  setValue(node: any, value: string): void { node.nodeValue = value; }\n\n  listen(target: 'window'|'document'|'body'|any, event: string, callback: (event: any) => boolean):\n      () => void {\n    checkNoSyntheticProp(event, 'listener');\n    if (typeof target === 'string') {\n      return <() => void>this.eventManager.addGlobalEventListener(\n          target, event, decoratePreventDefault(callback));\n    }\n    return <() => void>this.eventManager.addEventListener(\n               target, event, decoratePreventDefault(callback)) as() => void;\n  }\n}\n\nconst AT_CHARCODE = '@'.charCodeAt(0);\nfunction checkNoSyntheticProp(name: string, nameKind: string) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new Error(\n        `Found the synthetic ${nameKind} ${name}. Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.`);\n  }\n}\n\nclass EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {\n  private contentAttr: string;\n  private hostAttr: string;\n\n  constructor(\n      eventManager: EventManager, sharedStylesHost: DomSharedStylesHost,\n      private component: RendererType2) {\n    super(eventManager);\n    const styles = flattenStyles(component.id, component.styles, []);\n    sharedStylesHost.addStyles(styles);\n\n    this.contentAttr = shimContentAttribute(component.id);\n    this.hostAttr = shimHostAttribute(component.id);\n  }\n\n  applyToHost(element: any) { super.setAttribute(element, this.hostAttr, ''); }\n\n  createElement(parent: any, name: string): Element {\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n}\n\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n  private shadowRoot: any;\n\n  constructor(\n      eventManager: EventManager, private sharedStylesHost: DomSharedStylesHost,\n      private hostEl: any, private component: RendererType2) {\n    super(eventManager);\n    if (component.encapsulation === ViewEncapsulation.ShadowDom) {\n      this.shadowRoot = (hostEl as any).attachShadow({mode: 'open'});\n    } else {\n      this.shadowRoot = (hostEl as any).createShadowRoot();\n    }\n    this.sharedStylesHost.addHost(this.shadowRoot);\n    const styles = flattenStyles(component.id, component.styles, []);\n    for (let i = 0; i < styles.length; i++) {\n      const styleEl = document.createElement('style');\n      styleEl.textContent = styles[i];\n      this.shadowRoot.appendChild(styleEl);\n    }\n  }\n\n  private nodeOrShadowRoot(node: any): any { return node === this.hostEl ? this.shadowRoot : node; }\n\n  destroy() { this.sharedStylesHost.removeHost(this.shadowRoot); }\n\n  appendChild(parent: any, newChild: any): void {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n  removeChild(parent: any, oldChild: any): void {\n    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);\n  }\n  parentNode(node: any): any {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isPlatformServer} from '@angular/common';\nimport {Inject, Injectable, NgZone, Optional, PLATFORM_ID} from '@angular/core';\n\n\nimport {DOCUMENT} from '../dom_tokens';\n\nimport {EventManagerPlugin} from './event_manager';\n\n/**\n * Detect if Zone is present. If it is then use simple zone aware 'addEventListener'\n * since Angular can do much more\n * efficient bookkeeping than Zone can, because we have additional information. This speeds up\n * addEventListener by 3x.\n */\nconst __symbol__ =\n    (typeof Zone !== 'undefined') && (Zone as any)['__symbol__'] || function(v: string): string {\n      return '__zone_symbol__' + v;\n    };\nconst ADD_EVENT_LISTENER: 'addEventListener' = __symbol__('addEventListener');\nconst REMOVE_EVENT_LISTENER: 'removeEventListener' = __symbol__('removeEventListener');\n\nconst symbolNames: {[key: string]: string} = {};\n\nconst FALSE = 'FALSE';\nconst ANGULAR = 'ANGULAR';\nconst NATIVE_ADD_LISTENER = 'addEventListener';\nconst NATIVE_REMOVE_LISTENER = 'removeEventListener';\n\n// use the same symbol string which is used in zone.js\nconst stopSymbol = '__zone_symbol__propagationStopped';\nconst stopMethodSymbol = '__zone_symbol__stopImmediatePropagation';\n\nconst blackListedEvents: string[] =\n    (typeof Zone !== 'undefined') && (Zone as any)[__symbol__('BLACK_LISTED_EVENTS')];\nlet blackListedMap: {[eventName: string]: string};\nif (blackListedEvents) {\n  blackListedMap = {};\n  blackListedEvents.forEach(eventName => { blackListedMap[eventName] = eventName; });\n}\n\nconst isBlackListedEvent = function(eventName: string) {\n  if (!blackListedMap) {\n    return false;\n  }\n  return blackListedMap.hasOwnProperty(eventName);\n};\n\ninterface TaskData {\n  zone: any;\n  handler: Function;\n}\n\n// a global listener to handle all dom event,\n// so we do not need to create a closure every time\nconst globalListener = function(event: Event) {\n  const symbolName = symbolNames[event.type];\n  if (!symbolName) {\n    return;\n  }\n  const taskDatas: TaskData[] = this[symbolName];\n  if (!taskDatas) {\n    return;\n  }\n  const args: any = [event];\n  if (taskDatas.length === 1) {\n    // if taskDatas only have one element, just invoke it\n    const taskData = taskDatas[0];\n    if (taskData.zone !== Zone.current) {\n      // only use Zone.run when Zone.current not equals to stored zone\n      return taskData.zone.run(taskData.handler, this, args);\n    } else {\n      return taskData.handler.apply(this, args);\n    }\n  } else {\n    // copy tasks as a snapshot to avoid event handlers remove\n    // itself or others\n    const copiedTasks = taskDatas.slice();\n    for (let i = 0; i < copiedTasks.length; i++) {\n      // if other listener call event.stopImmediatePropagation\n      // just break\n      if ((event as any)[stopSymbol] === true) {\n        break;\n      }\n      const taskData = copiedTasks[i];\n      if (taskData.zone !== Zone.current) {\n        // only use Zone.run when Zone.current not equals to stored zone\n        taskData.zone.run(taskData.handler, this, args);\n      } else {\n        taskData.handler.apply(this, args);\n      }\n    }\n  }\n};\n\n@Injectable()\nexport class DomEventsPlugin extends EventManagerPlugin {\n  constructor(\n      @Inject(DOCUMENT) doc: any, private ngZone: NgZone,\n      @Optional() @Inject(PLATFORM_ID) platformId: {}|null) {\n    super(doc);\n\n    if (!platformId || !isPlatformServer(platformId)) {\n      this.patchEvent();\n    }\n  }\n\n  private patchEvent() {\n    if (typeof Event === 'undefined' || !Event || !Event.prototype) {\n      return;\n    }\n    if ((Event.prototype as any)[stopMethodSymbol]) {\n      // already patched by zone.js\n      return;\n    }\n    const delegate = (Event.prototype as any)[stopMethodSymbol] =\n        Event.prototype.stopImmediatePropagation;\n    Event.prototype.stopImmediatePropagation = function() {\n      if (this) {\n        this[stopSymbol] = true;\n      }\n\n      // should call native delegate in case\n      // in some environment part of the application\n      // will not use the patched Event\n      delegate && delegate.apply(this, arguments);\n    };\n  }\n\n  // This plugin should come last in the list of plugins, because it accepts all\n  // events.\n  supports(eventName: string): boolean { return true; }\n\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    /**\n     * This code is about to add a listener to the DOM. If Zone.js is present, than\n     * `addEventListener` has been patched. The patched code adds overhead in both\n     * memory and speed (3x slower) than native. For this reason if we detect that\n     * Zone.js is present we use a simple version of zone aware addEventListener instead.\n     * The result is faster registration and the zone will be restored.\n     * But ZoneSpec.onScheduleTask, ZoneSpec.onInvokeTask, ZoneSpec.onCancelTask\n     * will not be invoked\n     * We also do manual zone restoration in element.ts renderEventHandlerClosure method.\n     *\n     * NOTE: it is possible that the element is from different iframe, and so we\n     * have to check before we execute the method.\n     */\n    const self = this;\n    const zoneJsLoaded = element[ADD_EVENT_LISTENER];\n    let callback: EventListener = handler as EventListener;\n    // if zonejs is loaded and current zone is not ngZone\n    // we keep Zone.current on target for later restoration.\n    if (zoneJsLoaded && (!NgZone.isInAngularZone() || isBlackListedEvent(eventName))) {\n      let symbolName = symbolNames[eventName];\n      if (!symbolName) {\n        symbolName = symbolNames[eventName] = __symbol__(ANGULAR + eventName + FALSE);\n      }\n      let taskDatas: TaskData[] = (element as any)[symbolName];\n      const globalListenerRegistered = taskDatas && taskDatas.length > 0;\n      if (!taskDatas) {\n        taskDatas = (element as any)[symbolName] = [];\n      }\n\n      const zone = isBlackListedEvent(eventName) ? Zone.root : Zone.current;\n      if (taskDatas.length === 0) {\n        taskDatas.push({zone: zone, handler: callback});\n      } else {\n        let callbackRegistered = false;\n        for (let i = 0; i < taskDatas.length; i++) {\n          if (taskDatas[i].handler === callback) {\n            callbackRegistered = true;\n            break;\n          }\n        }\n        if (!callbackRegistered) {\n          taskDatas.push({zone: zone, handler: callback});\n        }\n      }\n\n      if (!globalListenerRegistered) {\n        element[ADD_EVENT_LISTENER](eventName, globalListener, false);\n      }\n    } else {\n      element[NATIVE_ADD_LISTENER](eventName, callback, false);\n    }\n    return () => this.removeEventListener(element, eventName, callback);\n  }\n\n  removeEventListener(target: any, eventName: string, callback: Function): void {\n    let underlyingRemove = target[REMOVE_EVENT_LISTENER];\n    // zone.js not loaded, use native removeEventListener\n    if (!underlyingRemove) {\n      return target[NATIVE_REMOVE_LISTENER].apply(target, [eventName, callback, false]);\n    }\n    let symbolName = symbolNames[eventName];\n    let taskDatas: TaskData[] = symbolName && target[symbolName];\n    if (!taskDatas) {\n      // addEventListener not using patched version\n      // just call native removeEventListener\n      return target[NATIVE_REMOVE_LISTENER].apply(target, [eventName, callback, false]);\n    }\n    // fix issue 20532, should be able to remove\n    // listener which was added inside of ngZone\n    let found = false;\n    for (let i = 0; i < taskDatas.length; i++) {\n      // remove listener from taskDatas if the callback equals\n      if (taskDatas[i].handler === callback) {\n        found = true;\n        taskDatas.splice(i, 1);\n        break;\n      }\n    }\n    if (found) {\n      if (taskDatas.length === 0) {\n        // all listeners are removed, we can remove the globalListener from target\n        underlyingRemove.apply(target, [eventName, globalListener, false]);\n      }\n    } else {\n      // not found in taskDatas, the callback may be added inside of ngZone\n      // use native remove listener to remove the callback\n      target[NATIVE_REMOVE_LISTENER].apply(target, [eventName, callback, false]);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, InjectionToken, Optional, ÉµConsole as Console} from '@angular/core';\n\nimport {DOCUMENT} from '../dom_tokens';\n\nimport {EventManagerPlugin} from './event_manager';\n\n/**\n * Supported HammerJS recognizer event names.\n */\nconst EVENT_NAMES = {\n  // pan\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  // pinch\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  // press\n  'press': true,\n  'pressup': true,\n  // rotate\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  // swipe\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  // tap\n  'tap': true,\n};\n\n/**\n * DI token for providing [HammerJS](http://hammerjs.github.io/) support to Angular.\n * @see `HammerGestureConfig`\n *\n * @publicApi\n */\nexport const HAMMER_GESTURE_CONFIG = new InjectionToken<HammerGestureConfig>('HammerGestureConfig');\n\n\n/**\n * Function that loads HammerJS, returning a promise that is resolved once HammerJs is loaded.\n *\n * @publicApi\n */\nexport type HammerLoader = () => Promise<void>;\n\n/**\n * Injection token used to provide a {@link HammerLoader} to Angular.\n *\n * @publicApi\n */\nexport const HAMMER_LOADER = new InjectionToken<HammerLoader>('HammerLoader');\n\nexport interface HammerInstance {\n  on(eventName: string, callback?: Function): void;\n  off(eventName: string, callback?: Function): void;\n  destroy?(): void;\n}\n\n/**\n * An injectable [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)\n * for gesture recognition. Configures specific event recognition.\n * @publicApi\n */\n@Injectable()\nexport class HammerGestureConfig {\n  /**\n   * A set of supported event names for gestures to be used in Angular.\n   * Angular supports all built-in recognizers, as listed in\n   * [HammerJS documentation](http://hammerjs.github.io/).\n   */\n  events: string[] = [];\n\n  /**\n  * Maps gesture event names to a set of configuration options\n  * that specify overrides to the default values for specific properties.\n  *\n  * The key is a supported event name to be configured,\n  * and the options object contains a set of properties, with override values\n  * to be applied to the named recognizer event.\n  * For example, to disable recognition of the rotate event, specify\n  *  `{\"rotate\": {\"enable\": false}}`.\n  *\n  * Properties that are not present take the HammerJS default values.\n  * For information about which properties are supported for which events,\n  * and their allowed and default values, see\n  * [HammerJS documentation](http://hammerjs.github.io/).\n  *\n  */\n  overrides: {[key: string]: Object} = {};\n\n  /**\n   * Properties whose default values can be overridden for a given event.\n   * Different sets of properties apply to different events.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](http://hammerjs.github.io/).\n   */\n  options?: {\n    cssProps?: any; domEvents?: boolean; enable?: boolean | ((manager: any) => boolean);\n    preset?: any[];\n    touchAction?: string;\n    recognizers?: any[];\n    inputClass?: any;\n    inputTarget?: EventTarget;\n  };\n\n  /**\n   * Creates a [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)\n   * and attaches it to a given HTML element.\n   * @param element The element that will recognize gestures.\n   * @returns A HammerJS event-manager object.\n   */\n  buildHammer(element: HTMLElement): HammerInstance {\n    const mc = new Hammer !(element, this.options);\n\n    mc.get('pinch').set({enable: true});\n    mc.get('rotate').set({enable: true});\n\n    for (const eventName in this.overrides) {\n      mc.get(eventName).set(this.overrides[eventName]);\n    }\n\n    return mc;\n  }\n}\n\n@Injectable()\nexport class HammerGesturesPlugin extends EventManagerPlugin {\n  constructor(\n      @Inject(DOCUMENT) doc: any,\n      @Inject(HAMMER_GESTURE_CONFIG) private _config: HammerGestureConfig, private console: Console,\n      @Optional() @Inject(HAMMER_LOADER) private loader?: HammerLoader|null) {\n    super(doc);\n  }\n\n  supports(eventName: string): boolean {\n    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n      return false;\n    }\n\n    if (!(window as any).Hammer && !this.loader) {\n      this.console.warn(\n          `The \"${eventName}\" event cannot be bound because Hammer.JS is not ` +\n          `loaded and no custom loader has been specified.`);\n      return false;\n    }\n\n    return true;\n  }\n\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const zone = this.manager.getZone();\n    eventName = eventName.toLowerCase();\n\n    // If Hammer is not present but a loader is specified, we defer adding the event listener\n    // until Hammer is loaded.\n    if (!(window as any).Hammer && this.loader) {\n      // This `addEventListener` method returns a function to remove the added listener.\n      // Until Hammer is loaded, the returned function needs to *cancel* the registration rather\n      // than remove anything.\n      let cancelRegistration = false;\n      let deregister: Function = () => { cancelRegistration = true; };\n\n      this.loader()\n          .then(() => {\n            // If Hammer isn't actually loaded when the custom loader resolves, give up.\n            if (!(window as any).Hammer) {\n              this.console.warn(\n                  `The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n              deregister = () => {};\n              return;\n            }\n\n            if (!cancelRegistration) {\n              // Now that Hammer is loaded and the listener is being loaded for real,\n              // the deregistration function changes from canceling registration to removal.\n              deregister = this.addEventListener(element, eventName, handler);\n            }\n          })\n          .catch(() => {\n            this.console.warn(\n                `The \"${eventName}\" event cannot be bound because the custom ` +\n                `Hammer.JS loader failed.`);\n            deregister = () => {};\n          });\n\n      // Return a function that *executes* `deregister` (and not `deregister` itself) so that we\n      // can change the behavior of `deregister` once the listener is added. Using a closure in\n      // this way allows us to avoid any additional data structures to track listener removal.\n      return () => { deregister(); };\n    }\n\n    return zone.runOutsideAngular(() => {\n      // Creating the manager bind events, must be done outside of angular\n      const mc = this._config.buildHammer(element);\n      const callback = function(eventObj: HammerInput) {\n        zone.runGuarded(function() { handler(eventObj); });\n      };\n      mc.on(eventName, callback);\n      return () => {\n        mc.off(eventName, callback);\n        // destroy mc to prevent memory leak\n        if (typeof mc.destroy === 'function') {\n          mc.destroy();\n        }\n      };\n    });\n  }\n\n  isCustomEvent(eventName: string): boolean { return this._config.events.indexOf(eventName) > -1; }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule, PlatformLocation, ÉµPLATFORM_BROWSER_ID as PLATFORM_BROWSER_ID} from '@angular/common';\nimport {APP_ID, ApplicationModule, ErrorHandler, Inject, ModuleWithProviders, NgModule, NgZone, Optional, PLATFORM_ID, PLATFORM_INITIALIZER, PlatformRef, RendererFactory2, Sanitizer, SkipSelf, StaticProvider, Testability, createPlatformFactory, platformCore, ÉµAPP_ROOT as APP_ROOT, ÉµConsole as Console} from '@angular/core';\n\nimport {BrowserDomAdapter} from './browser/browser_adapter';\nimport {BrowserPlatformLocation} from './browser/location/browser_platform_location';\nimport {SERVER_TRANSITION_PROVIDERS, TRANSITION_ID} from './browser/server-transition';\nimport {BrowserGetTestability} from './browser/testability';\nimport {ELEMENT_PROBE_PROVIDERS} from './dom/debug/ng_probe';\nimport {DomRendererFactory2} from './dom/dom_renderer';\nimport {DOCUMENT} from './dom/dom_tokens';\nimport {DomEventsPlugin} from './dom/events/dom_events';\nimport {EVENT_MANAGER_PLUGINS, EventManager} from './dom/events/event_manager';\nimport {HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerGesturesPlugin} from './dom/events/hammer_gestures';\nimport {KeyEventsPlugin} from './dom/events/key_events';\nimport {DomSharedStylesHost, SharedStylesHost} from './dom/shared_styles_host';\nimport {DomSanitizer, DomSanitizerImpl} from './security/dom_sanitization_service';\n\nexport const INTERNAL_BROWSER_PLATFORM_PROVIDERS: StaticProvider[] = [\n  {provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID},\n  {provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true},\n  {provide: PlatformLocation, useClass: BrowserPlatformLocation, deps: [DOCUMENT]},\n  {provide: DOCUMENT, useFactory: _document, deps: []},\n];\n\n/**\n * @security Replacing built-in sanitization providers exposes the application to XSS risks.\n * Attacker-controlled data introduced by an unsanitized provider could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n * @publicApi\n */\nexport const BROWSER_SANITIZATION_PROVIDERS: StaticProvider[] = [\n  {provide: Sanitizer, useExisting: DomSanitizer},\n  {provide: DomSanitizer, useClass: DomSanitizerImpl, deps: [DOCUMENT]},\n];\n\n/**\n * @publicApi\n */\nexport const platformBrowser: (extraProviders?: StaticProvider[]) => PlatformRef =\n    createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n\nexport function initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n  BrowserGetTestability.init();\n}\n\nexport function errorHandler(): ErrorHandler {\n  return new ErrorHandler();\n}\n\nexport function _document(): any {\n  return document;\n}\n\nexport const BROWSER_MODULE_PROVIDERS: StaticProvider[] = [\n  BROWSER_SANITIZATION_PROVIDERS,\n  {provide: APP_ROOT, useValue: true},\n  {provide: ErrorHandler, useFactory: errorHandler, deps: []},\n  {\n    provide: EVENT_MANAGER_PLUGINS,\n    useClass: DomEventsPlugin,\n    multi: true,\n    deps: [DOCUMENT, NgZone, PLATFORM_ID]\n  },\n  {provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT]},\n  {\n    provide: EVENT_MANAGER_PLUGINS,\n    useClass: HammerGesturesPlugin,\n    multi: true,\n    deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]\n  },\n  {provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: []},\n  {\n    provide: DomRendererFactory2,\n    useClass: DomRendererFactory2,\n    deps: [EventManager, DomSharedStylesHost]\n  },\n  {provide: RendererFactory2, useExisting: DomRendererFactory2},\n  {provide: SharedStylesHost, useExisting: DomSharedStylesHost},\n  {provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [DOCUMENT]},\n  {provide: Testability, useClass: Testability, deps: [NgZone]},\n  {provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, NgZone]},\n  ELEMENT_PROBE_PROVIDERS,\n];\n\n/**\n * Exports required infrastructure for all Angular apps.\n * Included by defaults in all Angular apps created with the CLI\n * `new` command.\n * Re-exports `CommonModule` and `ApplicationModule`, making their\n * exports and providers available to all apps.\n *\n * @publicApi\n */\n@NgModule({providers: BROWSER_MODULE_PROVIDERS, exports: [CommonModule, ApplicationModule]})\nexport class BrowserModule {\n  constructor(@Optional() @SkipSelf() @Inject(BrowserModule) parentModule: BrowserModule|null) {\n    if (parentModule) {\n      throw new Error(\n          `BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);\n    }\n  }\n\n  /**\n   * Configures a browser-based app to transition from a server-rendered app, if\n   * one is present on the page.\n   *\n   * @param params An object containing an identifier for the app to transition.\n   * The ID must match between the client and server versions of the app.\n   * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.\n   */\n  static withServerTransition(params: {appId: string}): ModuleWithProviders<BrowserModule> {\n    return {\n      ngModule: BrowserModule,\n      providers: [\n        {provide: APP_ID, useValue: params.appId},\n        {provide: TRANSITION_ID, useExisting: APP_ID},\n        SERVER_TRANSITION_PROVIDERS,\n      ],\n    };\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const PLATFORM_BROWSER_ID = 'browser';\nexport const PLATFORM_SERVER_ID = 'server';\nexport const PLATFORM_WORKER_APP_ID = 'browserWorkerApp';\nexport const PLATFORM_WORKER_UI_ID = 'browserWorkerUi';\n\n/**\n * Returns whether a platform id represents a browser platform.\n * @publicApi\n */\nexport function isPlatformBrowser(platformId: Object): boolean {\n  return platformId === PLATFORM_BROWSER_ID;\n}\n\n/**\n * Returns whether a platform id represents a server platform.\n * @publicApi\n */\nexport function isPlatformServer(platformId: Object): boolean {\n  return platformId === PLATFORM_SERVER_ID;\n}\n\n/**\n * Returns whether a platform id represents a web worker app platform.\n * @publicApi\n */\nexport function isPlatformWorkerApp(platformId: Object): boolean {\n  return platformId === PLATFORM_WORKER_APP_ID;\n}\n\n/**\n * Returns whether a platform id represents a web worker UI platform.\n * @publicApi\n */\nexport function isPlatformWorkerUi(platformId: Object): boolean {\n  return platformId === PLATFORM_WORKER_UI_ID;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n\nimport {Version} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('0.0.0-PLACEHOLDER');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, inject} from '@angular/core';\n\nimport {getDOM} from '../dom/dom_adapter';\nimport {DOCUMENT} from '../dom/dom_tokens';\n\n/**\n * Factory to create Title service.\n */\nexport function createTitle() {\n  return new Title(inject(DOCUMENT));\n}\n\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: createTitle, deps: []})\nexport class Title {\n  constructor(@Inject(DOCUMENT) private _doc: any) {}\n  /**\n   * Get the title of the current HTML document.\n   */\n  getTitle(): string { return getDOM().getTitle(this._doc); }\n\n  /**\n   * Set the title of the current HTML document.\n   * @param newTitle\n   */\n  setTitle(newTitle: string) { getDOM().setTitle(this._doc, newTitle); }\n}\n","import { Component, NgModule } from '@angular/core';\n\n@Component({ selector: 'hello-world', template: 'Hello World!' })\nexport class AppComponent { }\n\n@NgModule({ declarations: [AppComponent], bootstrap: [AppComponent] })\nexport class AppModule { }\n","Hello World!","import { enableProdMode } from '@angular/core';\nimport { platformBrowser } from '@angular/platform-browser';\nimport { AppModuleNgFactory } from './app.module.ngfactory';\n\nenableProdMode();\n\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory).catch(err => console.error(err));\n"]}